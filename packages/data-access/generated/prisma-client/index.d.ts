
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Account
 * 
 */
export type Account = {
  id: string
  userId: string
  type: string
  provider: string
  providerAccountId: string
  refresh_token: string | null
  access_token: string | null
  expires_at: number | null
  token_type: string | null
  scope: string | null
  id_token: string | null
  session_state: string | null
  oauth_token_secret: string | null
  oauth_token: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Session
 * 
 */
export type Session = {
  id: string
  sessionToken: string
  userId: string
  expires: Date
  createdAt: Date
  updatedAt: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  firstName: string
  lastName: string
  username: string | null
  email: string
  emailVerified: boolean
  hashedPassword: string | null
  dialCode: string | null
  phone: string | null
  termsAccepted: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Driver
 * 
 */
export type Driver = {
  id: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Vendor
 * 
 */
export type Vendor = {
  id: string
  name: string
  publicName: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Address
 * 
 */
export type Address = {
  id: string
  street1: string
  street2: string | null
  city: string
  state: string
  zipcode: string
  country: string
  countryCode: string | null
  coordinateId: string | null
  userId: string | null
  organizationId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ImageOrganization
 * 
 */
export type ImageOrganization = {
  id: string
  location: string
  organizationId: string
  blurhash: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ImageProduct
 * 
 */
export type ImageProduct = {
  id: string
  location: string
  productId: string
  blurhash: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ImageUser
 * 
 */
export type ImageUser = {
  id: string
  location: string
  userId: string
  blurhash: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ImageVendor
 * 
 */
export type ImageVendor = {
  id: string
  location: string
  blurhash: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Coordinates
 * 
 */
export type Coordinates = {
  id: string
  latitude: number
  longitude: number
  radius: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Membership
 * 
 */
export type Membership = {
  id: string
  role: MembershipRole
  userId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Order
 * 
 */
export type Order = {
  id: string
  total: number
  status: OrderStatus
  customerId: string
  driverId: string | null
  organizationId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Payment
 * 
 */
export type Payment = {
  id: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Organization
 * 
 */
export type Organization = {
  id: string
  name: string
  email: string
  emailVerified: boolean
  dialCode: string | null
  phone: string | null
  vendorId: string
  subdomainId: string
  termsAccepted: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model organizationMembership
 * 
 */
export type organizationMembership = {
  organizationId: string
  membershipId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: string
  name: string
  description: string | null
  features: string | null
  unit: Unit
  size: number
  basePrice: number
  currency: Currency
  discount: number
  quantity: number
  stock: number
  organizationId: string
  rating: number | null
  tags: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Category
 * 
 */
export type Category = {
  id: string
  name: string
  slug: string
  icon: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model CategoryList
 * 
 */
export type CategoryList = {
  id: string
  name: string
  slug: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ServiceList
 * 
 */
export type ServiceList = {
  id: string
  name: string
  slug: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Service
 * 
 */
export type Service = {
  id: string
  title: string
  subtitle: string | null
  slug: string
  icon: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Review
 * 
 */
export type Review = {
  id: string
  rating: number
  comment: string | null
  productId: string
  userId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model SiteSetting
 * 
 */
export type SiteSetting = {
  id: string
  organizationId: string
  description: string | null
  title: string
  bannerText: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model SubDomain
 * 
 */
export type SubDomain = {
  subdomain: string
  isValid: boolean
  createdAt: Date
  updatedAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const Currency: {
  USD: 'USD'
};

export type Currency = (typeof Currency)[keyof typeof Currency]


export const MembershipRole: {
  MEMBER: 'MEMBER',
  ADMIN: 'ADMIN',
  OWNER: 'OWNER'
};

export type MembershipRole = (typeof MembershipRole)[keyof typeof MembershipRole]


export const OrderStatus: {
  Pending: 'Pending',
  Processing: 'Processing',
  Delivered: 'Delivered',
  Cancelled: 'Cancelled'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const Unit: {
  g: 'g'
};

export type Unit = (typeof Unit)[keyof typeof Unit]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.driver`: Exposes CRUD operations for the **Driver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.driver.findMany()
    * ```
    */
  get driver(): Prisma.DriverDelegate<GlobalReject>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<GlobalReject>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<GlobalReject>;

  /**
   * `prisma.imageOrganization`: Exposes CRUD operations for the **ImageOrganization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImageOrganizations
    * const imageOrganizations = await prisma.imageOrganization.findMany()
    * ```
    */
  get imageOrganization(): Prisma.ImageOrganizationDelegate<GlobalReject>;

  /**
   * `prisma.imageProduct`: Exposes CRUD operations for the **ImageProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImageProducts
    * const imageProducts = await prisma.imageProduct.findMany()
    * ```
    */
  get imageProduct(): Prisma.ImageProductDelegate<GlobalReject>;

  /**
   * `prisma.imageUser`: Exposes CRUD operations for the **ImageUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImageUsers
    * const imageUsers = await prisma.imageUser.findMany()
    * ```
    */
  get imageUser(): Prisma.ImageUserDelegate<GlobalReject>;

  /**
   * `prisma.imageVendor`: Exposes CRUD operations for the **ImageVendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImageVendors
    * const imageVendors = await prisma.imageVendor.findMany()
    * ```
    */
  get imageVendor(): Prisma.ImageVendorDelegate<GlobalReject>;

  /**
   * `prisma.coordinates`: Exposes CRUD operations for the **Coordinates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coordinates
    * const coordinates = await prisma.coordinates.findMany()
    * ```
    */
  get coordinates(): Prisma.CoordinatesDelegate<GlobalReject>;

  /**
   * `prisma.membership`: Exposes CRUD operations for the **Membership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memberships
    * const memberships = await prisma.membership.findMany()
    * ```
    */
  get membership(): Prisma.MembershipDelegate<GlobalReject>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<GlobalReject>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<GlobalReject>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<GlobalReject>;

  /**
   * `prisma.organizationMembership`: Exposes CRUD operations for the **organizationMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationMemberships
    * const organizationMemberships = await prisma.organizationMembership.findMany()
    * ```
    */
  get organizationMembership(): Prisma.organizationMembershipDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<GlobalReject>;

  /**
   * `prisma.categoryList`: Exposes CRUD operations for the **CategoryList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoryLists
    * const categoryLists = await prisma.categoryList.findMany()
    * ```
    */
  get categoryList(): Prisma.CategoryListDelegate<GlobalReject>;

  /**
   * `prisma.serviceList`: Exposes CRUD operations for the **ServiceList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceLists
    * const serviceLists = await prisma.serviceList.findMany()
    * ```
    */
  get serviceList(): Prisma.ServiceListDelegate<GlobalReject>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<GlobalReject>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<GlobalReject>;

  /**
   * `prisma.siteSetting`: Exposes CRUD operations for the **SiteSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteSettings
    * const siteSettings = await prisma.siteSetting.findMany()
    * ```
    */
  get siteSetting(): Prisma.SiteSettingDelegate<GlobalReject>;

  /**
   * `prisma.subDomain`: Exposes CRUD operations for the **SubDomain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubDomains
    * const subDomains = await prisma.subDomain.findMany()
    * ```
    */
  get subDomain(): Prisma.SubDomainDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.4.0
   * Query Engine version: f352a33b70356f46311da8b00d83386dd9f145d6
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Account: 'Account',
    Session: 'Session',
    User: 'User',
    Driver: 'Driver',
    Vendor: 'Vendor',
    Address: 'Address',
    ImageOrganization: 'ImageOrganization',
    ImageProduct: 'ImageProduct',
    ImageUser: 'ImageUser',
    ImageVendor: 'ImageVendor',
    Coordinates: 'Coordinates',
    Membership: 'Membership',
    Order: 'Order',
    Payment: 'Payment',
    Organization: 'Organization',
    organizationMembership: 'organizationMembership',
    Product: 'Product',
    Category: 'Category',
    CategoryList: 'CategoryList',
    ServiceList: 'ServiceList',
    Service: 'Service',
    Review: 'Review',
    SiteSetting: 'SiteSetting',
    SubDomain: 'SubDomain'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    address: number
    imageUser: number
    accounts: number
    sessions: number
    reviews: number
    memberships: number
    orders: number
  }

  export type UserCountOutputTypeSelect = {
    address?: boolean
    imageUser?: boolean
    accounts?: boolean
    sessions?: boolean
    reviews?: boolean
    memberships?: boolean
    orders?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type DriverCountOutputType
   */


  export type DriverCountOutputType = {
    orders: number
  }

  export type DriverCountOutputTypeSelect = {
    orders?: boolean
  }

  export type DriverCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DriverCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DriverCountOutputType
    : S extends undefined
    ? never
    : S extends DriverCountOutputTypeArgs
    ?'include' extends U
    ? DriverCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DriverCountOutputType ? DriverCountOutputType[P] : never
  } 
    : DriverCountOutputType
  : DriverCountOutputType




  // Custom InputTypes

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DriverCountOutputType
     * 
    **/
    select?: DriverCountOutputTypeSelect | null
  }



  /**
   * Count Type VendorCountOutputType
   */


  export type VendorCountOutputType = {
    organizations: number
  }

  export type VendorCountOutputTypeSelect = {
    organizations?: boolean
  }

  export type VendorCountOutputTypeGetPayload<
    S extends boolean | null | undefined | VendorCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? VendorCountOutputType
    : S extends undefined
    ? never
    : S extends VendorCountOutputTypeArgs
    ?'include' extends U
    ? VendorCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof VendorCountOutputType ? VendorCountOutputType[P] : never
  } 
    : VendorCountOutputType
  : VendorCountOutputType




  // Custom InputTypes

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     * 
    **/
    select?: VendorCountOutputTypeSelect | null
  }



  /**
   * Count Type CoordinatesCountOutputType
   */


  export type CoordinatesCountOutputType = {
    addresses: number
  }

  export type CoordinatesCountOutputTypeSelect = {
    addresses?: boolean
  }

  export type CoordinatesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CoordinatesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CoordinatesCountOutputType
    : S extends undefined
    ? never
    : S extends CoordinatesCountOutputTypeArgs
    ?'include' extends U
    ? CoordinatesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CoordinatesCountOutputType ? CoordinatesCountOutputType[P] : never
  } 
    : CoordinatesCountOutputType
  : CoordinatesCountOutputType




  // Custom InputTypes

  /**
   * CoordinatesCountOutputType without action
   */
  export type CoordinatesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CoordinatesCountOutputType
     * 
    **/
    select?: CoordinatesCountOutputTypeSelect | null
  }



  /**
   * Count Type MembershipCountOutputType
   */


  export type MembershipCountOutputType = {
    organizations: number
  }

  export type MembershipCountOutputTypeSelect = {
    organizations?: boolean
  }

  export type MembershipCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MembershipCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MembershipCountOutputType
    : S extends undefined
    ? never
    : S extends MembershipCountOutputTypeArgs
    ?'include' extends U
    ? MembershipCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof MembershipCountOutputType ? MembershipCountOutputType[P] : never
  } 
    : MembershipCountOutputType
  : MembershipCountOutputType




  // Custom InputTypes

  /**
   * MembershipCountOutputType without action
   */
  export type MembershipCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MembershipCountOutputType
     * 
    **/
    select?: MembershipCountOutputTypeSelect | null
  }



  /**
   * Count Type OrderCountOutputType
   */


  export type OrderCountOutputType = {
    items: number
  }

  export type OrderCountOutputTypeSelect = {
    items?: boolean
  }

  export type OrderCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OrderCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OrderCountOutputType
    : S extends undefined
    ? never
    : S extends OrderCountOutputTypeArgs
    ?'include' extends U
    ? OrderCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OrderCountOutputType ? OrderCountOutputType[P] : never
  } 
    : OrderCountOutputType
  : OrderCountOutputType




  // Custom InputTypes

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     * 
    **/
    select?: OrderCountOutputTypeSelect | null
  }



  /**
   * Count Type OrganizationCountOutputType
   */


  export type OrganizationCountOutputType = {
    images: number
    memberships: number
    products: number
    orders: number
  }

  export type OrganizationCountOutputTypeSelect = {
    images?: boolean
    memberships?: boolean
    products?: boolean
    orders?: boolean
  }

  export type OrganizationCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OrganizationCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OrganizationCountOutputType
    : S extends undefined
    ? never
    : S extends OrganizationCountOutputTypeArgs
    ?'include' extends U
    ? OrganizationCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OrganizationCountOutputType ? OrganizationCountOutputType[P] : never
  } 
    : OrganizationCountOutputType
  : OrganizationCountOutputType




  // Custom InputTypes

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     * 
    **/
    select?: OrganizationCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    categories: number
    images: number
    orders: number
    reviews: number
  }

  export type ProductCountOutputTypeSelect = {
    categories?: boolean
    images?: boolean
    orders?: boolean
    reviews?: boolean
  }

  export type ProductCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductCountOutputType
    : S extends undefined
    ? never
    : S extends ProductCountOutputTypeArgs
    ?'include' extends U
    ? ProductCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProductCountOutputType ? ProductCountOutputType[P] : never
  } 
    : ProductCountOutputType
  : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     * 
    **/
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Count Type CategoryCountOutputType
   */


  export type CategoryCountOutputType = {
    products: number
    categoryLists: number
  }

  export type CategoryCountOutputTypeSelect = {
    products?: boolean
    categoryLists?: boolean
  }

  export type CategoryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CategoryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CategoryCountOutputType
    : S extends undefined
    ? never
    : S extends CategoryCountOutputTypeArgs
    ?'include' extends U
    ? CategoryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CategoryCountOutputType ? CategoryCountOutputType[P] : never
  } 
    : CategoryCountOutputType
  : CategoryCountOutputType




  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     * 
    **/
    select?: CategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type CategoryListCountOutputType
   */


  export type CategoryListCountOutputType = {
    categories: number
  }

  export type CategoryListCountOutputTypeSelect = {
    categories?: boolean
  }

  export type CategoryListCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CategoryListCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CategoryListCountOutputType
    : S extends undefined
    ? never
    : S extends CategoryListCountOutputTypeArgs
    ?'include' extends U
    ? CategoryListCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CategoryListCountOutputType ? CategoryListCountOutputType[P] : never
  } 
    : CategoryListCountOutputType
  : CategoryListCountOutputType




  // Custom InputTypes

  /**
   * CategoryListCountOutputType without action
   */
  export type CategoryListCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoryListCountOutputType
     * 
    **/
    select?: CategoryListCountOutputTypeSelect | null
  }



  /**
   * Count Type ServiceListCountOutputType
   */


  export type ServiceListCountOutputType = {
    services: number
  }

  export type ServiceListCountOutputTypeSelect = {
    services?: boolean
  }

  export type ServiceListCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ServiceListCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ServiceListCountOutputType
    : S extends undefined
    ? never
    : S extends ServiceListCountOutputTypeArgs
    ?'include' extends U
    ? ServiceListCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ServiceListCountOutputType ? ServiceListCountOutputType[P] : never
  } 
    : ServiceListCountOutputType
  : ServiceListCountOutputType




  // Custom InputTypes

  /**
   * ServiceListCountOutputType without action
   */
  export type ServiceListCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ServiceListCountOutputType
     * 
    **/
    select?: ServiceListCountOutputTypeSelect | null
  }



  /**
   * Count Type ServiceCountOutputType
   */


  export type ServiceCountOutputType = {
    serviceLists: number
  }

  export type ServiceCountOutputTypeSelect = {
    serviceLists?: boolean
  }

  export type ServiceCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ServiceCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ServiceCountOutputType
    : S extends undefined
    ? never
    : S extends ServiceCountOutputTypeArgs
    ?'include' extends U
    ? ServiceCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ServiceCountOutputType ? ServiceCountOutputType[P] : never
  } 
    : ServiceCountOutputType
  : ServiceCountOutputType




  // Custom InputTypes

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     * 
    **/
    select?: ServiceCountOutputTypeSelect | null
  }



  /**
   * Count Type SubDomainCountOutputType
   */


  export type SubDomainCountOutputType = {
    organization: number
  }

  export type SubDomainCountOutputTypeSelect = {
    organization?: boolean
  }

  export type SubDomainCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SubDomainCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SubDomainCountOutputType
    : S extends undefined
    ? never
    : S extends SubDomainCountOutputTypeArgs
    ?'include' extends U
    ? SubDomainCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SubDomainCountOutputType ? SubDomainCountOutputType[P] : never
  } 
    : SubDomainCountOutputType
  : SubDomainCountOutputType




  // Custom InputTypes

  /**
   * SubDomainCountOutputType without action
   */
  export type SubDomainCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SubDomainCountOutputType
     * 
    **/
    select?: SubDomainCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    oauth_token_secret: string | null
    oauth_token: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    oauth_token_secret: string | null
    oauth_token: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    oauth_token_secret: number
    oauth_token: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    oauth_token_secret?: true
    oauth_token?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    oauth_token_secret?: true
    oauth_token?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    oauth_token_secret?: true
    oauth_token?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs = {
    /**
     * Filter which Account to aggregate.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: Array<AccountScalarFieldEnum>
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    oauth_token_secret: string | null
    oauth_token: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    oauth_token_secret?: boolean
    oauth_token?: boolean
    user?: boolean | UserArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountInclude = {
    user?: boolean | UserArgs
  }

  export type AccountGetPayload<
    S extends boolean | null | undefined | AccountArgs,
    U = keyof S
      > = S extends true
        ? Account
    : S extends undefined
    ? never
    : S extends AccountArgs | AccountFindManyArgs
    ?'include' extends U
    ? Account  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Account ? Account[P] : never
  } 
    : Account
  : Account


  type AccountCountArgs = Merge<
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }
  >

  export interface AccountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null, null>, Prisma__AccountClient<AccountGetPayload<T> | null, null>>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null, null>, Prisma__AccountClient<AccountGetPayload<T> | null, null>>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Account>>, PrismaPromise<Array<AccountGetPayload<T>>>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Find one Account that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Find the first Account that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Account base type for findUnique actions
   */
  export type AccountFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where: AccountWhereUniqueInput
  }

  /**
   * Account: findUnique
   */
  export interface AccountFindUniqueArgs extends AccountFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account base type for findFirst actions
   */
  export type AccountFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     * 
    **/
    distinct?: Enumerable<AccountScalarFieldEnum>
  }

  /**
   * Account: findFirst
   */
  export interface AccountFindFirstArgs extends AccountFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findMany
   */
  export type AccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Accounts to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to create a Account.
     * 
    **/
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs = {
    /**
     * The data used to create many Accounts.
     * 
    **/
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to update a Account.
     * 
    **/
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs = {
    /**
     * The data used to update Accounts.
     * 
    **/
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     * 
    **/
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The filter to search for the Account to update in case it exists.
     * 
    **/
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     * 
    **/
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter which Account to delete.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs = {
    /**
     * Filter which Accounts to delete
     * 
    **/
    where?: AccountWhereInput
  }


  /**
   * Account: findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs = AccountFindUniqueArgsBase
      

  /**
   * Account: findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs = AccountFindFirstArgsBase
      

  /**
   * Account without action
   */
  export type AccountArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
  }



  /**
   * Model Session
   */


  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs = {
    /**
     * Filter which Session to aggregate.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs = {
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByWithAggregationInput>
    by: Array<SessionScalarFieldEnum>
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }


  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionInclude = {
    user?: boolean | UserArgs
  }

  export type SessionGetPayload<
    S extends boolean | null | undefined | SessionArgs,
    U = keyof S
      > = S extends true
        ? Session
    : S extends undefined
    ? never
    : S extends SessionArgs | SessionFindManyArgs
    ?'include' extends U
    ? Session  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Session ? Session[P] : never
  } 
    : Session
  : Session


  type SessionCountArgs = Merge<
    Omit<SessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }
  >

  export interface SessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Session'> extends True ? CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>> : CheckSelect<T, Prisma__SessionClient<Session | null, null>, Prisma__SessionClient<SessionGetPayload<T> | null, null>>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Session'> extends True ? CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>> : CheckSelect<T, Prisma__SessionClient<Session | null, null>, Prisma__SessionClient<SessionGetPayload<T> | null, null>>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Session>>, PrismaPromise<Array<SessionGetPayload<T>>>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Find one Session that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SessionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Find the first Session that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SessionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Session base type for findUnique actions
   */
  export type SessionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where: SessionWhereUniqueInput
  }

  /**
   * Session: findUnique
   */
  export interface SessionFindUniqueArgs extends SessionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session base type for findFirst actions
   */
  export type SessionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     * 
    **/
    distinct?: Enumerable<SessionScalarFieldEnum>
  }

  /**
   * Session: findFirst
   */
  export interface SessionFindFirstArgs extends SessionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session findMany
   */
  export type SessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Sessions to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session create
   */
  export type SessionCreateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The data needed to create a Session.
     * 
    **/
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs = {
    /**
     * The data used to create many Sessions.
     * 
    **/
    data: Enumerable<SessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The data needed to update a Session.
     * 
    **/
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs = {
    /**
     * The data used to update Sessions.
     * 
    **/
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     * 
    **/
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The filter to search for the Session to update in case it exists.
     * 
    **/
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     * 
    **/
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter which Session to delete.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs = {
    /**
     * Filter which Sessions to delete
     * 
    **/
    where?: SessionWhereInput
  }


  /**
   * Session: findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs = SessionFindUniqueArgsBase
      

  /**
   * Session: findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs = SessionFindFirstArgsBase
      

  /**
   * Session without action
   */
  export type SessionArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    email: string | null
    emailVerified: boolean | null
    hashedPassword: string | null
    dialCode: string | null
    phone: string | null
    termsAccepted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    email: string | null
    emailVerified: boolean | null
    hashedPassword: string | null
    dialCode: string | null
    phone: string | null
    termsAccepted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    username: number
    email: number
    emailVerified: number
    hashedPassword: number
    dialCode: number
    phone: number
    termsAccepted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    email?: true
    emailVerified?: true
    hashedPassword?: true
    dialCode?: true
    phone?: true
    termsAccepted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    email?: true
    emailVerified?: true
    hashedPassword?: true
    dialCode?: true
    phone?: true
    termsAccepted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    email?: true
    emailVerified?: true
    hashedPassword?: true
    dialCode?: true
    phone?: true
    termsAccepted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    username: string | null
    email: string
    emailVerified: boolean
    hashedPassword: string | null
    dialCode: string | null
    phone: string | null
    termsAccepted: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    email?: boolean
    emailVerified?: boolean
    hashedPassword?: boolean
    dialCode?: boolean
    phone?: boolean
    address?: boolean | AddressFindManyArgs
    termsAccepted?: boolean
    imageUser?: boolean | ImageUserFindManyArgs
    accounts?: boolean | AccountFindManyArgs
    sessions?: boolean | SessionFindManyArgs
    reviews?: boolean | ReviewFindManyArgs
    memberships?: boolean | MembershipFindManyArgs
    orders?: boolean | OrderFindManyArgs
    driver?: boolean | DriverArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    address?: boolean | AddressFindManyArgs
    imageUser?: boolean | ImageUserFindManyArgs
    accounts?: boolean | AccountFindManyArgs
    sessions?: boolean | SessionFindManyArgs
    reviews?: boolean | ReviewFindManyArgs
    memberships?: boolean | MembershipFindManyArgs
    orders?: boolean | OrderFindManyArgs
    driver?: boolean | DriverArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'address' ? Array < AddressGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'imageUser' ? Array < ImageUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'accounts' ? Array < AccountGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'sessions' ? Array < SessionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'reviews' ? Array < ReviewGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'memberships' ? Array < MembershipGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'driver' ? DriverGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'address' ? Array < AddressGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'imageUser' ? Array < ImageUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'accounts' ? Array < AccountGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'sessions' ? Array < SessionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'reviews' ? Array < ReviewGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'memberships' ? Array < MembershipGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'driver' ? DriverGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null, null>, Prisma__UserClient<UserGetPayload<T> | null, null>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null, null>, Prisma__UserClient<UserGetPayload<T> | null, null>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    address<T extends AddressFindManyArgs = {}>(args?: Subset<T, AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Address>| Null>, PrismaPromise<Array<AddressGetPayload<T>>| Null>>;

    imageUser<T extends ImageUserFindManyArgs = {}>(args?: Subset<T, ImageUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ImageUser>| Null>, PrismaPromise<Array<ImageUserGetPayload<T>>| Null>>;

    accounts<T extends AccountFindManyArgs = {}>(args?: Subset<T, AccountFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Account>| Null>, PrismaPromise<Array<AccountGetPayload<T>>| Null>>;

    sessions<T extends SessionFindManyArgs = {}>(args?: Subset<T, SessionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Session>| Null>, PrismaPromise<Array<SessionGetPayload<T>>| Null>>;

    reviews<T extends ReviewFindManyArgs = {}>(args?: Subset<T, ReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Review>| Null>, PrismaPromise<Array<ReviewGetPayload<T>>| Null>>;

    memberships<T extends MembershipFindManyArgs = {}>(args?: Subset<T, MembershipFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Membership>| Null>, PrismaPromise<Array<MembershipGetPayload<T>>| Null>>;

    orders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>| Null>, PrismaPromise<Array<OrderGetPayload<T>>| Null>>;

    driver<T extends DriverArgs = {}>(args?: Subset<T, DriverArgs>): CheckSelect<T, Prisma__DriverClient<Driver | Null>, Prisma__DriverClient<DriverGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User: findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = UserFindUniqueArgsBase
      

  /**
   * User: findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = UserFindFirstArgsBase
      

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Driver
   */


  export type AggregateDriver = {
    _count: DriverCountAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  export type DriverMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriverMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriverCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DriverMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriverMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriverCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DriverAggregateArgs = {
    /**
     * Filter which Driver to aggregate.
     * 
    **/
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     * 
    **/
    orderBy?: Enumerable<DriverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drivers
    **/
    _count?: true | DriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverMaxAggregateInputType
  }

  export type GetDriverAggregateType<T extends DriverAggregateArgs> = {
        [P in keyof T & keyof AggregateDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriver[P]>
      : GetScalarType<T[P], AggregateDriver[P]>
  }




  export type DriverGroupByArgs = {
    where?: DriverWhereInput
    orderBy?: Enumerable<DriverOrderByWithAggregationInput>
    by: Array<DriverScalarFieldEnum>
    having?: DriverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverCountAggregateInputType | true
    _min?: DriverMinAggregateInputType
    _max?: DriverMaxAggregateInputType
  }


  export type DriverGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    _count: DriverCountAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  type GetDriverGroupByPayload<T extends DriverGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverGroupByOutputType[P]>
            : GetScalarType<T[P], DriverGroupByOutputType[P]>
        }
      >
    >


  export type DriverSelect = {
    id?: boolean
    user?: boolean | UserArgs
    orders?: boolean | OrderFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | DriverCountOutputTypeArgs
  }

  export type DriverInclude = {
    user?: boolean | UserArgs
    orders?: boolean | OrderFindManyArgs
    _count?: boolean | DriverCountOutputTypeArgs
  }

  export type DriverGetPayload<
    S extends boolean | null | undefined | DriverArgs,
    U = keyof S
      > = S extends true
        ? Driver
    : S extends undefined
    ? never
    : S extends DriverArgs | DriverFindManyArgs
    ?'include' extends U
    ? Driver  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? DriverCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? DriverCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Driver ? Driver[P] : never
  } 
    : Driver
  : Driver


  type DriverCountArgs = Merge<
    Omit<DriverFindManyArgs, 'select' | 'include'> & {
      select?: DriverCountAggregateInputType | true
    }
  >

  export interface DriverDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Driver that matches the filter.
     * @param {DriverFindUniqueArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DriverFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DriverFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Driver'> extends True ? CheckSelect<T, Prisma__DriverClient<Driver>, Prisma__DriverClient<DriverGetPayload<T>>> : CheckSelect<T, Prisma__DriverClient<Driver | null, null>, Prisma__DriverClient<DriverGetPayload<T> | null, null>>

    /**
     * Find the first Driver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DriverFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DriverFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Driver'> extends True ? CheckSelect<T, Prisma__DriverClient<Driver>, Prisma__DriverClient<DriverGetPayload<T>>> : CheckSelect<T, Prisma__DriverClient<Driver | null, null>, Prisma__DriverClient<DriverGetPayload<T> | null, null>>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.driver.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.driver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverWithIdOnly = await prisma.driver.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DriverFindManyArgs>(
      args?: SelectSubset<T, DriverFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Driver>>, PrismaPromise<Array<DriverGetPayload<T>>>>

    /**
     * Create a Driver.
     * @param {DriverCreateArgs} args - Arguments to create a Driver.
     * @example
     * // Create one Driver
     * const Driver = await prisma.driver.create({
     *   data: {
     *     // ... data to create a Driver
     *   }
     * })
     * 
    **/
    create<T extends DriverCreateArgs>(
      args: SelectSubset<T, DriverCreateArgs>
    ): CheckSelect<T, Prisma__DriverClient<Driver>, Prisma__DriverClient<DriverGetPayload<T>>>

    /**
     * Create many Drivers.
     *     @param {DriverCreateManyArgs} args - Arguments to create many Drivers.
     *     @example
     *     // Create many Drivers
     *     const driver = await prisma.driver.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DriverCreateManyArgs>(
      args?: SelectSubset<T, DriverCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Driver.
     * @param {DriverDeleteArgs} args - Arguments to delete one Driver.
     * @example
     * // Delete one Driver
     * const Driver = await prisma.driver.delete({
     *   where: {
     *     // ... filter to delete one Driver
     *   }
     * })
     * 
    **/
    delete<T extends DriverDeleteArgs>(
      args: SelectSubset<T, DriverDeleteArgs>
    ): CheckSelect<T, Prisma__DriverClient<Driver>, Prisma__DriverClient<DriverGetPayload<T>>>

    /**
     * Update one Driver.
     * @param {DriverUpdateArgs} args - Arguments to update one Driver.
     * @example
     * // Update one Driver
     * const driver = await prisma.driver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DriverUpdateArgs>(
      args: SelectSubset<T, DriverUpdateArgs>
    ): CheckSelect<T, Prisma__DriverClient<Driver>, Prisma__DriverClient<DriverGetPayload<T>>>

    /**
     * Delete zero or more Drivers.
     * @param {DriverDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.driver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DriverDeleteManyArgs>(
      args?: SelectSubset<T, DriverDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DriverUpdateManyArgs>(
      args: SelectSubset<T, DriverUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Driver.
     * @param {DriverUpsertArgs} args - Arguments to update or create a Driver.
     * @example
     * // Update or create a Driver
     * const driver = await prisma.driver.upsert({
     *   create: {
     *     // ... data to create a Driver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driver we want to update
     *   }
     * })
    **/
    upsert<T extends DriverUpsertArgs>(
      args: SelectSubset<T, DriverUpsertArgs>
    ): CheckSelect<T, Prisma__DriverClient<Driver>, Prisma__DriverClient<DriverGetPayload<T>>>

    /**
     * Find one Driver that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DriverFindUniqueOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DriverFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DriverFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DriverClient<Driver>, Prisma__DriverClient<DriverGetPayload<T>>>

    /**
     * Find the first Driver that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DriverFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DriverFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DriverClient<Driver>, Prisma__DriverClient<DriverGetPayload<T>>>

    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.driver.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends DriverCountArgs>(
      args?: Subset<T, DriverCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverAggregateArgs>(args: Subset<T, DriverAggregateArgs>): PrismaPromise<GetDriverAggregateType<T>>

    /**
     * Group by Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverGroupByArgs['orderBy'] }
        : { orderBy?: DriverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Driver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DriverClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    orders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>| Null>, PrismaPromise<Array<OrderGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Driver base type for findUnique actions
   */
  export type DriverFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Driver
     * 
    **/
    select?: DriverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriverInclude | null
    /**
     * Filter, which Driver to fetch.
     * 
    **/
    where: DriverWhereUniqueInput
  }

  /**
   * Driver: findUnique
   */
  export interface DriverFindUniqueArgs extends DriverFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Driver base type for findFirst actions
   */
  export type DriverFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Driver
     * 
    **/
    select?: DriverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriverInclude | null
    /**
     * Filter, which Driver to fetch.
     * 
    **/
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     * 
    **/
    orderBy?: Enumerable<DriverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     * 
    **/
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     * 
    **/
    distinct?: Enumerable<DriverScalarFieldEnum>
  }

  /**
   * Driver: findFirst
   */
  export interface DriverFindFirstArgs extends DriverFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Driver findMany
   */
  export type DriverFindManyArgs = {
    /**
     * Select specific fields to fetch from the Driver
     * 
    **/
    select?: DriverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriverInclude | null
    /**
     * Filter, which Drivers to fetch.
     * 
    **/
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     * 
    **/
    orderBy?: Enumerable<DriverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drivers.
     * 
    **/
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DriverScalarFieldEnum>
  }


  /**
   * Driver create
   */
  export type DriverCreateArgs = {
    /**
     * Select specific fields to fetch from the Driver
     * 
    **/
    select?: DriverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriverInclude | null
    /**
     * The data needed to create a Driver.
     * 
    **/
    data: XOR<DriverCreateInput, DriverUncheckedCreateInput>
  }


  /**
   * Driver createMany
   */
  export type DriverCreateManyArgs = {
    /**
     * The data used to create many Drivers.
     * 
    **/
    data: Enumerable<DriverCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Driver update
   */
  export type DriverUpdateArgs = {
    /**
     * Select specific fields to fetch from the Driver
     * 
    **/
    select?: DriverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriverInclude | null
    /**
     * The data needed to update a Driver.
     * 
    **/
    data: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
    /**
     * Choose, which Driver to update.
     * 
    **/
    where: DriverWhereUniqueInput
  }


  /**
   * Driver updateMany
   */
  export type DriverUpdateManyArgs = {
    /**
     * The data used to update Drivers.
     * 
    **/
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     * 
    **/
    where?: DriverWhereInput
  }


  /**
   * Driver upsert
   */
  export type DriverUpsertArgs = {
    /**
     * Select specific fields to fetch from the Driver
     * 
    **/
    select?: DriverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriverInclude | null
    /**
     * The filter to search for the Driver to update in case it exists.
     * 
    **/
    where: DriverWhereUniqueInput
    /**
     * In case the Driver found by the `where` argument doesn't exist, create a new Driver with this data.
     * 
    **/
    create: XOR<DriverCreateInput, DriverUncheckedCreateInput>
    /**
     * In case the Driver was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
  }


  /**
   * Driver delete
   */
  export type DriverDeleteArgs = {
    /**
     * Select specific fields to fetch from the Driver
     * 
    **/
    select?: DriverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriverInclude | null
    /**
     * Filter which Driver to delete.
     * 
    **/
    where: DriverWhereUniqueInput
  }


  /**
   * Driver deleteMany
   */
  export type DriverDeleteManyArgs = {
    /**
     * Filter which Drivers to delete
     * 
    **/
    where?: DriverWhereInput
  }


  /**
   * Driver: findUniqueOrThrow
   */
  export type DriverFindUniqueOrThrowArgs = DriverFindUniqueArgsBase
      

  /**
   * Driver: findFirstOrThrow
   */
  export type DriverFindFirstOrThrowArgs = DriverFindFirstArgsBase
      

  /**
   * Driver without action
   */
  export type DriverArgs = {
    /**
     * Select specific fields to fetch from the Driver
     * 
    **/
    select?: DriverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriverInclude | null
  }



  /**
   * Model Vendor
   */


  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorMinAggregateOutputType = {
    id: string | null
    name: string | null
    publicName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    publicName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    name: number
    publicName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorMinAggregateInputType = {
    id?: true
    name?: true
    publicName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    name?: true
    publicName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    name?: true
    publicName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorAggregateArgs = {
    /**
     * Filter which Vendor to aggregate.
     * 
    **/
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     * 
    **/
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs = {
    where?: VendorWhereInput
    orderBy?: Enumerable<VendorOrderByWithAggregationInput>
    by: Array<VendorScalarFieldEnum>
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }


  export type VendorGroupByOutputType = {
    id: string
    name: string
    publicName: string
    createdAt: Date
    updatedAt: Date
    _count: VendorCountAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect = {
    id?: boolean
    name?: boolean
    publicName?: boolean
    organizations?: boolean | OrganizationFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | VendorCountOutputTypeArgs
  }

  export type VendorInclude = {
    organizations?: boolean | OrganizationFindManyArgs
    _count?: boolean | VendorCountOutputTypeArgs
  }

  export type VendorGetPayload<
    S extends boolean | null | undefined | VendorArgs,
    U = keyof S
      > = S extends true
        ? Vendor
    : S extends undefined
    ? never
    : S extends VendorArgs | VendorFindManyArgs
    ?'include' extends U
    ? Vendor  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organizations' ? Array < OrganizationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? VendorCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organizations' ? Array < OrganizationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? VendorCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Vendor ? Vendor[P] : never
  } 
    : Vendor
  : Vendor


  type VendorCountArgs = Merge<
    Omit<VendorFindManyArgs, 'select' | 'include'> & {
      select?: VendorCountAggregateInputType | true
    }
  >

  export interface VendorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VendorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VendorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Vendor'> extends True ? CheckSelect<T, Prisma__VendorClient<Vendor>, Prisma__VendorClient<VendorGetPayload<T>>> : CheckSelect<T, Prisma__VendorClient<Vendor | null, null>, Prisma__VendorClient<VendorGetPayload<T> | null, null>>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VendorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VendorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Vendor'> extends True ? CheckSelect<T, Prisma__VendorClient<Vendor>, Prisma__VendorClient<VendorGetPayload<T>>> : CheckSelect<T, Prisma__VendorClient<Vendor | null, null>, Prisma__VendorClient<VendorGetPayload<T> | null, null>>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VendorFindManyArgs>(
      args?: SelectSubset<T, VendorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Vendor>>, PrismaPromise<Array<VendorGetPayload<T>>>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
    **/
    create<T extends VendorCreateArgs>(
      args: SelectSubset<T, VendorCreateArgs>
    ): CheckSelect<T, Prisma__VendorClient<Vendor>, Prisma__VendorClient<VendorGetPayload<T>>>

    /**
     * Create many Vendors.
     *     @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     *     @example
     *     // Create many Vendors
     *     const vendor = await prisma.vendor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VendorCreateManyArgs>(
      args?: SelectSubset<T, VendorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
    **/
    delete<T extends VendorDeleteArgs>(
      args: SelectSubset<T, VendorDeleteArgs>
    ): CheckSelect<T, Prisma__VendorClient<Vendor>, Prisma__VendorClient<VendorGetPayload<T>>>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VendorUpdateArgs>(
      args: SelectSubset<T, VendorUpdateArgs>
    ): CheckSelect<T, Prisma__VendorClient<Vendor>, Prisma__VendorClient<VendorGetPayload<T>>>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VendorDeleteManyArgs>(
      args?: SelectSubset<T, VendorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VendorUpdateManyArgs>(
      args: SelectSubset<T, VendorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
    **/
    upsert<T extends VendorUpsertArgs>(
      args: SelectSubset<T, VendorUpsertArgs>
    ): CheckSelect<T, Prisma__VendorClient<Vendor>, Prisma__VendorClient<VendorGetPayload<T>>>

    /**
     * Find one Vendor that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VendorFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__VendorClient<Vendor>, Prisma__VendorClient<VendorGetPayload<T>>>

    /**
     * Find the first Vendor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VendorFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__VendorClient<Vendor>, Prisma__VendorClient<VendorGetPayload<T>>>

    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VendorClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organizations<T extends OrganizationFindManyArgs = {}>(args?: Subset<T, OrganizationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Organization>| Null>, PrismaPromise<Array<OrganizationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Vendor base type for findUnique actions
   */
  export type VendorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
    /**
     * Filter, which Vendor to fetch.
     * 
    **/
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor: findUnique
   */
  export interface VendorFindUniqueArgs extends VendorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Vendor base type for findFirst actions
   */
  export type VendorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
    /**
     * Filter, which Vendor to fetch.
     * 
    **/
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     * 
    **/
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     * 
    **/
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     * 
    **/
    distinct?: Enumerable<VendorScalarFieldEnum>
  }

  /**
   * Vendor: findFirst
   */
  export interface VendorFindFirstArgs extends VendorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
    /**
     * Filter, which Vendors to fetch.
     * 
    **/
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     * 
    **/
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     * 
    **/
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VendorScalarFieldEnum>
  }


  /**
   * Vendor create
   */
  export type VendorCreateArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
    /**
     * The data needed to create a Vendor.
     * 
    **/
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }


  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs = {
    /**
     * The data used to create many Vendors.
     * 
    **/
    data: Enumerable<VendorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Vendor update
   */
  export type VendorUpdateArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
    /**
     * The data needed to update a Vendor.
     * 
    **/
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     * 
    **/
    where: VendorWhereUniqueInput
  }


  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs = {
    /**
     * The data used to update Vendors.
     * 
    **/
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     * 
    **/
    where?: VendorWhereInput
  }


  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     * 
    **/
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     * 
    **/
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }


  /**
   * Vendor delete
   */
  export type VendorDeleteArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
    /**
     * Filter which Vendor to delete.
     * 
    **/
    where: VendorWhereUniqueInput
  }


  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs = {
    /**
     * Filter which Vendors to delete
     * 
    **/
    where?: VendorWhereInput
  }


  /**
   * Vendor: findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs = VendorFindUniqueArgsBase
      

  /**
   * Vendor: findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs = VendorFindFirstArgsBase
      

  /**
   * Vendor without action
   */
  export type VendorArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
  }



  /**
   * Model Address
   */


  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    street1: string | null
    street2: string | null
    city: string | null
    state: string | null
    zipcode: string | null
    country: string | null
    countryCode: string | null
    coordinateId: string | null
    userId: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    street1: string | null
    street2: string | null
    city: string | null
    state: string | null
    zipcode: string | null
    country: string | null
    countryCode: string | null
    coordinateId: string | null
    userId: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    street1: number
    street2: number
    city: number
    state: number
    zipcode: number
    country: number
    countryCode: number
    coordinateId: number
    userId: number
    organizationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    zipcode?: true
    country?: true
    countryCode?: true
    coordinateId?: true
    userId?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    zipcode?: true
    country?: true
    countryCode?: true
    coordinateId?: true
    userId?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    zipcode?: true
    country?: true
    countryCode?: true
    coordinateId?: true
    userId?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs = {
    /**
     * Filter which Address to aggregate.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs = {
    where?: AddressWhereInput
    orderBy?: Enumerable<AddressOrderByWithAggregationInput>
    by: Array<AddressScalarFieldEnum>
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }


  export type AddressGroupByOutputType = {
    id: string
    street1: string
    street2: string | null
    city: string
    state: string
    zipcode: string
    country: string
    countryCode: string | null
    coordinateId: string | null
    userId: string | null
    organizationId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect = {
    id?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    zipcode?: boolean
    country?: boolean
    countryCode?: boolean
    coordinateId?: boolean
    coordinates?: boolean | CoordinatesArgs
    userId?: boolean
    user?: boolean | UserArgs
    organizationId?: boolean
    organization?: boolean | OrganizationArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressInclude = {
    coordinates?: boolean | CoordinatesArgs
    user?: boolean | UserArgs
    organization?: boolean | OrganizationArgs
  }

  export type AddressGetPayload<
    S extends boolean | null | undefined | AddressArgs,
    U = keyof S
      > = S extends true
        ? Address
    : S extends undefined
    ? never
    : S extends AddressArgs | AddressFindManyArgs
    ?'include' extends U
    ? Address  & {
    [P in TrueKeys<S['include']>]:
        P extends 'coordinates' ? CoordinatesGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'organization' ? OrganizationGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'coordinates' ? CoordinatesGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'organization' ? OrganizationGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof Address ? Address[P] : never
  } 
    : Address
  : Address


  type AddressCountArgs = Merge<
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }
  >

  export interface AddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null, null>, Prisma__AddressClient<AddressGetPayload<T> | null, null>>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null, null>, Prisma__AddressClient<AddressGetPayload<T> | null, null>>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Find one Address that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AddressFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Find the first Address that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AddressFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    coordinates<T extends CoordinatesArgs = {}>(args?: Subset<T, CoordinatesArgs>): CheckSelect<T, Prisma__CoordinatesClient<Coordinates | Null>, Prisma__CoordinatesClient<CoordinatesGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    organization<T extends OrganizationArgs = {}>(args?: Subset<T, OrganizationArgs>): CheckSelect<T, Prisma__OrganizationClient<Organization | Null>, Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Address base type for findUnique actions
   */
  export type AddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where: AddressWhereUniqueInput
  }

  /**
   * Address: findUnique
   */
  export interface AddressFindUniqueArgs extends AddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Address base type for findFirst actions
   */
  export type AddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     * 
    **/
    distinct?: Enumerable<AddressScalarFieldEnum>
  }

  /**
   * Address: findFirst
   */
  export interface AddressFindFirstArgs extends AddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Address findMany
   */
  export type AddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Addresses to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address create
   */
  export type AddressCreateArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The data needed to create a Address.
     * 
    **/
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address createMany
   */
  export type AddressCreateManyArgs = {
    /**
     * The data used to create many Addresses.
     * 
    **/
    data: Enumerable<AddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The data needed to update a Address.
     * 
    **/
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs = {
    /**
     * The data used to update Addresses.
     * 
    **/
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     * 
    **/
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The filter to search for the Address to update in case it exists.
     * 
    **/
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     * 
    **/
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter which Address to delete.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs = {
    /**
     * Filter which Addresses to delete
     * 
    **/
    where?: AddressWhereInput
  }


  /**
   * Address: findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs = AddressFindUniqueArgsBase
      

  /**
   * Address: findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs = AddressFindFirstArgsBase
      

  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
  }



  /**
   * Model ImageOrganization
   */


  export type AggregateImageOrganization = {
    _count: ImageOrganizationCountAggregateOutputType | null
    _min: ImageOrganizationMinAggregateOutputType | null
    _max: ImageOrganizationMaxAggregateOutputType | null
  }

  export type ImageOrganizationMinAggregateOutputType = {
    id: string | null
    location: string | null
    organizationId: string | null
    blurhash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageOrganizationMaxAggregateOutputType = {
    id: string | null
    location: string | null
    organizationId: string | null
    blurhash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageOrganizationCountAggregateOutputType = {
    id: number
    location: number
    organizationId: number
    blurhash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImageOrganizationMinAggregateInputType = {
    id?: true
    location?: true
    organizationId?: true
    blurhash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageOrganizationMaxAggregateInputType = {
    id?: true
    location?: true
    organizationId?: true
    blurhash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageOrganizationCountAggregateInputType = {
    id?: true
    location?: true
    organizationId?: true
    blurhash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImageOrganizationAggregateArgs = {
    /**
     * Filter which ImageOrganization to aggregate.
     * 
    **/
    where?: ImageOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageOrganizations to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageOrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ImageOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageOrganizations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageOrganizations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImageOrganizations
    **/
    _count?: true | ImageOrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageOrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageOrganizationMaxAggregateInputType
  }

  export type GetImageOrganizationAggregateType<T extends ImageOrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateImageOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImageOrganization[P]>
      : GetScalarType<T[P], AggregateImageOrganization[P]>
  }




  export type ImageOrganizationGroupByArgs = {
    where?: ImageOrganizationWhereInput
    orderBy?: Enumerable<ImageOrganizationOrderByWithAggregationInput>
    by: Array<ImageOrganizationScalarFieldEnum>
    having?: ImageOrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageOrganizationCountAggregateInputType | true
    _min?: ImageOrganizationMinAggregateInputType
    _max?: ImageOrganizationMaxAggregateInputType
  }


  export type ImageOrganizationGroupByOutputType = {
    id: string
    location: string
    organizationId: string
    blurhash: string | null
    createdAt: Date
    updatedAt: Date
    _count: ImageOrganizationCountAggregateOutputType | null
    _min: ImageOrganizationMinAggregateOutputType | null
    _max: ImageOrganizationMaxAggregateOutputType | null
  }

  type GetImageOrganizationGroupByPayload<T extends ImageOrganizationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ImageOrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageOrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageOrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], ImageOrganizationGroupByOutputType[P]>
        }
      >
    >


  export type ImageOrganizationSelect = {
    id?: boolean
    location?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationArgs
    blurhash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImageOrganizationInclude = {
    organization?: boolean | OrganizationArgs
  }

  export type ImageOrganizationGetPayload<
    S extends boolean | null | undefined | ImageOrganizationArgs,
    U = keyof S
      > = S extends true
        ? ImageOrganization
    : S extends undefined
    ? never
    : S extends ImageOrganizationArgs | ImageOrganizationFindManyArgs
    ?'include' extends U
    ? ImageOrganization  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organization' ? OrganizationGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organization' ? OrganizationGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof ImageOrganization ? ImageOrganization[P] : never
  } 
    : ImageOrganization
  : ImageOrganization


  type ImageOrganizationCountArgs = Merge<
    Omit<ImageOrganizationFindManyArgs, 'select' | 'include'> & {
      select?: ImageOrganizationCountAggregateInputType | true
    }
  >

  export interface ImageOrganizationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ImageOrganization that matches the filter.
     * @param {ImageOrganizationFindUniqueArgs} args - Arguments to find a ImageOrganization
     * @example
     * // Get one ImageOrganization
     * const imageOrganization = await prisma.imageOrganization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ImageOrganizationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ImageOrganizationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ImageOrganization'> extends True ? CheckSelect<T, Prisma__ImageOrganizationClient<ImageOrganization>, Prisma__ImageOrganizationClient<ImageOrganizationGetPayload<T>>> : CheckSelect<T, Prisma__ImageOrganizationClient<ImageOrganization | null, null>, Prisma__ImageOrganizationClient<ImageOrganizationGetPayload<T> | null, null>>

    /**
     * Find the first ImageOrganization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageOrganizationFindFirstArgs} args - Arguments to find a ImageOrganization
     * @example
     * // Get one ImageOrganization
     * const imageOrganization = await prisma.imageOrganization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ImageOrganizationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ImageOrganizationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ImageOrganization'> extends True ? CheckSelect<T, Prisma__ImageOrganizationClient<ImageOrganization>, Prisma__ImageOrganizationClient<ImageOrganizationGetPayload<T>>> : CheckSelect<T, Prisma__ImageOrganizationClient<ImageOrganization | null, null>, Prisma__ImageOrganizationClient<ImageOrganizationGetPayload<T> | null, null>>

    /**
     * Find zero or more ImageOrganizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageOrganizationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImageOrganizations
     * const imageOrganizations = await prisma.imageOrganization.findMany()
     * 
     * // Get first 10 ImageOrganizations
     * const imageOrganizations = await prisma.imageOrganization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageOrganizationWithIdOnly = await prisma.imageOrganization.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ImageOrganizationFindManyArgs>(
      args?: SelectSubset<T, ImageOrganizationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ImageOrganization>>, PrismaPromise<Array<ImageOrganizationGetPayload<T>>>>

    /**
     * Create a ImageOrganization.
     * @param {ImageOrganizationCreateArgs} args - Arguments to create a ImageOrganization.
     * @example
     * // Create one ImageOrganization
     * const ImageOrganization = await prisma.imageOrganization.create({
     *   data: {
     *     // ... data to create a ImageOrganization
     *   }
     * })
     * 
    **/
    create<T extends ImageOrganizationCreateArgs>(
      args: SelectSubset<T, ImageOrganizationCreateArgs>
    ): CheckSelect<T, Prisma__ImageOrganizationClient<ImageOrganization>, Prisma__ImageOrganizationClient<ImageOrganizationGetPayload<T>>>

    /**
     * Create many ImageOrganizations.
     *     @param {ImageOrganizationCreateManyArgs} args - Arguments to create many ImageOrganizations.
     *     @example
     *     // Create many ImageOrganizations
     *     const imageOrganization = await prisma.imageOrganization.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ImageOrganizationCreateManyArgs>(
      args?: SelectSubset<T, ImageOrganizationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ImageOrganization.
     * @param {ImageOrganizationDeleteArgs} args - Arguments to delete one ImageOrganization.
     * @example
     * // Delete one ImageOrganization
     * const ImageOrganization = await prisma.imageOrganization.delete({
     *   where: {
     *     // ... filter to delete one ImageOrganization
     *   }
     * })
     * 
    **/
    delete<T extends ImageOrganizationDeleteArgs>(
      args: SelectSubset<T, ImageOrganizationDeleteArgs>
    ): CheckSelect<T, Prisma__ImageOrganizationClient<ImageOrganization>, Prisma__ImageOrganizationClient<ImageOrganizationGetPayload<T>>>

    /**
     * Update one ImageOrganization.
     * @param {ImageOrganizationUpdateArgs} args - Arguments to update one ImageOrganization.
     * @example
     * // Update one ImageOrganization
     * const imageOrganization = await prisma.imageOrganization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ImageOrganizationUpdateArgs>(
      args: SelectSubset<T, ImageOrganizationUpdateArgs>
    ): CheckSelect<T, Prisma__ImageOrganizationClient<ImageOrganization>, Prisma__ImageOrganizationClient<ImageOrganizationGetPayload<T>>>

    /**
     * Delete zero or more ImageOrganizations.
     * @param {ImageOrganizationDeleteManyArgs} args - Arguments to filter ImageOrganizations to delete.
     * @example
     * // Delete a few ImageOrganizations
     * const { count } = await prisma.imageOrganization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ImageOrganizationDeleteManyArgs>(
      args?: SelectSubset<T, ImageOrganizationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImageOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageOrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImageOrganizations
     * const imageOrganization = await prisma.imageOrganization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ImageOrganizationUpdateManyArgs>(
      args: SelectSubset<T, ImageOrganizationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ImageOrganization.
     * @param {ImageOrganizationUpsertArgs} args - Arguments to update or create a ImageOrganization.
     * @example
     * // Update or create a ImageOrganization
     * const imageOrganization = await prisma.imageOrganization.upsert({
     *   create: {
     *     // ... data to create a ImageOrganization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImageOrganization we want to update
     *   }
     * })
    **/
    upsert<T extends ImageOrganizationUpsertArgs>(
      args: SelectSubset<T, ImageOrganizationUpsertArgs>
    ): CheckSelect<T, Prisma__ImageOrganizationClient<ImageOrganization>, Prisma__ImageOrganizationClient<ImageOrganizationGetPayload<T>>>

    /**
     * Find one ImageOrganization that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ImageOrganizationFindUniqueOrThrowArgs} args - Arguments to find a ImageOrganization
     * @example
     * // Get one ImageOrganization
     * const imageOrganization = await prisma.imageOrganization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ImageOrganizationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ImageOrganizationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ImageOrganizationClient<ImageOrganization>, Prisma__ImageOrganizationClient<ImageOrganizationGetPayload<T>>>

    /**
     * Find the first ImageOrganization that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageOrganizationFindFirstOrThrowArgs} args - Arguments to find a ImageOrganization
     * @example
     * // Get one ImageOrganization
     * const imageOrganization = await prisma.imageOrganization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ImageOrganizationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ImageOrganizationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ImageOrganizationClient<ImageOrganization>, Prisma__ImageOrganizationClient<ImageOrganizationGetPayload<T>>>

    /**
     * Count the number of ImageOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageOrganizationCountArgs} args - Arguments to filter ImageOrganizations to count.
     * @example
     * // Count the number of ImageOrganizations
     * const count = await prisma.imageOrganization.count({
     *   where: {
     *     // ... the filter for the ImageOrganizations we want to count
     *   }
     * })
    **/
    count<T extends ImageOrganizationCountArgs>(
      args?: Subset<T, ImageOrganizationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageOrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImageOrganization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageOrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageOrganizationAggregateArgs>(args: Subset<T, ImageOrganizationAggregateArgs>): PrismaPromise<GetImageOrganizationAggregateType<T>>

    /**
     * Group by ImageOrganization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageOrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageOrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageOrganizationGroupByArgs['orderBy'] }
        : { orderBy?: ImageOrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageOrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageOrganizationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ImageOrganization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ImageOrganizationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organization<T extends OrganizationArgs = {}>(args?: Subset<T, OrganizationArgs>): CheckSelect<T, Prisma__OrganizationClient<Organization | Null>, Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ImageOrganization base type for findUnique actions
   */
  export type ImageOrganizationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ImageOrganization
     * 
    **/
    select?: ImageOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageOrganizationInclude | null
    /**
     * Filter, which ImageOrganization to fetch.
     * 
    **/
    where: ImageOrganizationWhereUniqueInput
  }

  /**
   * ImageOrganization: findUnique
   */
  export interface ImageOrganizationFindUniqueArgs extends ImageOrganizationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ImageOrganization base type for findFirst actions
   */
  export type ImageOrganizationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ImageOrganization
     * 
    **/
    select?: ImageOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageOrganizationInclude | null
    /**
     * Filter, which ImageOrganization to fetch.
     * 
    **/
    where?: ImageOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageOrganizations to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageOrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageOrganizations.
     * 
    **/
    cursor?: ImageOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageOrganizations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageOrganizations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageOrganizations.
     * 
    **/
    distinct?: Enumerable<ImageOrganizationScalarFieldEnum>
  }

  /**
   * ImageOrganization: findFirst
   */
  export interface ImageOrganizationFindFirstArgs extends ImageOrganizationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ImageOrganization findMany
   */
  export type ImageOrganizationFindManyArgs = {
    /**
     * Select specific fields to fetch from the ImageOrganization
     * 
    **/
    select?: ImageOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageOrganizationInclude | null
    /**
     * Filter, which ImageOrganizations to fetch.
     * 
    **/
    where?: ImageOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageOrganizations to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageOrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImageOrganizations.
     * 
    **/
    cursor?: ImageOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageOrganizations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageOrganizations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ImageOrganizationScalarFieldEnum>
  }


  /**
   * ImageOrganization create
   */
  export type ImageOrganizationCreateArgs = {
    /**
     * Select specific fields to fetch from the ImageOrganization
     * 
    **/
    select?: ImageOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageOrganizationInclude | null
    /**
     * The data needed to create a ImageOrganization.
     * 
    **/
    data: XOR<ImageOrganizationCreateInput, ImageOrganizationUncheckedCreateInput>
  }


  /**
   * ImageOrganization createMany
   */
  export type ImageOrganizationCreateManyArgs = {
    /**
     * The data used to create many ImageOrganizations.
     * 
    **/
    data: Enumerable<ImageOrganizationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ImageOrganization update
   */
  export type ImageOrganizationUpdateArgs = {
    /**
     * Select specific fields to fetch from the ImageOrganization
     * 
    **/
    select?: ImageOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageOrganizationInclude | null
    /**
     * The data needed to update a ImageOrganization.
     * 
    **/
    data: XOR<ImageOrganizationUpdateInput, ImageOrganizationUncheckedUpdateInput>
    /**
     * Choose, which ImageOrganization to update.
     * 
    **/
    where: ImageOrganizationWhereUniqueInput
  }


  /**
   * ImageOrganization updateMany
   */
  export type ImageOrganizationUpdateManyArgs = {
    /**
     * The data used to update ImageOrganizations.
     * 
    **/
    data: XOR<ImageOrganizationUpdateManyMutationInput, ImageOrganizationUncheckedUpdateManyInput>
    /**
     * Filter which ImageOrganizations to update
     * 
    **/
    where?: ImageOrganizationWhereInput
  }


  /**
   * ImageOrganization upsert
   */
  export type ImageOrganizationUpsertArgs = {
    /**
     * Select specific fields to fetch from the ImageOrganization
     * 
    **/
    select?: ImageOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageOrganizationInclude | null
    /**
     * The filter to search for the ImageOrganization to update in case it exists.
     * 
    **/
    where: ImageOrganizationWhereUniqueInput
    /**
     * In case the ImageOrganization found by the `where` argument doesn't exist, create a new ImageOrganization with this data.
     * 
    **/
    create: XOR<ImageOrganizationCreateInput, ImageOrganizationUncheckedCreateInput>
    /**
     * In case the ImageOrganization was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ImageOrganizationUpdateInput, ImageOrganizationUncheckedUpdateInput>
  }


  /**
   * ImageOrganization delete
   */
  export type ImageOrganizationDeleteArgs = {
    /**
     * Select specific fields to fetch from the ImageOrganization
     * 
    **/
    select?: ImageOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageOrganizationInclude | null
    /**
     * Filter which ImageOrganization to delete.
     * 
    **/
    where: ImageOrganizationWhereUniqueInput
  }


  /**
   * ImageOrganization deleteMany
   */
  export type ImageOrganizationDeleteManyArgs = {
    /**
     * Filter which ImageOrganizations to delete
     * 
    **/
    where?: ImageOrganizationWhereInput
  }


  /**
   * ImageOrganization: findUniqueOrThrow
   */
  export type ImageOrganizationFindUniqueOrThrowArgs = ImageOrganizationFindUniqueArgsBase
      

  /**
   * ImageOrganization: findFirstOrThrow
   */
  export type ImageOrganizationFindFirstOrThrowArgs = ImageOrganizationFindFirstArgsBase
      

  /**
   * ImageOrganization without action
   */
  export type ImageOrganizationArgs = {
    /**
     * Select specific fields to fetch from the ImageOrganization
     * 
    **/
    select?: ImageOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageOrganizationInclude | null
  }



  /**
   * Model ImageProduct
   */


  export type AggregateImageProduct = {
    _count: ImageProductCountAggregateOutputType | null
    _min: ImageProductMinAggregateOutputType | null
    _max: ImageProductMaxAggregateOutputType | null
  }

  export type ImageProductMinAggregateOutputType = {
    id: string | null
    location: string | null
    productId: string | null
    blurhash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageProductMaxAggregateOutputType = {
    id: string | null
    location: string | null
    productId: string | null
    blurhash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageProductCountAggregateOutputType = {
    id: number
    location: number
    productId: number
    blurhash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImageProductMinAggregateInputType = {
    id?: true
    location?: true
    productId?: true
    blurhash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageProductMaxAggregateInputType = {
    id?: true
    location?: true
    productId?: true
    blurhash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageProductCountAggregateInputType = {
    id?: true
    location?: true
    productId?: true
    blurhash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImageProductAggregateArgs = {
    /**
     * Filter which ImageProduct to aggregate.
     * 
    **/
    where?: ImageProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ImageProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImageProducts
    **/
    _count?: true | ImageProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageProductMaxAggregateInputType
  }

  export type GetImageProductAggregateType<T extends ImageProductAggregateArgs> = {
        [P in keyof T & keyof AggregateImageProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImageProduct[P]>
      : GetScalarType<T[P], AggregateImageProduct[P]>
  }




  export type ImageProductGroupByArgs = {
    where?: ImageProductWhereInput
    orderBy?: Enumerable<ImageProductOrderByWithAggregationInput>
    by: Array<ImageProductScalarFieldEnum>
    having?: ImageProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageProductCountAggregateInputType | true
    _min?: ImageProductMinAggregateInputType
    _max?: ImageProductMaxAggregateInputType
  }


  export type ImageProductGroupByOutputType = {
    id: string
    location: string
    productId: string
    blurhash: string | null
    createdAt: Date
    updatedAt: Date
    _count: ImageProductCountAggregateOutputType | null
    _min: ImageProductMinAggregateOutputType | null
    _max: ImageProductMaxAggregateOutputType | null
  }

  type GetImageProductGroupByPayload<T extends ImageProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ImageProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageProductGroupByOutputType[P]>
            : GetScalarType<T[P], ImageProductGroupByOutputType[P]>
        }
      >
    >


  export type ImageProductSelect = {
    id?: boolean
    location?: boolean
    productId?: boolean
    product?: boolean | ProductArgs
    blurhash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImageProductInclude = {
    product?: boolean | ProductArgs
  }

  export type ImageProductGetPayload<
    S extends boolean | null | undefined | ImageProductArgs,
    U = keyof S
      > = S extends true
        ? ImageProduct
    : S extends undefined
    ? never
    : S extends ImageProductArgs | ImageProductFindManyArgs
    ?'include' extends U
    ? ImageProduct  & {
    [P in TrueKeys<S['include']>]:
        P extends 'product' ? ProductGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'product' ? ProductGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof ImageProduct ? ImageProduct[P] : never
  } 
    : ImageProduct
  : ImageProduct


  type ImageProductCountArgs = Merge<
    Omit<ImageProductFindManyArgs, 'select' | 'include'> & {
      select?: ImageProductCountAggregateInputType | true
    }
  >

  export interface ImageProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ImageProduct that matches the filter.
     * @param {ImageProductFindUniqueArgs} args - Arguments to find a ImageProduct
     * @example
     * // Get one ImageProduct
     * const imageProduct = await prisma.imageProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ImageProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ImageProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ImageProduct'> extends True ? CheckSelect<T, Prisma__ImageProductClient<ImageProduct>, Prisma__ImageProductClient<ImageProductGetPayload<T>>> : CheckSelect<T, Prisma__ImageProductClient<ImageProduct | null, null>, Prisma__ImageProductClient<ImageProductGetPayload<T> | null, null>>

    /**
     * Find the first ImageProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageProductFindFirstArgs} args - Arguments to find a ImageProduct
     * @example
     * // Get one ImageProduct
     * const imageProduct = await prisma.imageProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ImageProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ImageProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ImageProduct'> extends True ? CheckSelect<T, Prisma__ImageProductClient<ImageProduct>, Prisma__ImageProductClient<ImageProductGetPayload<T>>> : CheckSelect<T, Prisma__ImageProductClient<ImageProduct | null, null>, Prisma__ImageProductClient<ImageProductGetPayload<T> | null, null>>

    /**
     * Find zero or more ImageProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImageProducts
     * const imageProducts = await prisma.imageProduct.findMany()
     * 
     * // Get first 10 ImageProducts
     * const imageProducts = await prisma.imageProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageProductWithIdOnly = await prisma.imageProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ImageProductFindManyArgs>(
      args?: SelectSubset<T, ImageProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ImageProduct>>, PrismaPromise<Array<ImageProductGetPayload<T>>>>

    /**
     * Create a ImageProduct.
     * @param {ImageProductCreateArgs} args - Arguments to create a ImageProduct.
     * @example
     * // Create one ImageProduct
     * const ImageProduct = await prisma.imageProduct.create({
     *   data: {
     *     // ... data to create a ImageProduct
     *   }
     * })
     * 
    **/
    create<T extends ImageProductCreateArgs>(
      args: SelectSubset<T, ImageProductCreateArgs>
    ): CheckSelect<T, Prisma__ImageProductClient<ImageProduct>, Prisma__ImageProductClient<ImageProductGetPayload<T>>>

    /**
     * Create many ImageProducts.
     *     @param {ImageProductCreateManyArgs} args - Arguments to create many ImageProducts.
     *     @example
     *     // Create many ImageProducts
     *     const imageProduct = await prisma.imageProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ImageProductCreateManyArgs>(
      args?: SelectSubset<T, ImageProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ImageProduct.
     * @param {ImageProductDeleteArgs} args - Arguments to delete one ImageProduct.
     * @example
     * // Delete one ImageProduct
     * const ImageProduct = await prisma.imageProduct.delete({
     *   where: {
     *     // ... filter to delete one ImageProduct
     *   }
     * })
     * 
    **/
    delete<T extends ImageProductDeleteArgs>(
      args: SelectSubset<T, ImageProductDeleteArgs>
    ): CheckSelect<T, Prisma__ImageProductClient<ImageProduct>, Prisma__ImageProductClient<ImageProductGetPayload<T>>>

    /**
     * Update one ImageProduct.
     * @param {ImageProductUpdateArgs} args - Arguments to update one ImageProduct.
     * @example
     * // Update one ImageProduct
     * const imageProduct = await prisma.imageProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ImageProductUpdateArgs>(
      args: SelectSubset<T, ImageProductUpdateArgs>
    ): CheckSelect<T, Prisma__ImageProductClient<ImageProduct>, Prisma__ImageProductClient<ImageProductGetPayload<T>>>

    /**
     * Delete zero or more ImageProducts.
     * @param {ImageProductDeleteManyArgs} args - Arguments to filter ImageProducts to delete.
     * @example
     * // Delete a few ImageProducts
     * const { count } = await prisma.imageProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ImageProductDeleteManyArgs>(
      args?: SelectSubset<T, ImageProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImageProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImageProducts
     * const imageProduct = await prisma.imageProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ImageProductUpdateManyArgs>(
      args: SelectSubset<T, ImageProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ImageProduct.
     * @param {ImageProductUpsertArgs} args - Arguments to update or create a ImageProduct.
     * @example
     * // Update or create a ImageProduct
     * const imageProduct = await prisma.imageProduct.upsert({
     *   create: {
     *     // ... data to create a ImageProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImageProduct we want to update
     *   }
     * })
    **/
    upsert<T extends ImageProductUpsertArgs>(
      args: SelectSubset<T, ImageProductUpsertArgs>
    ): CheckSelect<T, Prisma__ImageProductClient<ImageProduct>, Prisma__ImageProductClient<ImageProductGetPayload<T>>>

    /**
     * Find one ImageProduct that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ImageProductFindUniqueOrThrowArgs} args - Arguments to find a ImageProduct
     * @example
     * // Get one ImageProduct
     * const imageProduct = await prisma.imageProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ImageProductFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ImageProductFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ImageProductClient<ImageProduct>, Prisma__ImageProductClient<ImageProductGetPayload<T>>>

    /**
     * Find the first ImageProduct that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageProductFindFirstOrThrowArgs} args - Arguments to find a ImageProduct
     * @example
     * // Get one ImageProduct
     * const imageProduct = await prisma.imageProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ImageProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ImageProductFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ImageProductClient<ImageProduct>, Prisma__ImageProductClient<ImageProductGetPayload<T>>>

    /**
     * Count the number of ImageProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageProductCountArgs} args - Arguments to filter ImageProducts to count.
     * @example
     * // Count the number of ImageProducts
     * const count = await prisma.imageProduct.count({
     *   where: {
     *     // ... the filter for the ImageProducts we want to count
     *   }
     * })
    **/
    count<T extends ImageProductCountArgs>(
      args?: Subset<T, ImageProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImageProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageProductAggregateArgs>(args: Subset<T, ImageProductAggregateArgs>): PrismaPromise<GetImageProductAggregateType<T>>

    /**
     * Group by ImageProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageProductGroupByArgs['orderBy'] }
        : { orderBy?: ImageProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageProductGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ImageProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ImageProductClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | Null>, Prisma__ProductClient<ProductGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ImageProduct base type for findUnique actions
   */
  export type ImageProductFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ImageProduct
     * 
    **/
    select?: ImageProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageProductInclude | null
    /**
     * Filter, which ImageProduct to fetch.
     * 
    **/
    where: ImageProductWhereUniqueInput
  }

  /**
   * ImageProduct: findUnique
   */
  export interface ImageProductFindUniqueArgs extends ImageProductFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ImageProduct base type for findFirst actions
   */
  export type ImageProductFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ImageProduct
     * 
    **/
    select?: ImageProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageProductInclude | null
    /**
     * Filter, which ImageProduct to fetch.
     * 
    **/
    where?: ImageProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageProducts.
     * 
    **/
    cursor?: ImageProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageProducts.
     * 
    **/
    distinct?: Enumerable<ImageProductScalarFieldEnum>
  }

  /**
   * ImageProduct: findFirst
   */
  export interface ImageProductFindFirstArgs extends ImageProductFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ImageProduct findMany
   */
  export type ImageProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the ImageProduct
     * 
    **/
    select?: ImageProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageProductInclude | null
    /**
     * Filter, which ImageProducts to fetch.
     * 
    **/
    where?: ImageProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImageProducts.
     * 
    **/
    cursor?: ImageProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageProducts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ImageProductScalarFieldEnum>
  }


  /**
   * ImageProduct create
   */
  export type ImageProductCreateArgs = {
    /**
     * Select specific fields to fetch from the ImageProduct
     * 
    **/
    select?: ImageProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageProductInclude | null
    /**
     * The data needed to create a ImageProduct.
     * 
    **/
    data: XOR<ImageProductCreateInput, ImageProductUncheckedCreateInput>
  }


  /**
   * ImageProduct createMany
   */
  export type ImageProductCreateManyArgs = {
    /**
     * The data used to create many ImageProducts.
     * 
    **/
    data: Enumerable<ImageProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ImageProduct update
   */
  export type ImageProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the ImageProduct
     * 
    **/
    select?: ImageProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageProductInclude | null
    /**
     * The data needed to update a ImageProduct.
     * 
    **/
    data: XOR<ImageProductUpdateInput, ImageProductUncheckedUpdateInput>
    /**
     * Choose, which ImageProduct to update.
     * 
    **/
    where: ImageProductWhereUniqueInput
  }


  /**
   * ImageProduct updateMany
   */
  export type ImageProductUpdateManyArgs = {
    /**
     * The data used to update ImageProducts.
     * 
    **/
    data: XOR<ImageProductUpdateManyMutationInput, ImageProductUncheckedUpdateManyInput>
    /**
     * Filter which ImageProducts to update
     * 
    **/
    where?: ImageProductWhereInput
  }


  /**
   * ImageProduct upsert
   */
  export type ImageProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the ImageProduct
     * 
    **/
    select?: ImageProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageProductInclude | null
    /**
     * The filter to search for the ImageProduct to update in case it exists.
     * 
    **/
    where: ImageProductWhereUniqueInput
    /**
     * In case the ImageProduct found by the `where` argument doesn't exist, create a new ImageProduct with this data.
     * 
    **/
    create: XOR<ImageProductCreateInput, ImageProductUncheckedCreateInput>
    /**
     * In case the ImageProduct was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ImageProductUpdateInput, ImageProductUncheckedUpdateInput>
  }


  /**
   * ImageProduct delete
   */
  export type ImageProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the ImageProduct
     * 
    **/
    select?: ImageProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageProductInclude | null
    /**
     * Filter which ImageProduct to delete.
     * 
    **/
    where: ImageProductWhereUniqueInput
  }


  /**
   * ImageProduct deleteMany
   */
  export type ImageProductDeleteManyArgs = {
    /**
     * Filter which ImageProducts to delete
     * 
    **/
    where?: ImageProductWhereInput
  }


  /**
   * ImageProduct: findUniqueOrThrow
   */
  export type ImageProductFindUniqueOrThrowArgs = ImageProductFindUniqueArgsBase
      

  /**
   * ImageProduct: findFirstOrThrow
   */
  export type ImageProductFindFirstOrThrowArgs = ImageProductFindFirstArgsBase
      

  /**
   * ImageProduct without action
   */
  export type ImageProductArgs = {
    /**
     * Select specific fields to fetch from the ImageProduct
     * 
    **/
    select?: ImageProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageProductInclude | null
  }



  /**
   * Model ImageUser
   */


  export type AggregateImageUser = {
    _count: ImageUserCountAggregateOutputType | null
    _min: ImageUserMinAggregateOutputType | null
    _max: ImageUserMaxAggregateOutputType | null
  }

  export type ImageUserMinAggregateOutputType = {
    id: string | null
    location: string | null
    userId: string | null
    blurhash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageUserMaxAggregateOutputType = {
    id: string | null
    location: string | null
    userId: string | null
    blurhash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageUserCountAggregateOutputType = {
    id: number
    location: number
    userId: number
    blurhash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImageUserMinAggregateInputType = {
    id?: true
    location?: true
    userId?: true
    blurhash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageUserMaxAggregateInputType = {
    id?: true
    location?: true
    userId?: true
    blurhash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageUserCountAggregateInputType = {
    id?: true
    location?: true
    userId?: true
    blurhash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImageUserAggregateArgs = {
    /**
     * Filter which ImageUser to aggregate.
     * 
    **/
    where?: ImageUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ImageUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImageUsers
    **/
    _count?: true | ImageUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageUserMaxAggregateInputType
  }

  export type GetImageUserAggregateType<T extends ImageUserAggregateArgs> = {
        [P in keyof T & keyof AggregateImageUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImageUser[P]>
      : GetScalarType<T[P], AggregateImageUser[P]>
  }




  export type ImageUserGroupByArgs = {
    where?: ImageUserWhereInput
    orderBy?: Enumerable<ImageUserOrderByWithAggregationInput>
    by: Array<ImageUserScalarFieldEnum>
    having?: ImageUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageUserCountAggregateInputType | true
    _min?: ImageUserMinAggregateInputType
    _max?: ImageUserMaxAggregateInputType
  }


  export type ImageUserGroupByOutputType = {
    id: string
    location: string
    userId: string
    blurhash: string | null
    createdAt: Date
    updatedAt: Date
    _count: ImageUserCountAggregateOutputType | null
    _min: ImageUserMinAggregateOutputType | null
    _max: ImageUserMaxAggregateOutputType | null
  }

  type GetImageUserGroupByPayload<T extends ImageUserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ImageUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageUserGroupByOutputType[P]>
            : GetScalarType<T[P], ImageUserGroupByOutputType[P]>
        }
      >
    >


  export type ImageUserSelect = {
    id?: boolean
    location?: boolean
    userId?: boolean
    user?: boolean | UserArgs
    blurhash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImageUserInclude = {
    user?: boolean | UserArgs
  }

  export type ImageUserGetPayload<
    S extends boolean | null | undefined | ImageUserArgs,
    U = keyof S
      > = S extends true
        ? ImageUser
    : S extends undefined
    ? never
    : S extends ImageUserArgs | ImageUserFindManyArgs
    ?'include' extends U
    ? ImageUser  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof ImageUser ? ImageUser[P] : never
  } 
    : ImageUser
  : ImageUser


  type ImageUserCountArgs = Merge<
    Omit<ImageUserFindManyArgs, 'select' | 'include'> & {
      select?: ImageUserCountAggregateInputType | true
    }
  >

  export interface ImageUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ImageUser that matches the filter.
     * @param {ImageUserFindUniqueArgs} args - Arguments to find a ImageUser
     * @example
     * // Get one ImageUser
     * const imageUser = await prisma.imageUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ImageUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ImageUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ImageUser'> extends True ? CheckSelect<T, Prisma__ImageUserClient<ImageUser>, Prisma__ImageUserClient<ImageUserGetPayload<T>>> : CheckSelect<T, Prisma__ImageUserClient<ImageUser | null, null>, Prisma__ImageUserClient<ImageUserGetPayload<T> | null, null>>

    /**
     * Find the first ImageUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUserFindFirstArgs} args - Arguments to find a ImageUser
     * @example
     * // Get one ImageUser
     * const imageUser = await prisma.imageUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ImageUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ImageUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ImageUser'> extends True ? CheckSelect<T, Prisma__ImageUserClient<ImageUser>, Prisma__ImageUserClient<ImageUserGetPayload<T>>> : CheckSelect<T, Prisma__ImageUserClient<ImageUser | null, null>, Prisma__ImageUserClient<ImageUserGetPayload<T> | null, null>>

    /**
     * Find zero or more ImageUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImageUsers
     * const imageUsers = await prisma.imageUser.findMany()
     * 
     * // Get first 10 ImageUsers
     * const imageUsers = await prisma.imageUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageUserWithIdOnly = await prisma.imageUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ImageUserFindManyArgs>(
      args?: SelectSubset<T, ImageUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ImageUser>>, PrismaPromise<Array<ImageUserGetPayload<T>>>>

    /**
     * Create a ImageUser.
     * @param {ImageUserCreateArgs} args - Arguments to create a ImageUser.
     * @example
     * // Create one ImageUser
     * const ImageUser = await prisma.imageUser.create({
     *   data: {
     *     // ... data to create a ImageUser
     *   }
     * })
     * 
    **/
    create<T extends ImageUserCreateArgs>(
      args: SelectSubset<T, ImageUserCreateArgs>
    ): CheckSelect<T, Prisma__ImageUserClient<ImageUser>, Prisma__ImageUserClient<ImageUserGetPayload<T>>>

    /**
     * Create many ImageUsers.
     *     @param {ImageUserCreateManyArgs} args - Arguments to create many ImageUsers.
     *     @example
     *     // Create many ImageUsers
     *     const imageUser = await prisma.imageUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ImageUserCreateManyArgs>(
      args?: SelectSubset<T, ImageUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ImageUser.
     * @param {ImageUserDeleteArgs} args - Arguments to delete one ImageUser.
     * @example
     * // Delete one ImageUser
     * const ImageUser = await prisma.imageUser.delete({
     *   where: {
     *     // ... filter to delete one ImageUser
     *   }
     * })
     * 
    **/
    delete<T extends ImageUserDeleteArgs>(
      args: SelectSubset<T, ImageUserDeleteArgs>
    ): CheckSelect<T, Prisma__ImageUserClient<ImageUser>, Prisma__ImageUserClient<ImageUserGetPayload<T>>>

    /**
     * Update one ImageUser.
     * @param {ImageUserUpdateArgs} args - Arguments to update one ImageUser.
     * @example
     * // Update one ImageUser
     * const imageUser = await prisma.imageUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ImageUserUpdateArgs>(
      args: SelectSubset<T, ImageUserUpdateArgs>
    ): CheckSelect<T, Prisma__ImageUserClient<ImageUser>, Prisma__ImageUserClient<ImageUserGetPayload<T>>>

    /**
     * Delete zero or more ImageUsers.
     * @param {ImageUserDeleteManyArgs} args - Arguments to filter ImageUsers to delete.
     * @example
     * // Delete a few ImageUsers
     * const { count } = await prisma.imageUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ImageUserDeleteManyArgs>(
      args?: SelectSubset<T, ImageUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImageUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImageUsers
     * const imageUser = await prisma.imageUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ImageUserUpdateManyArgs>(
      args: SelectSubset<T, ImageUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ImageUser.
     * @param {ImageUserUpsertArgs} args - Arguments to update or create a ImageUser.
     * @example
     * // Update or create a ImageUser
     * const imageUser = await prisma.imageUser.upsert({
     *   create: {
     *     // ... data to create a ImageUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImageUser we want to update
     *   }
     * })
    **/
    upsert<T extends ImageUserUpsertArgs>(
      args: SelectSubset<T, ImageUserUpsertArgs>
    ): CheckSelect<T, Prisma__ImageUserClient<ImageUser>, Prisma__ImageUserClient<ImageUserGetPayload<T>>>

    /**
     * Find one ImageUser that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ImageUserFindUniqueOrThrowArgs} args - Arguments to find a ImageUser
     * @example
     * // Get one ImageUser
     * const imageUser = await prisma.imageUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ImageUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ImageUserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ImageUserClient<ImageUser>, Prisma__ImageUserClient<ImageUserGetPayload<T>>>

    /**
     * Find the first ImageUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUserFindFirstOrThrowArgs} args - Arguments to find a ImageUser
     * @example
     * // Get one ImageUser
     * const imageUser = await prisma.imageUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ImageUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ImageUserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ImageUserClient<ImageUser>, Prisma__ImageUserClient<ImageUserGetPayload<T>>>

    /**
     * Count the number of ImageUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUserCountArgs} args - Arguments to filter ImageUsers to count.
     * @example
     * // Count the number of ImageUsers
     * const count = await prisma.imageUser.count({
     *   where: {
     *     // ... the filter for the ImageUsers we want to count
     *   }
     * })
    **/
    count<T extends ImageUserCountArgs>(
      args?: Subset<T, ImageUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImageUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageUserAggregateArgs>(args: Subset<T, ImageUserAggregateArgs>): PrismaPromise<GetImageUserAggregateType<T>>

    /**
     * Group by ImageUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageUserGroupByArgs['orderBy'] }
        : { orderBy?: ImageUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ImageUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ImageUserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ImageUser base type for findUnique actions
   */
  export type ImageUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ImageUser
     * 
    **/
    select?: ImageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageUserInclude | null
    /**
     * Filter, which ImageUser to fetch.
     * 
    **/
    where: ImageUserWhereUniqueInput
  }

  /**
   * ImageUser: findUnique
   */
  export interface ImageUserFindUniqueArgs extends ImageUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ImageUser base type for findFirst actions
   */
  export type ImageUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ImageUser
     * 
    **/
    select?: ImageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageUserInclude | null
    /**
     * Filter, which ImageUser to fetch.
     * 
    **/
    where?: ImageUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageUsers.
     * 
    **/
    cursor?: ImageUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageUsers.
     * 
    **/
    distinct?: Enumerable<ImageUserScalarFieldEnum>
  }

  /**
   * ImageUser: findFirst
   */
  export interface ImageUserFindFirstArgs extends ImageUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ImageUser findMany
   */
  export type ImageUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the ImageUser
     * 
    **/
    select?: ImageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageUserInclude | null
    /**
     * Filter, which ImageUsers to fetch.
     * 
    **/
    where?: ImageUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImageUsers.
     * 
    **/
    cursor?: ImageUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ImageUserScalarFieldEnum>
  }


  /**
   * ImageUser create
   */
  export type ImageUserCreateArgs = {
    /**
     * Select specific fields to fetch from the ImageUser
     * 
    **/
    select?: ImageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageUserInclude | null
    /**
     * The data needed to create a ImageUser.
     * 
    **/
    data: XOR<ImageUserCreateInput, ImageUserUncheckedCreateInput>
  }


  /**
   * ImageUser createMany
   */
  export type ImageUserCreateManyArgs = {
    /**
     * The data used to create many ImageUsers.
     * 
    **/
    data: Enumerable<ImageUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ImageUser update
   */
  export type ImageUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the ImageUser
     * 
    **/
    select?: ImageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageUserInclude | null
    /**
     * The data needed to update a ImageUser.
     * 
    **/
    data: XOR<ImageUserUpdateInput, ImageUserUncheckedUpdateInput>
    /**
     * Choose, which ImageUser to update.
     * 
    **/
    where: ImageUserWhereUniqueInput
  }


  /**
   * ImageUser updateMany
   */
  export type ImageUserUpdateManyArgs = {
    /**
     * The data used to update ImageUsers.
     * 
    **/
    data: XOR<ImageUserUpdateManyMutationInput, ImageUserUncheckedUpdateManyInput>
    /**
     * Filter which ImageUsers to update
     * 
    **/
    where?: ImageUserWhereInput
  }


  /**
   * ImageUser upsert
   */
  export type ImageUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the ImageUser
     * 
    **/
    select?: ImageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageUserInclude | null
    /**
     * The filter to search for the ImageUser to update in case it exists.
     * 
    **/
    where: ImageUserWhereUniqueInput
    /**
     * In case the ImageUser found by the `where` argument doesn't exist, create a new ImageUser with this data.
     * 
    **/
    create: XOR<ImageUserCreateInput, ImageUserUncheckedCreateInput>
    /**
     * In case the ImageUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ImageUserUpdateInput, ImageUserUncheckedUpdateInput>
  }


  /**
   * ImageUser delete
   */
  export type ImageUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the ImageUser
     * 
    **/
    select?: ImageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageUserInclude | null
    /**
     * Filter which ImageUser to delete.
     * 
    **/
    where: ImageUserWhereUniqueInput
  }


  /**
   * ImageUser deleteMany
   */
  export type ImageUserDeleteManyArgs = {
    /**
     * Filter which ImageUsers to delete
     * 
    **/
    where?: ImageUserWhereInput
  }


  /**
   * ImageUser: findUniqueOrThrow
   */
  export type ImageUserFindUniqueOrThrowArgs = ImageUserFindUniqueArgsBase
      

  /**
   * ImageUser: findFirstOrThrow
   */
  export type ImageUserFindFirstOrThrowArgs = ImageUserFindFirstArgsBase
      

  /**
   * ImageUser without action
   */
  export type ImageUserArgs = {
    /**
     * Select specific fields to fetch from the ImageUser
     * 
    **/
    select?: ImageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageUserInclude | null
  }



  /**
   * Model ImageVendor
   */


  export type AggregateImageVendor = {
    _count: ImageVendorCountAggregateOutputType | null
    _min: ImageVendorMinAggregateOutputType | null
    _max: ImageVendorMaxAggregateOutputType | null
  }

  export type ImageVendorMinAggregateOutputType = {
    id: string | null
    location: string | null
    blurhash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageVendorMaxAggregateOutputType = {
    id: string | null
    location: string | null
    blurhash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageVendorCountAggregateOutputType = {
    id: number
    location: number
    blurhash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImageVendorMinAggregateInputType = {
    id?: true
    location?: true
    blurhash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageVendorMaxAggregateInputType = {
    id?: true
    location?: true
    blurhash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageVendorCountAggregateInputType = {
    id?: true
    location?: true
    blurhash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImageVendorAggregateArgs = {
    /**
     * Filter which ImageVendor to aggregate.
     * 
    **/
    where?: ImageVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageVendors to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageVendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ImageVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageVendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageVendors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImageVendors
    **/
    _count?: true | ImageVendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageVendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageVendorMaxAggregateInputType
  }

  export type GetImageVendorAggregateType<T extends ImageVendorAggregateArgs> = {
        [P in keyof T & keyof AggregateImageVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImageVendor[P]>
      : GetScalarType<T[P], AggregateImageVendor[P]>
  }




  export type ImageVendorGroupByArgs = {
    where?: ImageVendorWhereInput
    orderBy?: Enumerable<ImageVendorOrderByWithAggregationInput>
    by: Array<ImageVendorScalarFieldEnum>
    having?: ImageVendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageVendorCountAggregateInputType | true
    _min?: ImageVendorMinAggregateInputType
    _max?: ImageVendorMaxAggregateInputType
  }


  export type ImageVendorGroupByOutputType = {
    id: string
    location: string
    blurhash: string | null
    createdAt: Date
    updatedAt: Date
    _count: ImageVendorCountAggregateOutputType | null
    _min: ImageVendorMinAggregateOutputType | null
    _max: ImageVendorMaxAggregateOutputType | null
  }

  type GetImageVendorGroupByPayload<T extends ImageVendorGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ImageVendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageVendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageVendorGroupByOutputType[P]>
            : GetScalarType<T[P], ImageVendorGroupByOutputType[P]>
        }
      >
    >


  export type ImageVendorSelect = {
    id?: boolean
    location?: boolean
    blurhash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImageVendorGetPayload<
    S extends boolean | null | undefined | ImageVendorArgs,
    U = keyof S
      > = S extends true
        ? ImageVendor
    : S extends undefined
    ? never
    : S extends ImageVendorArgs | ImageVendorFindManyArgs
    ?'include' extends U
    ? ImageVendor 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ImageVendor ? ImageVendor[P] : never
  } 
    : ImageVendor
  : ImageVendor


  type ImageVendorCountArgs = Merge<
    Omit<ImageVendorFindManyArgs, 'select' | 'include'> & {
      select?: ImageVendorCountAggregateInputType | true
    }
  >

  export interface ImageVendorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ImageVendor that matches the filter.
     * @param {ImageVendorFindUniqueArgs} args - Arguments to find a ImageVendor
     * @example
     * // Get one ImageVendor
     * const imageVendor = await prisma.imageVendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ImageVendorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ImageVendorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ImageVendor'> extends True ? CheckSelect<T, Prisma__ImageVendorClient<ImageVendor>, Prisma__ImageVendorClient<ImageVendorGetPayload<T>>> : CheckSelect<T, Prisma__ImageVendorClient<ImageVendor | null, null>, Prisma__ImageVendorClient<ImageVendorGetPayload<T> | null, null>>

    /**
     * Find the first ImageVendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageVendorFindFirstArgs} args - Arguments to find a ImageVendor
     * @example
     * // Get one ImageVendor
     * const imageVendor = await prisma.imageVendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ImageVendorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ImageVendorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ImageVendor'> extends True ? CheckSelect<T, Prisma__ImageVendorClient<ImageVendor>, Prisma__ImageVendorClient<ImageVendorGetPayload<T>>> : CheckSelect<T, Prisma__ImageVendorClient<ImageVendor | null, null>, Prisma__ImageVendorClient<ImageVendorGetPayload<T> | null, null>>

    /**
     * Find zero or more ImageVendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageVendorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImageVendors
     * const imageVendors = await prisma.imageVendor.findMany()
     * 
     * // Get first 10 ImageVendors
     * const imageVendors = await prisma.imageVendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageVendorWithIdOnly = await prisma.imageVendor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ImageVendorFindManyArgs>(
      args?: SelectSubset<T, ImageVendorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ImageVendor>>, PrismaPromise<Array<ImageVendorGetPayload<T>>>>

    /**
     * Create a ImageVendor.
     * @param {ImageVendorCreateArgs} args - Arguments to create a ImageVendor.
     * @example
     * // Create one ImageVendor
     * const ImageVendor = await prisma.imageVendor.create({
     *   data: {
     *     // ... data to create a ImageVendor
     *   }
     * })
     * 
    **/
    create<T extends ImageVendorCreateArgs>(
      args: SelectSubset<T, ImageVendorCreateArgs>
    ): CheckSelect<T, Prisma__ImageVendorClient<ImageVendor>, Prisma__ImageVendorClient<ImageVendorGetPayload<T>>>

    /**
     * Create many ImageVendors.
     *     @param {ImageVendorCreateManyArgs} args - Arguments to create many ImageVendors.
     *     @example
     *     // Create many ImageVendors
     *     const imageVendor = await prisma.imageVendor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ImageVendorCreateManyArgs>(
      args?: SelectSubset<T, ImageVendorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ImageVendor.
     * @param {ImageVendorDeleteArgs} args - Arguments to delete one ImageVendor.
     * @example
     * // Delete one ImageVendor
     * const ImageVendor = await prisma.imageVendor.delete({
     *   where: {
     *     // ... filter to delete one ImageVendor
     *   }
     * })
     * 
    **/
    delete<T extends ImageVendorDeleteArgs>(
      args: SelectSubset<T, ImageVendorDeleteArgs>
    ): CheckSelect<T, Prisma__ImageVendorClient<ImageVendor>, Prisma__ImageVendorClient<ImageVendorGetPayload<T>>>

    /**
     * Update one ImageVendor.
     * @param {ImageVendorUpdateArgs} args - Arguments to update one ImageVendor.
     * @example
     * // Update one ImageVendor
     * const imageVendor = await prisma.imageVendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ImageVendorUpdateArgs>(
      args: SelectSubset<T, ImageVendorUpdateArgs>
    ): CheckSelect<T, Prisma__ImageVendorClient<ImageVendor>, Prisma__ImageVendorClient<ImageVendorGetPayload<T>>>

    /**
     * Delete zero or more ImageVendors.
     * @param {ImageVendorDeleteManyArgs} args - Arguments to filter ImageVendors to delete.
     * @example
     * // Delete a few ImageVendors
     * const { count } = await prisma.imageVendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ImageVendorDeleteManyArgs>(
      args?: SelectSubset<T, ImageVendorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImageVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageVendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImageVendors
     * const imageVendor = await prisma.imageVendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ImageVendorUpdateManyArgs>(
      args: SelectSubset<T, ImageVendorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ImageVendor.
     * @param {ImageVendorUpsertArgs} args - Arguments to update or create a ImageVendor.
     * @example
     * // Update or create a ImageVendor
     * const imageVendor = await prisma.imageVendor.upsert({
     *   create: {
     *     // ... data to create a ImageVendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImageVendor we want to update
     *   }
     * })
    **/
    upsert<T extends ImageVendorUpsertArgs>(
      args: SelectSubset<T, ImageVendorUpsertArgs>
    ): CheckSelect<T, Prisma__ImageVendorClient<ImageVendor>, Prisma__ImageVendorClient<ImageVendorGetPayload<T>>>

    /**
     * Find one ImageVendor that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ImageVendorFindUniqueOrThrowArgs} args - Arguments to find a ImageVendor
     * @example
     * // Get one ImageVendor
     * const imageVendor = await prisma.imageVendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ImageVendorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ImageVendorFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ImageVendorClient<ImageVendor>, Prisma__ImageVendorClient<ImageVendorGetPayload<T>>>

    /**
     * Find the first ImageVendor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageVendorFindFirstOrThrowArgs} args - Arguments to find a ImageVendor
     * @example
     * // Get one ImageVendor
     * const imageVendor = await prisma.imageVendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ImageVendorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ImageVendorFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ImageVendorClient<ImageVendor>, Prisma__ImageVendorClient<ImageVendorGetPayload<T>>>

    /**
     * Count the number of ImageVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageVendorCountArgs} args - Arguments to filter ImageVendors to count.
     * @example
     * // Count the number of ImageVendors
     * const count = await prisma.imageVendor.count({
     *   where: {
     *     // ... the filter for the ImageVendors we want to count
     *   }
     * })
    **/
    count<T extends ImageVendorCountArgs>(
      args?: Subset<T, ImageVendorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageVendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImageVendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageVendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageVendorAggregateArgs>(args: Subset<T, ImageVendorAggregateArgs>): PrismaPromise<GetImageVendorAggregateType<T>>

    /**
     * Group by ImageVendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageVendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageVendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageVendorGroupByArgs['orderBy'] }
        : { orderBy?: ImageVendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageVendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageVendorGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ImageVendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ImageVendorClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ImageVendor base type for findUnique actions
   */
  export type ImageVendorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ImageVendor
     * 
    **/
    select?: ImageVendorSelect | null
    /**
     * Filter, which ImageVendor to fetch.
     * 
    **/
    where: ImageVendorWhereUniqueInput
  }

  /**
   * ImageVendor: findUnique
   */
  export interface ImageVendorFindUniqueArgs extends ImageVendorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ImageVendor base type for findFirst actions
   */
  export type ImageVendorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ImageVendor
     * 
    **/
    select?: ImageVendorSelect | null
    /**
     * Filter, which ImageVendor to fetch.
     * 
    **/
    where?: ImageVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageVendors to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageVendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageVendors.
     * 
    **/
    cursor?: ImageVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageVendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageVendors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageVendors.
     * 
    **/
    distinct?: Enumerable<ImageVendorScalarFieldEnum>
  }

  /**
   * ImageVendor: findFirst
   */
  export interface ImageVendorFindFirstArgs extends ImageVendorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ImageVendor findMany
   */
  export type ImageVendorFindManyArgs = {
    /**
     * Select specific fields to fetch from the ImageVendor
     * 
    **/
    select?: ImageVendorSelect | null
    /**
     * Filter, which ImageVendors to fetch.
     * 
    **/
    where?: ImageVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageVendors to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageVendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImageVendors.
     * 
    **/
    cursor?: ImageVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageVendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageVendors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ImageVendorScalarFieldEnum>
  }


  /**
   * ImageVendor create
   */
  export type ImageVendorCreateArgs = {
    /**
     * Select specific fields to fetch from the ImageVendor
     * 
    **/
    select?: ImageVendorSelect | null
    /**
     * The data needed to create a ImageVendor.
     * 
    **/
    data: XOR<ImageVendorCreateInput, ImageVendorUncheckedCreateInput>
  }


  /**
   * ImageVendor createMany
   */
  export type ImageVendorCreateManyArgs = {
    /**
     * The data used to create many ImageVendors.
     * 
    **/
    data: Enumerable<ImageVendorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ImageVendor update
   */
  export type ImageVendorUpdateArgs = {
    /**
     * Select specific fields to fetch from the ImageVendor
     * 
    **/
    select?: ImageVendorSelect | null
    /**
     * The data needed to update a ImageVendor.
     * 
    **/
    data: XOR<ImageVendorUpdateInput, ImageVendorUncheckedUpdateInput>
    /**
     * Choose, which ImageVendor to update.
     * 
    **/
    where: ImageVendorWhereUniqueInput
  }


  /**
   * ImageVendor updateMany
   */
  export type ImageVendorUpdateManyArgs = {
    /**
     * The data used to update ImageVendors.
     * 
    **/
    data: XOR<ImageVendorUpdateManyMutationInput, ImageVendorUncheckedUpdateManyInput>
    /**
     * Filter which ImageVendors to update
     * 
    **/
    where?: ImageVendorWhereInput
  }


  /**
   * ImageVendor upsert
   */
  export type ImageVendorUpsertArgs = {
    /**
     * Select specific fields to fetch from the ImageVendor
     * 
    **/
    select?: ImageVendorSelect | null
    /**
     * The filter to search for the ImageVendor to update in case it exists.
     * 
    **/
    where: ImageVendorWhereUniqueInput
    /**
     * In case the ImageVendor found by the `where` argument doesn't exist, create a new ImageVendor with this data.
     * 
    **/
    create: XOR<ImageVendorCreateInput, ImageVendorUncheckedCreateInput>
    /**
     * In case the ImageVendor was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ImageVendorUpdateInput, ImageVendorUncheckedUpdateInput>
  }


  /**
   * ImageVendor delete
   */
  export type ImageVendorDeleteArgs = {
    /**
     * Select specific fields to fetch from the ImageVendor
     * 
    **/
    select?: ImageVendorSelect | null
    /**
     * Filter which ImageVendor to delete.
     * 
    **/
    where: ImageVendorWhereUniqueInput
  }


  /**
   * ImageVendor deleteMany
   */
  export type ImageVendorDeleteManyArgs = {
    /**
     * Filter which ImageVendors to delete
     * 
    **/
    where?: ImageVendorWhereInput
  }


  /**
   * ImageVendor: findUniqueOrThrow
   */
  export type ImageVendorFindUniqueOrThrowArgs = ImageVendorFindUniqueArgsBase
      

  /**
   * ImageVendor: findFirstOrThrow
   */
  export type ImageVendorFindFirstOrThrowArgs = ImageVendorFindFirstArgsBase
      

  /**
   * ImageVendor without action
   */
  export type ImageVendorArgs = {
    /**
     * Select specific fields to fetch from the ImageVendor
     * 
    **/
    select?: ImageVendorSelect | null
  }



  /**
   * Model Coordinates
   */


  export type AggregateCoordinates = {
    _count: CoordinatesCountAggregateOutputType | null
    _avg: CoordinatesAvgAggregateOutputType | null
    _sum: CoordinatesSumAggregateOutputType | null
    _min: CoordinatesMinAggregateOutputType | null
    _max: CoordinatesMaxAggregateOutputType | null
  }

  export type CoordinatesAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    radius: number | null
  }

  export type CoordinatesSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    radius: number | null
  }

  export type CoordinatesMinAggregateOutputType = {
    id: string | null
    latitude: number | null
    longitude: number | null
    radius: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoordinatesMaxAggregateOutputType = {
    id: string | null
    latitude: number | null
    longitude: number | null
    radius: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoordinatesCountAggregateOutputType = {
    id: number
    latitude: number
    longitude: number
    radius: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoordinatesAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    radius?: true
  }

  export type CoordinatesSumAggregateInputType = {
    latitude?: true
    longitude?: true
    radius?: true
  }

  export type CoordinatesMinAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    radius?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoordinatesMaxAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    radius?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoordinatesCountAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    radius?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoordinatesAggregateArgs = {
    /**
     * Filter which Coordinates to aggregate.
     * 
    **/
    where?: CoordinatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coordinates to fetch.
     * 
    **/
    orderBy?: Enumerable<CoordinatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CoordinatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coordinates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coordinates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coordinates
    **/
    _count?: true | CoordinatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoordinatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoordinatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoordinatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoordinatesMaxAggregateInputType
  }

  export type GetCoordinatesAggregateType<T extends CoordinatesAggregateArgs> = {
        [P in keyof T & keyof AggregateCoordinates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoordinates[P]>
      : GetScalarType<T[P], AggregateCoordinates[P]>
  }




  export type CoordinatesGroupByArgs = {
    where?: CoordinatesWhereInput
    orderBy?: Enumerable<CoordinatesOrderByWithAggregationInput>
    by: Array<CoordinatesScalarFieldEnum>
    having?: CoordinatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoordinatesCountAggregateInputType | true
    _avg?: CoordinatesAvgAggregateInputType
    _sum?: CoordinatesSumAggregateInputType
    _min?: CoordinatesMinAggregateInputType
    _max?: CoordinatesMaxAggregateInputType
  }


  export type CoordinatesGroupByOutputType = {
    id: string
    latitude: number
    longitude: number
    radius: number | null
    createdAt: Date
    updatedAt: Date
    _count: CoordinatesCountAggregateOutputType | null
    _avg: CoordinatesAvgAggregateOutputType | null
    _sum: CoordinatesSumAggregateOutputType | null
    _min: CoordinatesMinAggregateOutputType | null
    _max: CoordinatesMaxAggregateOutputType | null
  }

  type GetCoordinatesGroupByPayload<T extends CoordinatesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CoordinatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoordinatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoordinatesGroupByOutputType[P]>
            : GetScalarType<T[P], CoordinatesGroupByOutputType[P]>
        }
      >
    >


  export type CoordinatesSelect = {
    id?: boolean
    latitude?: boolean
    longitude?: boolean
    radius?: boolean
    addresses?: boolean | AddressFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | CoordinatesCountOutputTypeArgs
  }

  export type CoordinatesInclude = {
    addresses?: boolean | AddressFindManyArgs
    _count?: boolean | CoordinatesCountOutputTypeArgs
  }

  export type CoordinatesGetPayload<
    S extends boolean | null | undefined | CoordinatesArgs,
    U = keyof S
      > = S extends true
        ? Coordinates
    : S extends undefined
    ? never
    : S extends CoordinatesArgs | CoordinatesFindManyArgs
    ?'include' extends U
    ? Coordinates  & {
    [P in TrueKeys<S['include']>]:
        P extends 'addresses' ? Array < AddressGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CoordinatesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'addresses' ? Array < AddressGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CoordinatesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Coordinates ? Coordinates[P] : never
  } 
    : Coordinates
  : Coordinates


  type CoordinatesCountArgs = Merge<
    Omit<CoordinatesFindManyArgs, 'select' | 'include'> & {
      select?: CoordinatesCountAggregateInputType | true
    }
  >

  export interface CoordinatesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Coordinates that matches the filter.
     * @param {CoordinatesFindUniqueArgs} args - Arguments to find a Coordinates
     * @example
     * // Get one Coordinates
     * const coordinates = await prisma.coordinates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CoordinatesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CoordinatesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Coordinates'> extends True ? CheckSelect<T, Prisma__CoordinatesClient<Coordinates>, Prisma__CoordinatesClient<CoordinatesGetPayload<T>>> : CheckSelect<T, Prisma__CoordinatesClient<Coordinates | null, null>, Prisma__CoordinatesClient<CoordinatesGetPayload<T> | null, null>>

    /**
     * Find the first Coordinates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoordinatesFindFirstArgs} args - Arguments to find a Coordinates
     * @example
     * // Get one Coordinates
     * const coordinates = await prisma.coordinates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CoordinatesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CoordinatesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Coordinates'> extends True ? CheckSelect<T, Prisma__CoordinatesClient<Coordinates>, Prisma__CoordinatesClient<CoordinatesGetPayload<T>>> : CheckSelect<T, Prisma__CoordinatesClient<Coordinates | null, null>, Prisma__CoordinatesClient<CoordinatesGetPayload<T> | null, null>>

    /**
     * Find zero or more Coordinates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoordinatesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coordinates
     * const coordinates = await prisma.coordinates.findMany()
     * 
     * // Get first 10 Coordinates
     * const coordinates = await prisma.coordinates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coordinatesWithIdOnly = await prisma.coordinates.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CoordinatesFindManyArgs>(
      args?: SelectSubset<T, CoordinatesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Coordinates>>, PrismaPromise<Array<CoordinatesGetPayload<T>>>>

    /**
     * Create a Coordinates.
     * @param {CoordinatesCreateArgs} args - Arguments to create a Coordinates.
     * @example
     * // Create one Coordinates
     * const Coordinates = await prisma.coordinates.create({
     *   data: {
     *     // ... data to create a Coordinates
     *   }
     * })
     * 
    **/
    create<T extends CoordinatesCreateArgs>(
      args: SelectSubset<T, CoordinatesCreateArgs>
    ): CheckSelect<T, Prisma__CoordinatesClient<Coordinates>, Prisma__CoordinatesClient<CoordinatesGetPayload<T>>>

    /**
     * Create many Coordinates.
     *     @param {CoordinatesCreateManyArgs} args - Arguments to create many Coordinates.
     *     @example
     *     // Create many Coordinates
     *     const coordinates = await prisma.coordinates.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CoordinatesCreateManyArgs>(
      args?: SelectSubset<T, CoordinatesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Coordinates.
     * @param {CoordinatesDeleteArgs} args - Arguments to delete one Coordinates.
     * @example
     * // Delete one Coordinates
     * const Coordinates = await prisma.coordinates.delete({
     *   where: {
     *     // ... filter to delete one Coordinates
     *   }
     * })
     * 
    **/
    delete<T extends CoordinatesDeleteArgs>(
      args: SelectSubset<T, CoordinatesDeleteArgs>
    ): CheckSelect<T, Prisma__CoordinatesClient<Coordinates>, Prisma__CoordinatesClient<CoordinatesGetPayload<T>>>

    /**
     * Update one Coordinates.
     * @param {CoordinatesUpdateArgs} args - Arguments to update one Coordinates.
     * @example
     * // Update one Coordinates
     * const coordinates = await prisma.coordinates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CoordinatesUpdateArgs>(
      args: SelectSubset<T, CoordinatesUpdateArgs>
    ): CheckSelect<T, Prisma__CoordinatesClient<Coordinates>, Prisma__CoordinatesClient<CoordinatesGetPayload<T>>>

    /**
     * Delete zero or more Coordinates.
     * @param {CoordinatesDeleteManyArgs} args - Arguments to filter Coordinates to delete.
     * @example
     * // Delete a few Coordinates
     * const { count } = await prisma.coordinates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CoordinatesDeleteManyArgs>(
      args?: SelectSubset<T, CoordinatesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coordinates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoordinatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coordinates
     * const coordinates = await prisma.coordinates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CoordinatesUpdateManyArgs>(
      args: SelectSubset<T, CoordinatesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Coordinates.
     * @param {CoordinatesUpsertArgs} args - Arguments to update or create a Coordinates.
     * @example
     * // Update or create a Coordinates
     * const coordinates = await prisma.coordinates.upsert({
     *   create: {
     *     // ... data to create a Coordinates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coordinates we want to update
     *   }
     * })
    **/
    upsert<T extends CoordinatesUpsertArgs>(
      args: SelectSubset<T, CoordinatesUpsertArgs>
    ): CheckSelect<T, Prisma__CoordinatesClient<Coordinates>, Prisma__CoordinatesClient<CoordinatesGetPayload<T>>>

    /**
     * Find one Coordinates that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CoordinatesFindUniqueOrThrowArgs} args - Arguments to find a Coordinates
     * @example
     * // Get one Coordinates
     * const coordinates = await prisma.coordinates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CoordinatesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CoordinatesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CoordinatesClient<Coordinates>, Prisma__CoordinatesClient<CoordinatesGetPayload<T>>>

    /**
     * Find the first Coordinates that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoordinatesFindFirstOrThrowArgs} args - Arguments to find a Coordinates
     * @example
     * // Get one Coordinates
     * const coordinates = await prisma.coordinates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CoordinatesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CoordinatesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CoordinatesClient<Coordinates>, Prisma__CoordinatesClient<CoordinatesGetPayload<T>>>

    /**
     * Count the number of Coordinates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoordinatesCountArgs} args - Arguments to filter Coordinates to count.
     * @example
     * // Count the number of Coordinates
     * const count = await prisma.coordinates.count({
     *   where: {
     *     // ... the filter for the Coordinates we want to count
     *   }
     * })
    **/
    count<T extends CoordinatesCountArgs>(
      args?: Subset<T, CoordinatesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoordinatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coordinates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoordinatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoordinatesAggregateArgs>(args: Subset<T, CoordinatesAggregateArgs>): PrismaPromise<GetCoordinatesAggregateType<T>>

    /**
     * Group by Coordinates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoordinatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoordinatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoordinatesGroupByArgs['orderBy'] }
        : { orderBy?: CoordinatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoordinatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoordinatesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Coordinates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CoordinatesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    addresses<T extends AddressFindManyArgs = {}>(args?: Subset<T, AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Address>| Null>, PrismaPromise<Array<AddressGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Coordinates base type for findUnique actions
   */
  export type CoordinatesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Coordinates
     * 
    **/
    select?: CoordinatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoordinatesInclude | null
    /**
     * Filter, which Coordinates to fetch.
     * 
    **/
    where: CoordinatesWhereUniqueInput
  }

  /**
   * Coordinates: findUnique
   */
  export interface CoordinatesFindUniqueArgs extends CoordinatesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Coordinates base type for findFirst actions
   */
  export type CoordinatesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Coordinates
     * 
    **/
    select?: CoordinatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoordinatesInclude | null
    /**
     * Filter, which Coordinates to fetch.
     * 
    **/
    where?: CoordinatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coordinates to fetch.
     * 
    **/
    orderBy?: Enumerable<CoordinatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coordinates.
     * 
    **/
    cursor?: CoordinatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coordinates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coordinates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coordinates.
     * 
    **/
    distinct?: Enumerable<CoordinatesScalarFieldEnum>
  }

  /**
   * Coordinates: findFirst
   */
  export interface CoordinatesFindFirstArgs extends CoordinatesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Coordinates findMany
   */
  export type CoordinatesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Coordinates
     * 
    **/
    select?: CoordinatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoordinatesInclude | null
    /**
     * Filter, which Coordinates to fetch.
     * 
    **/
    where?: CoordinatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coordinates to fetch.
     * 
    **/
    orderBy?: Enumerable<CoordinatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coordinates.
     * 
    **/
    cursor?: CoordinatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coordinates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coordinates.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CoordinatesScalarFieldEnum>
  }


  /**
   * Coordinates create
   */
  export type CoordinatesCreateArgs = {
    /**
     * Select specific fields to fetch from the Coordinates
     * 
    **/
    select?: CoordinatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoordinatesInclude | null
    /**
     * The data needed to create a Coordinates.
     * 
    **/
    data: XOR<CoordinatesCreateInput, CoordinatesUncheckedCreateInput>
  }


  /**
   * Coordinates createMany
   */
  export type CoordinatesCreateManyArgs = {
    /**
     * The data used to create many Coordinates.
     * 
    **/
    data: Enumerable<CoordinatesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Coordinates update
   */
  export type CoordinatesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Coordinates
     * 
    **/
    select?: CoordinatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoordinatesInclude | null
    /**
     * The data needed to update a Coordinates.
     * 
    **/
    data: XOR<CoordinatesUpdateInput, CoordinatesUncheckedUpdateInput>
    /**
     * Choose, which Coordinates to update.
     * 
    **/
    where: CoordinatesWhereUniqueInput
  }


  /**
   * Coordinates updateMany
   */
  export type CoordinatesUpdateManyArgs = {
    /**
     * The data used to update Coordinates.
     * 
    **/
    data: XOR<CoordinatesUpdateManyMutationInput, CoordinatesUncheckedUpdateManyInput>
    /**
     * Filter which Coordinates to update
     * 
    **/
    where?: CoordinatesWhereInput
  }


  /**
   * Coordinates upsert
   */
  export type CoordinatesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Coordinates
     * 
    **/
    select?: CoordinatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoordinatesInclude | null
    /**
     * The filter to search for the Coordinates to update in case it exists.
     * 
    **/
    where: CoordinatesWhereUniqueInput
    /**
     * In case the Coordinates found by the `where` argument doesn't exist, create a new Coordinates with this data.
     * 
    **/
    create: XOR<CoordinatesCreateInput, CoordinatesUncheckedCreateInput>
    /**
     * In case the Coordinates was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CoordinatesUpdateInput, CoordinatesUncheckedUpdateInput>
  }


  /**
   * Coordinates delete
   */
  export type CoordinatesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Coordinates
     * 
    **/
    select?: CoordinatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoordinatesInclude | null
    /**
     * Filter which Coordinates to delete.
     * 
    **/
    where: CoordinatesWhereUniqueInput
  }


  /**
   * Coordinates deleteMany
   */
  export type CoordinatesDeleteManyArgs = {
    /**
     * Filter which Coordinates to delete
     * 
    **/
    where?: CoordinatesWhereInput
  }


  /**
   * Coordinates: findUniqueOrThrow
   */
  export type CoordinatesFindUniqueOrThrowArgs = CoordinatesFindUniqueArgsBase
      

  /**
   * Coordinates: findFirstOrThrow
   */
  export type CoordinatesFindFirstOrThrowArgs = CoordinatesFindFirstArgsBase
      

  /**
   * Coordinates without action
   */
  export type CoordinatesArgs = {
    /**
     * Select specific fields to fetch from the Coordinates
     * 
    **/
    select?: CoordinatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoordinatesInclude | null
  }



  /**
   * Model Membership
   */


  export type AggregateMembership = {
    _count: MembershipCountAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  export type MembershipMinAggregateOutputType = {
    id: string | null
    role: MembershipRole | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipMaxAggregateOutputType = {
    id: string | null
    role: MembershipRole | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipCountAggregateOutputType = {
    id: number
    role: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MembershipMinAggregateInputType = {
    id?: true
    role?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipMaxAggregateInputType = {
    id?: true
    role?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipCountAggregateInputType = {
    id?: true
    role?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MembershipAggregateArgs = {
    /**
     * Filter which Membership to aggregate.
     * 
    **/
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     * 
    **/
    orderBy?: Enumerable<MembershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Memberships
    **/
    _count?: true | MembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipMaxAggregateInputType
  }

  export type GetMembershipAggregateType<T extends MembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembership[P]>
      : GetScalarType<T[P], AggregateMembership[P]>
  }




  export type MembershipGroupByArgs = {
    where?: MembershipWhereInput
    orderBy?: Enumerable<MembershipOrderByWithAggregationInput>
    by: Array<MembershipScalarFieldEnum>
    having?: MembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipCountAggregateInputType | true
    _min?: MembershipMinAggregateInputType
    _max?: MembershipMaxAggregateInputType
  }


  export type MembershipGroupByOutputType = {
    id: string
    role: MembershipRole
    userId: string | null
    createdAt: Date
    updatedAt: Date
    _count: MembershipCountAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  type GetMembershipGroupByPayload<T extends MembershipGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipGroupByOutputType[P]>
        }
      >
    >


  export type MembershipSelect = {
    id?: boolean
    role?: boolean
    organizations?: boolean | organizationMembershipFindManyArgs
    userId?: boolean
    user?: boolean | UserArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | MembershipCountOutputTypeArgs
  }

  export type MembershipInclude = {
    organizations?: boolean | organizationMembershipFindManyArgs
    user?: boolean | UserArgs
    _count?: boolean | MembershipCountOutputTypeArgs
  }

  export type MembershipGetPayload<
    S extends boolean | null | undefined | MembershipArgs,
    U = keyof S
      > = S extends true
        ? Membership
    : S extends undefined
    ? never
    : S extends MembershipArgs | MembershipFindManyArgs
    ?'include' extends U
    ? Membership  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organizations' ? Array < organizationMembershipGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends '_count' ? MembershipCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organizations' ? Array < organizationMembershipGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends '_count' ? MembershipCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Membership ? Membership[P] : never
  } 
    : Membership
  : Membership


  type MembershipCountArgs = Merge<
    Omit<MembershipFindManyArgs, 'select' | 'include'> & {
      select?: MembershipCountAggregateInputType | true
    }
  >

  export interface MembershipDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Membership that matches the filter.
     * @param {MembershipFindUniqueArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MembershipFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MembershipFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Membership'> extends True ? CheckSelect<T, Prisma__MembershipClient<Membership>, Prisma__MembershipClient<MembershipGetPayload<T>>> : CheckSelect<T, Prisma__MembershipClient<Membership | null, null>, Prisma__MembershipClient<MembershipGetPayload<T> | null, null>>

    /**
     * Find the first Membership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MembershipFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MembershipFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Membership'> extends True ? CheckSelect<T, Prisma__MembershipClient<Membership>, Prisma__MembershipClient<MembershipGetPayload<T>>> : CheckSelect<T, Prisma__MembershipClient<Membership | null, null>, Prisma__MembershipClient<MembershipGetPayload<T> | null, null>>

    /**
     * Find zero or more Memberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memberships
     * const memberships = await prisma.membership.findMany()
     * 
     * // Get first 10 Memberships
     * const memberships = await prisma.membership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipWithIdOnly = await prisma.membership.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MembershipFindManyArgs>(
      args?: SelectSubset<T, MembershipFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Membership>>, PrismaPromise<Array<MembershipGetPayload<T>>>>

    /**
     * Create a Membership.
     * @param {MembershipCreateArgs} args - Arguments to create a Membership.
     * @example
     * // Create one Membership
     * const Membership = await prisma.membership.create({
     *   data: {
     *     // ... data to create a Membership
     *   }
     * })
     * 
    **/
    create<T extends MembershipCreateArgs>(
      args: SelectSubset<T, MembershipCreateArgs>
    ): CheckSelect<T, Prisma__MembershipClient<Membership>, Prisma__MembershipClient<MembershipGetPayload<T>>>

    /**
     * Create many Memberships.
     *     @param {MembershipCreateManyArgs} args - Arguments to create many Memberships.
     *     @example
     *     // Create many Memberships
     *     const membership = await prisma.membership.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MembershipCreateManyArgs>(
      args?: SelectSubset<T, MembershipCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Membership.
     * @param {MembershipDeleteArgs} args - Arguments to delete one Membership.
     * @example
     * // Delete one Membership
     * const Membership = await prisma.membership.delete({
     *   where: {
     *     // ... filter to delete one Membership
     *   }
     * })
     * 
    **/
    delete<T extends MembershipDeleteArgs>(
      args: SelectSubset<T, MembershipDeleteArgs>
    ): CheckSelect<T, Prisma__MembershipClient<Membership>, Prisma__MembershipClient<MembershipGetPayload<T>>>

    /**
     * Update one Membership.
     * @param {MembershipUpdateArgs} args - Arguments to update one Membership.
     * @example
     * // Update one Membership
     * const membership = await prisma.membership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MembershipUpdateArgs>(
      args: SelectSubset<T, MembershipUpdateArgs>
    ): CheckSelect<T, Prisma__MembershipClient<Membership>, Prisma__MembershipClient<MembershipGetPayload<T>>>

    /**
     * Delete zero or more Memberships.
     * @param {MembershipDeleteManyArgs} args - Arguments to filter Memberships to delete.
     * @example
     * // Delete a few Memberships
     * const { count } = await prisma.membership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MembershipDeleteManyArgs>(
      args?: SelectSubset<T, MembershipDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MembershipUpdateManyArgs>(
      args: SelectSubset<T, MembershipUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Membership.
     * @param {MembershipUpsertArgs} args - Arguments to update or create a Membership.
     * @example
     * // Update or create a Membership
     * const membership = await prisma.membership.upsert({
     *   create: {
     *     // ... data to create a Membership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Membership we want to update
     *   }
     * })
    **/
    upsert<T extends MembershipUpsertArgs>(
      args: SelectSubset<T, MembershipUpsertArgs>
    ): CheckSelect<T, Prisma__MembershipClient<Membership>, Prisma__MembershipClient<MembershipGetPayload<T>>>

    /**
     * Find one Membership that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {MembershipFindUniqueOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MembershipFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MembershipFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__MembershipClient<Membership>, Prisma__MembershipClient<MembershipGetPayload<T>>>

    /**
     * Find the first Membership that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MembershipFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MembershipFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__MembershipClient<Membership>, Prisma__MembershipClient<MembershipGetPayload<T>>>

    /**
     * Count the number of Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipCountArgs} args - Arguments to filter Memberships to count.
     * @example
     * // Count the number of Memberships
     * const count = await prisma.membership.count({
     *   where: {
     *     // ... the filter for the Memberships we want to count
     *   }
     * })
    **/
    count<T extends MembershipCountArgs>(
      args?: Subset<T, MembershipCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipAggregateArgs>(args: Subset<T, MembershipAggregateArgs>): PrismaPromise<GetMembershipAggregateType<T>>

    /**
     * Group by Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipGroupByArgs['orderBy'] }
        : { orderBy?: MembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Membership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MembershipClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organizations<T extends organizationMembershipFindManyArgs = {}>(args?: Subset<T, organizationMembershipFindManyArgs>): CheckSelect<T, PrismaPromise<Array<organizationMembership>| Null>, PrismaPromise<Array<organizationMembershipGetPayload<T>>| Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Membership base type for findUnique actions
   */
  export type MembershipFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Membership
     * 
    **/
    select?: MembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MembershipInclude | null
    /**
     * Filter, which Membership to fetch.
     * 
    **/
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership: findUnique
   */
  export interface MembershipFindUniqueArgs extends MembershipFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Membership base type for findFirst actions
   */
  export type MembershipFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Membership
     * 
    **/
    select?: MembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MembershipInclude | null
    /**
     * Filter, which Membership to fetch.
     * 
    **/
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     * 
    **/
    orderBy?: Enumerable<MembershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     * 
    **/
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     * 
    **/
    distinct?: Enumerable<MembershipScalarFieldEnum>
  }

  /**
   * Membership: findFirst
   */
  export interface MembershipFindFirstArgs extends MembershipFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Membership findMany
   */
  export type MembershipFindManyArgs = {
    /**
     * Select specific fields to fetch from the Membership
     * 
    **/
    select?: MembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MembershipInclude | null
    /**
     * Filter, which Memberships to fetch.
     * 
    **/
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     * 
    **/
    orderBy?: Enumerable<MembershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Memberships.
     * 
    **/
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MembershipScalarFieldEnum>
  }


  /**
   * Membership create
   */
  export type MembershipCreateArgs = {
    /**
     * Select specific fields to fetch from the Membership
     * 
    **/
    select?: MembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MembershipInclude | null
    /**
     * The data needed to create a Membership.
     * 
    **/
    data: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>
  }


  /**
   * Membership createMany
   */
  export type MembershipCreateManyArgs = {
    /**
     * The data used to create many Memberships.
     * 
    **/
    data: Enumerable<MembershipCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Membership update
   */
  export type MembershipUpdateArgs = {
    /**
     * Select specific fields to fetch from the Membership
     * 
    **/
    select?: MembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MembershipInclude | null
    /**
     * The data needed to update a Membership.
     * 
    **/
    data: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>
    /**
     * Choose, which Membership to update.
     * 
    **/
    where: MembershipWhereUniqueInput
  }


  /**
   * Membership updateMany
   */
  export type MembershipUpdateManyArgs = {
    /**
     * The data used to update Memberships.
     * 
    **/
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyInput>
    /**
     * Filter which Memberships to update
     * 
    **/
    where?: MembershipWhereInput
  }


  /**
   * Membership upsert
   */
  export type MembershipUpsertArgs = {
    /**
     * Select specific fields to fetch from the Membership
     * 
    **/
    select?: MembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MembershipInclude | null
    /**
     * The filter to search for the Membership to update in case it exists.
     * 
    **/
    where: MembershipWhereUniqueInput
    /**
     * In case the Membership found by the `where` argument doesn't exist, create a new Membership with this data.
     * 
    **/
    create: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>
    /**
     * In case the Membership was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>
  }


  /**
   * Membership delete
   */
  export type MembershipDeleteArgs = {
    /**
     * Select specific fields to fetch from the Membership
     * 
    **/
    select?: MembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MembershipInclude | null
    /**
     * Filter which Membership to delete.
     * 
    **/
    where: MembershipWhereUniqueInput
  }


  /**
   * Membership deleteMany
   */
  export type MembershipDeleteManyArgs = {
    /**
     * Filter which Memberships to delete
     * 
    **/
    where?: MembershipWhereInput
  }


  /**
   * Membership: findUniqueOrThrow
   */
  export type MembershipFindUniqueOrThrowArgs = MembershipFindUniqueArgsBase
      

  /**
   * Membership: findFirstOrThrow
   */
  export type MembershipFindFirstOrThrowArgs = MembershipFindFirstArgsBase
      

  /**
   * Membership without action
   */
  export type MembershipArgs = {
    /**
     * Select specific fields to fetch from the Membership
     * 
    **/
    select?: MembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MembershipInclude | null
  }



  /**
   * Model Order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    total: number | null
  }

  export type OrderSumAggregateOutputType = {
    total: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    total: number | null
    status: OrderStatus | null
    customerId: string | null
    driverId: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    total: number | null
    status: OrderStatus | null
    customerId: string | null
    driverId: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    total: number
    status: number
    customerId: number
    driverId: number
    organizationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    total?: true
  }

  export type OrderSumAggregateInputType = {
    total?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    total?: true
    status?: true
    customerId?: true
    driverId?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    total?: true
    status?: true
    customerId?: true
    driverId?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    total?: true
    status?: true
    customerId?: true
    driverId?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs = {
    /**
     * Filter which Order to aggregate.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs = {
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithAggregationInput>
    by: Array<OrderScalarFieldEnum>
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: string
    total: number
    status: OrderStatus
    customerId: string
    driverId: string | null
    organizationId: string
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect = {
    id?: boolean
    total?: boolean
    status?: boolean
    items?: boolean | ProductFindManyArgs
    customerId?: boolean
    customer?: boolean | UserArgs
    driverId?: boolean
    driver?: boolean | DriverArgs
    organizationId?: boolean
    organization?: boolean | OrganizationArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderInclude = {
    items?: boolean | ProductFindManyArgs
    customer?: boolean | UserArgs
    driver?: boolean | DriverArgs
    organization?: boolean | OrganizationArgs
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderGetPayload<
    S extends boolean | null | undefined | OrderArgs,
    U = keyof S
      > = S extends true
        ? Order
    : S extends undefined
    ? never
    : S extends OrderArgs | OrderFindManyArgs
    ?'include' extends U
    ? Order  & {
    [P in TrueKeys<S['include']>]:
        P extends 'items' ? Array < ProductGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'customer' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'driver' ? DriverGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'organization' ? OrganizationGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends '_count' ? OrderCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'items' ? Array < ProductGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'customer' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'driver' ? DriverGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'organization' ? OrganizationGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends '_count' ? OrderCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Order ? Order[P] : never
  } 
    : Order
  : Order


  type OrderCountArgs = Merge<
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }
  >

  export interface OrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Order'> extends True ? CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>> : CheckSelect<T, Prisma__OrderClient<Order | null, null>, Prisma__OrderClient<OrderGetPayload<T> | null, null>>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Order'> extends True ? CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>> : CheckSelect<T, Prisma__OrderClient<Order | null, null>, Prisma__OrderClient<OrderGetPayload<T> | null, null>>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Find one Order that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Find the first Order that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    items<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>| Null>, PrismaPromise<Array<ProductGetPayload<T>>| Null>>;

    customer<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    driver<T extends DriverArgs = {}>(args?: Subset<T, DriverArgs>): CheckSelect<T, Prisma__DriverClient<Driver | Null>, Prisma__DriverClient<DriverGetPayload<T> | Null>>;

    organization<T extends OrganizationArgs = {}>(args?: Subset<T, OrganizationArgs>): CheckSelect<T, Prisma__OrganizationClient<Organization | Null>, Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Order base type for findUnique actions
   */
  export type OrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where: OrderWhereUniqueInput
  }

  /**
   * Order: findUnique
   */
  export interface OrderFindUniqueArgs extends OrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order base type for findFirst actions
   */
  export type OrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     * 
    **/
    distinct?: Enumerable<OrderScalarFieldEnum>
  }

  /**
   * Order: findFirst
   */
  export interface OrderFindFirstArgs extends OrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findMany
   */
  export type OrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Orders to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order create
   */
  export type OrderCreateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to create a Order.
     * 
    **/
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs = {
    /**
     * The data used to create many Orders.
     * 
    **/
    data: Enumerable<OrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to update a Order.
     * 
    **/
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs = {
    /**
     * The data used to update Orders.
     * 
    **/
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     * 
    **/
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The filter to search for the Order to update in case it exists.
     * 
    **/
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     * 
    **/
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter which Order to delete.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs = {
    /**
     * Filter which Orders to delete
     * 
    **/
    where?: OrderWhereInput
  }


  /**
   * Order: findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs = OrderFindUniqueArgsBase
      

  /**
   * Order: findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs = OrderFindFirstArgsBase
      

  /**
   * Order without action
   */
  export type OrderArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
  }



  /**
   * Model Payment
   */


  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs = {
    /**
     * Filter which Payment to aggregate.
     * 
    **/
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs = {
    where?: PaymentWhereInput
    orderBy?: Enumerable<PaymentOrderByWithAggregationInput>
    by: Array<PaymentScalarFieldEnum>
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }


  export type PaymentGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentGetPayload<
    S extends boolean | null | undefined | PaymentArgs,
    U = keyof S
      > = S extends true
        ? Payment
    : S extends undefined
    ? never
    : S extends PaymentArgs | PaymentFindManyArgs
    ?'include' extends U
    ? Payment 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Payment ? Payment[P] : never
  } 
    : Payment
  : Payment


  type PaymentCountArgs = Merge<
    Omit<PaymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }
  >

  export interface PaymentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Payment'> extends True ? CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>> : CheckSelect<T, Prisma__PaymentClient<Payment | null, null>, Prisma__PaymentClient<PaymentGetPayload<T> | null, null>>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Payment'> extends True ? CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>> : CheckSelect<T, Prisma__PaymentClient<Payment | null, null>, Prisma__PaymentClient<PaymentGetPayload<T> | null, null>>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentFindManyArgs>(
      args?: SelectSubset<T, PaymentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Payment>>, PrismaPromise<Array<PaymentGetPayload<T>>>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends PaymentCreateArgs>(
      args: SelectSubset<T, PaymentCreateArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Create many Payments.
     *     @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCreateManyArgs>(
      args?: SelectSubset<T, PaymentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends PaymentDeleteArgs>(
      args: SelectSubset<T, PaymentDeleteArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentUpdateArgs>(
      args: SelectSubset<T, PaymentUpdateArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentDeleteManyArgs>(
      args?: SelectSubset<T, PaymentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentUpdateManyArgs>(
      args: SelectSubset<T, PaymentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentUpsertArgs>(
      args: SelectSubset<T, PaymentUpsertArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Find one Payment that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PaymentFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Find the first Payment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Payment base type for findUnique actions
   */
  export type PaymentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Filter, which Payment to fetch.
     * 
    **/
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment: findUnique
   */
  export interface PaymentFindUniqueArgs extends PaymentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Payment base type for findFirst actions
   */
  export type PaymentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Filter, which Payment to fetch.
     * 
    **/
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     * 
    **/
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     * 
    **/
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }

  /**
   * Payment: findFirst
   */
  export interface PaymentFindFirstArgs extends PaymentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Filter, which Payments to fetch.
     * 
    **/
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     * 
    **/
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Payment create
   */
  export type PaymentCreateArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * The data needed to create a Payment.
     * 
    **/
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }


  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs = {
    /**
     * The data used to create many Payments.
     * 
    **/
    data: Enumerable<PaymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Payment update
   */
  export type PaymentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * The data needed to update a Payment.
     * 
    **/
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     * 
    **/
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs = {
    /**
     * The data used to update Payments.
     * 
    **/
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     * 
    **/
    where?: PaymentWhereInput
  }


  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * The filter to search for the Payment to update in case it exists.
     * 
    **/
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     * 
    **/
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }


  /**
   * Payment delete
   */
  export type PaymentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Filter which Payment to delete.
     * 
    **/
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs = {
    /**
     * Filter which Payments to delete
     * 
    **/
    where?: PaymentWhereInput
  }


  /**
   * Payment: findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs = PaymentFindUniqueArgsBase
      

  /**
   * Payment: findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs = PaymentFindFirstArgsBase
      

  /**
   * Payment without action
   */
  export type PaymentArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
  }



  /**
   * Model Organization
   */


  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    dialCode: string | null
    phone: string | null
    vendorId: string | null
    subdomainId: string | null
    termsAccepted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    dialCode: string | null
    phone: string | null
    vendorId: string | null
    subdomainId: string | null
    termsAccepted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    dialCode: number
    phone: number
    vendorId: number
    subdomainId: number
    termsAccepted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    dialCode?: true
    phone?: true
    vendorId?: true
    subdomainId?: true
    termsAccepted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    dialCode?: true
    phone?: true
    vendorId?: true
    subdomainId?: true
    termsAccepted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    dialCode?: true
    phone?: true
    vendorId?: true
    subdomainId?: true
    termsAccepted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs = {
    /**
     * Filter which Organization to aggregate.
     * 
    **/
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     * 
    **/
    orderBy?: Enumerable<OrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs = {
    where?: OrganizationWhereInput
    orderBy?: Enumerable<OrganizationOrderByWithAggregationInput>
    by: Array<OrganizationScalarFieldEnum>
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }


  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    dialCode: string | null
    phone: string | null
    vendorId: string
    subdomainId: string
    termsAccepted: boolean
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect = {
    id?: boolean
    name?: boolean
    address?: boolean | AddressArgs
    email?: boolean
    emailVerified?: boolean
    dialCode?: boolean
    phone?: boolean
    images?: boolean | ImageOrganizationFindManyArgs
    memberships?: boolean | organizationMembershipFindManyArgs
    products?: boolean | ProductFindManyArgs
    vendorId?: boolean
    vendor?: boolean | VendorArgs
    subdomainId?: boolean
    termsAccepted?: boolean
    subdomain?: boolean | SubDomainArgs
    siteSetting?: boolean | SiteSettingArgs
    orders?: boolean | OrderFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | OrganizationCountOutputTypeArgs
  }

  export type OrganizationInclude = {
    address?: boolean | AddressArgs
    images?: boolean | ImageOrganizationFindManyArgs
    memberships?: boolean | organizationMembershipFindManyArgs
    products?: boolean | ProductFindManyArgs
    vendor?: boolean | VendorArgs
    subdomain?: boolean | SubDomainArgs
    siteSetting?: boolean | SiteSettingArgs
    orders?: boolean | OrderFindManyArgs
    _count?: boolean | OrganizationCountOutputTypeArgs
  }

  export type OrganizationGetPayload<
    S extends boolean | null | undefined | OrganizationArgs,
    U = keyof S
      > = S extends true
        ? Organization
    : S extends undefined
    ? never
    : S extends OrganizationArgs | OrganizationFindManyArgs
    ?'include' extends U
    ? Organization  & {
    [P in TrueKeys<S['include']>]:
        P extends 'address' ? AddressGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'images' ? Array < ImageOrganizationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'memberships' ? Array < organizationMembershipGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'products' ? Array < ProductGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'vendor' ? VendorGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'subdomain' ? SubDomainGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'siteSetting' ? SiteSettingGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? OrganizationCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'address' ? AddressGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'images' ? Array < ImageOrganizationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'memberships' ? Array < organizationMembershipGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'products' ? Array < ProductGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'vendor' ? VendorGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'subdomain' ? SubDomainGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'siteSetting' ? SiteSettingGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? OrganizationCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Organization ? Organization[P] : never
  } 
    : Organization
  : Organization


  type OrganizationCountArgs = Merge<
    Omit<OrganizationFindManyArgs, 'select' | 'include'> & {
      select?: OrganizationCountAggregateInputType | true
    }
  >

  export interface OrganizationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrganizationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrganizationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Organization'> extends True ? CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>> : CheckSelect<T, Prisma__OrganizationClient<Organization | null, null>, Prisma__OrganizationClient<OrganizationGetPayload<T> | null, null>>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrganizationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrganizationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Organization'> extends True ? CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>> : CheckSelect<T, Prisma__OrganizationClient<Organization | null, null>, Prisma__OrganizationClient<OrganizationGetPayload<T> | null, null>>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrganizationFindManyArgs>(
      args?: SelectSubset<T, OrganizationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Organization>>, PrismaPromise<Array<OrganizationGetPayload<T>>>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
    **/
    create<T extends OrganizationCreateArgs>(
      args: SelectSubset<T, OrganizationCreateArgs>
    ): CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>>

    /**
     * Create many Organizations.
     *     @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     *     @example
     *     // Create many Organizations
     *     const organization = await prisma.organization.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrganizationCreateManyArgs>(
      args?: SelectSubset<T, OrganizationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
    **/
    delete<T extends OrganizationDeleteArgs>(
      args: SelectSubset<T, OrganizationDeleteArgs>
    ): CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrganizationUpdateArgs>(
      args: SelectSubset<T, OrganizationUpdateArgs>
    ): CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrganizationDeleteManyArgs>(
      args?: SelectSubset<T, OrganizationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrganizationUpdateManyArgs>(
      args: SelectSubset<T, OrganizationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
    **/
    upsert<T extends OrganizationUpsertArgs>(
      args: SelectSubset<T, OrganizationUpsertArgs>
    ): CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>>

    /**
     * Find one Organization that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrganizationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>>

    /**
     * Find the first Organization that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>>

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrganizationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    address<T extends AddressArgs = {}>(args?: Subset<T, AddressArgs>): CheckSelect<T, Prisma__AddressClient<Address | Null>, Prisma__AddressClient<AddressGetPayload<T> | Null>>;

    images<T extends ImageOrganizationFindManyArgs = {}>(args?: Subset<T, ImageOrganizationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ImageOrganization>| Null>, PrismaPromise<Array<ImageOrganizationGetPayload<T>>| Null>>;

    memberships<T extends organizationMembershipFindManyArgs = {}>(args?: Subset<T, organizationMembershipFindManyArgs>): CheckSelect<T, PrismaPromise<Array<organizationMembership>| Null>, PrismaPromise<Array<organizationMembershipGetPayload<T>>| Null>>;

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>| Null>, PrismaPromise<Array<ProductGetPayload<T>>| Null>>;

    vendor<T extends VendorArgs = {}>(args?: Subset<T, VendorArgs>): CheckSelect<T, Prisma__VendorClient<Vendor | Null>, Prisma__VendorClient<VendorGetPayload<T> | Null>>;

    subdomain<T extends SubDomainArgs = {}>(args?: Subset<T, SubDomainArgs>): CheckSelect<T, Prisma__SubDomainClient<SubDomain | Null>, Prisma__SubDomainClient<SubDomainGetPayload<T> | Null>>;

    siteSetting<T extends SiteSettingArgs = {}>(args?: Subset<T, SiteSettingArgs>): CheckSelect<T, Prisma__SiteSettingClient<SiteSetting | Null>, Prisma__SiteSettingClient<SiteSettingGetPayload<T> | Null>>;

    orders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>| Null>, PrismaPromise<Array<OrderGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Organization base type for findUnique actions
   */
  export type OrganizationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
    /**
     * Filter, which Organization to fetch.
     * 
    **/
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization: findUnique
   */
  export interface OrganizationFindUniqueArgs extends OrganizationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Organization base type for findFirst actions
   */
  export type OrganizationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
    /**
     * Filter, which Organization to fetch.
     * 
    **/
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     * 
    **/
    orderBy?: Enumerable<OrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     * 
    **/
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     * 
    **/
    distinct?: Enumerable<OrganizationScalarFieldEnum>
  }

  /**
   * Organization: findFirst
   */
  export interface OrganizationFindFirstArgs extends OrganizationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
    /**
     * Filter, which Organizations to fetch.
     * 
    **/
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     * 
    **/
    orderBy?: Enumerable<OrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     * 
    **/
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrganizationScalarFieldEnum>
  }


  /**
   * Organization create
   */
  export type OrganizationCreateArgs = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
    /**
     * The data needed to create a Organization.
     * 
    **/
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }


  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs = {
    /**
     * The data used to create many Organizations.
     * 
    **/
    data: Enumerable<OrganizationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Organization update
   */
  export type OrganizationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
    /**
     * The data needed to update a Organization.
     * 
    **/
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     * 
    **/
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs = {
    /**
     * The data used to update Organizations.
     * 
    **/
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     * 
    **/
    where?: OrganizationWhereInput
  }


  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
    /**
     * The filter to search for the Organization to update in case it exists.
     * 
    **/
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     * 
    **/
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }


  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
    /**
     * Filter which Organization to delete.
     * 
    **/
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs = {
    /**
     * Filter which Organizations to delete
     * 
    **/
    where?: OrganizationWhereInput
  }


  /**
   * Organization: findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs = OrganizationFindUniqueArgsBase
      

  /**
   * Organization: findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs = OrganizationFindFirstArgsBase
      

  /**
   * Organization without action
   */
  export type OrganizationArgs = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
  }



  /**
   * Model organizationMembership
   */


  export type AggregateOrganizationMembership = {
    _count: OrganizationMembershipCountAggregateOutputType | null
    _min: OrganizationMembershipMinAggregateOutputType | null
    _max: OrganizationMembershipMaxAggregateOutputType | null
  }

  export type OrganizationMembershipMinAggregateOutputType = {
    organizationId: string | null
    membershipId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMembershipMaxAggregateOutputType = {
    organizationId: string | null
    membershipId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMembershipCountAggregateOutputType = {
    organizationId: number
    membershipId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMembershipMinAggregateInputType = {
    organizationId?: true
    membershipId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMembershipMaxAggregateInputType = {
    organizationId?: true
    membershipId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMembershipCountAggregateInputType = {
    organizationId?: true
    membershipId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationMembershipAggregateArgs = {
    /**
     * Filter which organizationMembership to aggregate.
     * 
    **/
    where?: organizationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizationMemberships to fetch.
     * 
    **/
    orderBy?: Enumerable<organizationMembershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: organizationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizationMemberships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizationMemberships.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organizationMemberships
    **/
    _count?: true | OrganizationMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMembershipMaxAggregateInputType
  }

  export type GetOrganizationMembershipAggregateType<T extends OrganizationMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationMembership[P]>
      : GetScalarType<T[P], AggregateOrganizationMembership[P]>
  }




  export type OrganizationMembershipGroupByArgs = {
    where?: organizationMembershipWhereInput
    orderBy?: Enumerable<organizationMembershipOrderByWithAggregationInput>
    by: Array<OrganizationMembershipScalarFieldEnum>
    having?: organizationMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationMembershipCountAggregateInputType | true
    _min?: OrganizationMembershipMinAggregateInputType
    _max?: OrganizationMembershipMaxAggregateInputType
  }


  export type OrganizationMembershipGroupByOutputType = {
    organizationId: string
    membershipId: string
    createdAt: Date
    updatedAt: Date
    _count: OrganizationMembershipCountAggregateOutputType | null
    _min: OrganizationMembershipMinAggregateOutputType | null
    _max: OrganizationMembershipMaxAggregateOutputType | null
  }

  type GetOrganizationMembershipGroupByPayload<T extends OrganizationMembershipGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrganizationMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationMembershipGroupByOutputType[P]>
        }
      >
    >


  export type organizationMembershipSelect = {
    organizationId?: boolean
    organization?: boolean | OrganizationArgs
    membershipId?: boolean
    membership?: boolean | MembershipArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type organizationMembershipInclude = {
    organization?: boolean | OrganizationArgs
    membership?: boolean | MembershipArgs
  }

  export type organizationMembershipGetPayload<
    S extends boolean | null | undefined | organizationMembershipArgs,
    U = keyof S
      > = S extends true
        ? organizationMembership
    : S extends undefined
    ? never
    : S extends organizationMembershipArgs | organizationMembershipFindManyArgs
    ?'include' extends U
    ? organizationMembership  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organization' ? OrganizationGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'membership' ? MembershipGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organization' ? OrganizationGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'membership' ? MembershipGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof organizationMembership ? organizationMembership[P] : never
  } 
    : organizationMembership
  : organizationMembership


  type organizationMembershipCountArgs = Merge<
    Omit<organizationMembershipFindManyArgs, 'select' | 'include'> & {
      select?: OrganizationMembershipCountAggregateInputType | true
    }
  >

  export interface organizationMembershipDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OrganizationMembership that matches the filter.
     * @param {organizationMembershipFindUniqueArgs} args - Arguments to find a OrganizationMembership
     * @example
     * // Get one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organizationMembershipFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, organizationMembershipFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'organizationMembership'> extends True ? CheckSelect<T, Prisma__organizationMembershipClient<organizationMembership>, Prisma__organizationMembershipClient<organizationMembershipGetPayload<T>>> : CheckSelect<T, Prisma__organizationMembershipClient<organizationMembership | null, null>, Prisma__organizationMembershipClient<organizationMembershipGetPayload<T> | null, null>>

    /**
     * Find the first OrganizationMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationMembershipFindFirstArgs} args - Arguments to find a OrganizationMembership
     * @example
     * // Get one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organizationMembershipFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, organizationMembershipFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'organizationMembership'> extends True ? CheckSelect<T, Prisma__organizationMembershipClient<organizationMembership>, Prisma__organizationMembershipClient<organizationMembershipGetPayload<T>>> : CheckSelect<T, Prisma__organizationMembershipClient<organizationMembership | null, null>, Prisma__organizationMembershipClient<organizationMembershipGetPayload<T> | null, null>>

    /**
     * Find zero or more OrganizationMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationMembershipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationMemberships
     * const organizationMemberships = await prisma.organizationMembership.findMany()
     * 
     * // Get first 10 OrganizationMemberships
     * const organizationMemberships = await prisma.organizationMembership.findMany({ take: 10 })
     * 
     * // Only select the `organizationId`
     * const organizationMembershipWithOrganizationIdOnly = await prisma.organizationMembership.findMany({ select: { organizationId: true } })
     * 
    **/
    findMany<T extends organizationMembershipFindManyArgs>(
      args?: SelectSubset<T, organizationMembershipFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<organizationMembership>>, PrismaPromise<Array<organizationMembershipGetPayload<T>>>>

    /**
     * Create a OrganizationMembership.
     * @param {organizationMembershipCreateArgs} args - Arguments to create a OrganizationMembership.
     * @example
     * // Create one OrganizationMembership
     * const OrganizationMembership = await prisma.organizationMembership.create({
     *   data: {
     *     // ... data to create a OrganizationMembership
     *   }
     * })
     * 
    **/
    create<T extends organizationMembershipCreateArgs>(
      args: SelectSubset<T, organizationMembershipCreateArgs>
    ): CheckSelect<T, Prisma__organizationMembershipClient<organizationMembership>, Prisma__organizationMembershipClient<organizationMembershipGetPayload<T>>>

    /**
     * Create many OrganizationMemberships.
     *     @param {organizationMembershipCreateManyArgs} args - Arguments to create many OrganizationMemberships.
     *     @example
     *     // Create many OrganizationMemberships
     *     const organizationMembership = await prisma.organizationMembership.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organizationMembershipCreateManyArgs>(
      args?: SelectSubset<T, organizationMembershipCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OrganizationMembership.
     * @param {organizationMembershipDeleteArgs} args - Arguments to delete one OrganizationMembership.
     * @example
     * // Delete one OrganizationMembership
     * const OrganizationMembership = await prisma.organizationMembership.delete({
     *   where: {
     *     // ... filter to delete one OrganizationMembership
     *   }
     * })
     * 
    **/
    delete<T extends organizationMembershipDeleteArgs>(
      args: SelectSubset<T, organizationMembershipDeleteArgs>
    ): CheckSelect<T, Prisma__organizationMembershipClient<organizationMembership>, Prisma__organizationMembershipClient<organizationMembershipGetPayload<T>>>

    /**
     * Update one OrganizationMembership.
     * @param {organizationMembershipUpdateArgs} args - Arguments to update one OrganizationMembership.
     * @example
     * // Update one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organizationMembershipUpdateArgs>(
      args: SelectSubset<T, organizationMembershipUpdateArgs>
    ): CheckSelect<T, Prisma__organizationMembershipClient<organizationMembership>, Prisma__organizationMembershipClient<organizationMembershipGetPayload<T>>>

    /**
     * Delete zero or more OrganizationMemberships.
     * @param {organizationMembershipDeleteManyArgs} args - Arguments to filter OrganizationMemberships to delete.
     * @example
     * // Delete a few OrganizationMemberships
     * const { count } = await prisma.organizationMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organizationMembershipDeleteManyArgs>(
      args?: SelectSubset<T, organizationMembershipDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationMemberships
     * const organizationMembership = await prisma.organizationMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organizationMembershipUpdateManyArgs>(
      args: SelectSubset<T, organizationMembershipUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganizationMembership.
     * @param {organizationMembershipUpsertArgs} args - Arguments to update or create a OrganizationMembership.
     * @example
     * // Update or create a OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.upsert({
     *   create: {
     *     // ... data to create a OrganizationMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationMembership we want to update
     *   }
     * })
    **/
    upsert<T extends organizationMembershipUpsertArgs>(
      args: SelectSubset<T, organizationMembershipUpsertArgs>
    ): CheckSelect<T, Prisma__organizationMembershipClient<organizationMembership>, Prisma__organizationMembershipClient<organizationMembershipGetPayload<T>>>

    /**
     * Find one OrganizationMembership that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {organizationMembershipFindUniqueOrThrowArgs} args - Arguments to find a OrganizationMembership
     * @example
     * // Get one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organizationMembershipFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, organizationMembershipFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__organizationMembershipClient<organizationMembership>, Prisma__organizationMembershipClient<organizationMembershipGetPayload<T>>>

    /**
     * Find the first OrganizationMembership that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationMembershipFindFirstOrThrowArgs} args - Arguments to find a OrganizationMembership
     * @example
     * // Get one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organizationMembershipFindFirstOrThrowArgs>(
      args?: SelectSubset<T, organizationMembershipFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__organizationMembershipClient<organizationMembership>, Prisma__organizationMembershipClient<organizationMembershipGetPayload<T>>>

    /**
     * Count the number of OrganizationMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationMembershipCountArgs} args - Arguments to filter OrganizationMemberships to count.
     * @example
     * // Count the number of OrganizationMemberships
     * const count = await prisma.organizationMembership.count({
     *   where: {
     *     // ... the filter for the OrganizationMemberships we want to count
     *   }
     * })
    **/
    count<T extends organizationMembershipCountArgs>(
      args?: Subset<T, organizationMembershipCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationMembershipAggregateArgs>(args: Subset<T, OrganizationMembershipAggregateArgs>): PrismaPromise<GetOrganizationMembershipAggregateType<T>>

    /**
     * Group by OrganizationMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationMembershipGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationMembershipGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for organizationMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__organizationMembershipClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organization<T extends OrganizationArgs = {}>(args?: Subset<T, OrganizationArgs>): CheckSelect<T, Prisma__OrganizationClient<Organization | Null>, Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>>;

    membership<T extends MembershipArgs = {}>(args?: Subset<T, MembershipArgs>): CheckSelect<T, Prisma__MembershipClient<Membership | Null>, Prisma__MembershipClient<MembershipGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * organizationMembership base type for findUnique actions
   */
  export type organizationMembershipFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the organizationMembership
     * 
    **/
    select?: organizationMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organizationMembershipInclude | null
    /**
     * Filter, which organizationMembership to fetch.
     * 
    **/
    where: organizationMembershipWhereUniqueInput
  }

  /**
   * organizationMembership: findUnique
   */
  export interface organizationMembershipFindUniqueArgs extends organizationMembershipFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organizationMembership base type for findFirst actions
   */
  export type organizationMembershipFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the organizationMembership
     * 
    **/
    select?: organizationMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organizationMembershipInclude | null
    /**
     * Filter, which organizationMembership to fetch.
     * 
    **/
    where?: organizationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizationMemberships to fetch.
     * 
    **/
    orderBy?: Enumerable<organizationMembershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizationMemberships.
     * 
    **/
    cursor?: organizationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizationMemberships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizationMemberships.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizationMemberships.
     * 
    **/
    distinct?: Enumerable<OrganizationMembershipScalarFieldEnum>
  }

  /**
   * organizationMembership: findFirst
   */
  export interface organizationMembershipFindFirstArgs extends organizationMembershipFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organizationMembership findMany
   */
  export type organizationMembershipFindManyArgs = {
    /**
     * Select specific fields to fetch from the organizationMembership
     * 
    **/
    select?: organizationMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organizationMembershipInclude | null
    /**
     * Filter, which organizationMemberships to fetch.
     * 
    **/
    where?: organizationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizationMemberships to fetch.
     * 
    **/
    orderBy?: Enumerable<organizationMembershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organizationMemberships.
     * 
    **/
    cursor?: organizationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizationMemberships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizationMemberships.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrganizationMembershipScalarFieldEnum>
  }


  /**
   * organizationMembership create
   */
  export type organizationMembershipCreateArgs = {
    /**
     * Select specific fields to fetch from the organizationMembership
     * 
    **/
    select?: organizationMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organizationMembershipInclude | null
    /**
     * The data needed to create a organizationMembership.
     * 
    **/
    data: XOR<organizationMembershipCreateInput, organizationMembershipUncheckedCreateInput>
  }


  /**
   * organizationMembership createMany
   */
  export type organizationMembershipCreateManyArgs = {
    /**
     * The data used to create many organizationMemberships.
     * 
    **/
    data: Enumerable<organizationMembershipCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * organizationMembership update
   */
  export type organizationMembershipUpdateArgs = {
    /**
     * Select specific fields to fetch from the organizationMembership
     * 
    **/
    select?: organizationMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organizationMembershipInclude | null
    /**
     * The data needed to update a organizationMembership.
     * 
    **/
    data: XOR<organizationMembershipUpdateInput, organizationMembershipUncheckedUpdateInput>
    /**
     * Choose, which organizationMembership to update.
     * 
    **/
    where: organizationMembershipWhereUniqueInput
  }


  /**
   * organizationMembership updateMany
   */
  export type organizationMembershipUpdateManyArgs = {
    /**
     * The data used to update organizationMemberships.
     * 
    **/
    data: XOR<organizationMembershipUpdateManyMutationInput, organizationMembershipUncheckedUpdateManyInput>
    /**
     * Filter which organizationMemberships to update
     * 
    **/
    where?: organizationMembershipWhereInput
  }


  /**
   * organizationMembership upsert
   */
  export type organizationMembershipUpsertArgs = {
    /**
     * Select specific fields to fetch from the organizationMembership
     * 
    **/
    select?: organizationMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organizationMembershipInclude | null
    /**
     * The filter to search for the organizationMembership to update in case it exists.
     * 
    **/
    where: organizationMembershipWhereUniqueInput
    /**
     * In case the organizationMembership found by the `where` argument doesn't exist, create a new organizationMembership with this data.
     * 
    **/
    create: XOR<organizationMembershipCreateInput, organizationMembershipUncheckedCreateInput>
    /**
     * In case the organizationMembership was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<organizationMembershipUpdateInput, organizationMembershipUncheckedUpdateInput>
  }


  /**
   * organizationMembership delete
   */
  export type organizationMembershipDeleteArgs = {
    /**
     * Select specific fields to fetch from the organizationMembership
     * 
    **/
    select?: organizationMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organizationMembershipInclude | null
    /**
     * Filter which organizationMembership to delete.
     * 
    **/
    where: organizationMembershipWhereUniqueInput
  }


  /**
   * organizationMembership deleteMany
   */
  export type organizationMembershipDeleteManyArgs = {
    /**
     * Filter which organizationMemberships to delete
     * 
    **/
    where?: organizationMembershipWhereInput
  }


  /**
   * organizationMembership: findUniqueOrThrow
   */
  export type organizationMembershipFindUniqueOrThrowArgs = organizationMembershipFindUniqueArgsBase
      

  /**
   * organizationMembership: findFirstOrThrow
   */
  export type organizationMembershipFindFirstOrThrowArgs = organizationMembershipFindFirstArgsBase
      

  /**
   * organizationMembership without action
   */
  export type organizationMembershipArgs = {
    /**
     * Select specific fields to fetch from the organizationMembership
     * 
    **/
    select?: organizationMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organizationMembershipInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    size: number | null
    basePrice: number | null
    discount: number | null
    quantity: number | null
    stock: number | null
    rating: number | null
  }

  export type ProductSumAggregateOutputType = {
    size: number | null
    basePrice: number | null
    discount: number | null
    quantity: number | null
    stock: number | null
    rating: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    features: string | null
    unit: Unit | null
    size: number | null
    basePrice: number | null
    currency: Currency | null
    discount: number | null
    quantity: number | null
    stock: number | null
    organizationId: string | null
    rating: number | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    features: string | null
    unit: Unit | null
    size: number | null
    basePrice: number | null
    currency: Currency | null
    discount: number | null
    quantity: number | null
    stock: number | null
    organizationId: string | null
    rating: number | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    features: number
    unit: number
    size: number
    basePrice: number
    currency: number
    discount: number
    quantity: number
    stock: number
    organizationId: number
    rating: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    size?: true
    basePrice?: true
    discount?: true
    quantity?: true
    stock?: true
    rating?: true
  }

  export type ProductSumAggregateInputType = {
    size?: true
    basePrice?: true
    discount?: true
    quantity?: true
    stock?: true
    rating?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    features?: true
    unit?: true
    size?: true
    basePrice?: true
    currency?: true
    discount?: true
    quantity?: true
    stock?: true
    organizationId?: true
    rating?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    features?: true
    unit?: true
    size?: true
    basePrice?: true
    currency?: true
    discount?: true
    quantity?: true
    stock?: true
    organizationId?: true
    rating?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    features?: true
    unit?: true
    size?: true
    basePrice?: true
    currency?: true
    discount?: true
    quantity?: true
    stock?: true
    organizationId?: true
    rating?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: Array<ProductScalarFieldEnum>
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: string
    name: string
    description: string | null
    features: string | null
    unit: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    organizationId: string
    rating: number | null
    tags: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    features?: boolean
    categories?: boolean | CategoryFindManyArgs
    unit?: boolean
    size?: boolean
    basePrice?: boolean
    currency?: boolean
    discount?: boolean
    quantity?: boolean
    stock?: boolean
    images?: boolean | ImageProductFindManyArgs
    organizationId?: boolean
    organization?: boolean | OrganizationArgs
    orders?: boolean | OrderFindManyArgs
    reviews?: boolean | ReviewFindManyArgs
    rating?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductInclude = {
    categories?: boolean | CategoryFindManyArgs
    images?: boolean | ImageProductFindManyArgs
    organization?: boolean | OrganizationArgs
    orders?: boolean | OrderFindManyArgs
    reviews?: boolean | ReviewFindManyArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductGetPayload<
    S extends boolean | null | undefined | ProductArgs,
    U = keyof S
      > = S extends true
        ? Product
    : S extends undefined
    ? never
    : S extends ProductArgs | ProductFindManyArgs
    ?'include' extends U
    ? Product  & {
    [P in TrueKeys<S['include']>]:
        P extends 'categories' ? Array < CategoryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'images' ? Array < ImageProductGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'organization' ? OrganizationGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'reviews' ? Array < ReviewGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'categories' ? Array < CategoryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'images' ? Array < ImageProductGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'organization' ? OrganizationGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'reviews' ? Array < ReviewGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Product ? Product[P] : never
  } 
    : Product
  : Product


  type ProductCountArgs = Merge<
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface ProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null, null>, Prisma__ProductClient<ProductGetPayload<T> | null, null>>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null, null>, Prisma__ProductClient<ProductGetPayload<T> | null, null>>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Find one Product that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Find the first Product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    categories<T extends CategoryFindManyArgs = {}>(args?: Subset<T, CategoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Category>| Null>, PrismaPromise<Array<CategoryGetPayload<T>>| Null>>;

    images<T extends ImageProductFindManyArgs = {}>(args?: Subset<T, ImageProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ImageProduct>| Null>, PrismaPromise<Array<ImageProductGetPayload<T>>| Null>>;

    organization<T extends OrganizationArgs = {}>(args?: Subset<T, OrganizationArgs>): CheckSelect<T, Prisma__OrganizationClient<Organization | Null>, Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>>;

    orders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>| Null>, PrismaPromise<Array<OrderGetPayload<T>>| Null>>;

    reviews<T extends ReviewFindManyArgs = {}>(args?: Subset<T, ReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Review>| Null>, PrismaPromise<Array<ReviewGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Product base type for findUnique actions
   */
  export type ProductFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }

  /**
   * Product: findUnique
   */
  export interface ProductFindUniqueArgs extends ProductFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product base type for findFirst actions
   */
  export type ProductFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }

  /**
   * Product: findFirst
   */
  export interface ProductFindFirstArgs extends ProductFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     * 
    **/
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    /**
     * The data used to create many Products.
     * 
    **/
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     * 
    **/
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    /**
     * The data used to update Products.
     * 
    **/
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     * 
    **/
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     * 
    **/
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    /**
     * Filter which Products to delete
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product: findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs = ProductFindUniqueArgsBase
      

  /**
   * Product: findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs = ProductFindFirstArgsBase
      

  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
  }



  /**
   * Model Category
   */


  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which Category to aggregate.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs = {
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithAggregationInput>
    by: Array<CategoryScalarFieldEnum>
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    icon: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    icon?: boolean
    products?: boolean | ProductFindManyArgs
    categoryLists?: boolean | CategoryListFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | CategoryCountOutputTypeArgs
  }

  export type CategoryInclude = {
    products?: boolean | ProductFindManyArgs
    categoryLists?: boolean | CategoryListFindManyArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }

  export type CategoryGetPayload<
    S extends boolean | null | undefined | CategoryArgs,
    U = keyof S
      > = S extends true
        ? Category
    : S extends undefined
    ? never
    : S extends CategoryArgs | CategoryFindManyArgs
    ?'include' extends U
    ? Category  & {
    [P in TrueKeys<S['include']>]:
        P extends 'products' ? Array < ProductGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'categoryLists' ? Array < CategoryListGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'products' ? Array < ProductGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'categoryLists' ? Array < CategoryListGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Category ? Category[P] : never
  } 
    : Category
  : Category


  type CategoryCountArgs = Merge<
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }
  >

  export interface CategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Category'> extends True ? CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>> : CheckSelect<T, Prisma__CategoryClient<Category | null, null>, Prisma__CategoryClient<CategoryGetPayload<T> | null, null>>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Category'> extends True ? CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>> : CheckSelect<T, Prisma__CategoryClient<Category | null, null>, Prisma__CategoryClient<CategoryGetPayload<T> | null, null>>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Category>>, PrismaPromise<Array<CategoryGetPayload<T>>>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Find one Category that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Find the first Category that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>| Null>, PrismaPromise<Array<ProductGetPayload<T>>| Null>>;

    categoryLists<T extends CategoryListFindManyArgs = {}>(args?: Subset<T, CategoryListFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CategoryList>| Null>, PrismaPromise<Array<CategoryListGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Category base type for findUnique actions
   */
  export type CategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     * 
    **/
    where: CategoryWhereUniqueInput
  }

  /**
   * Category: findUnique
   */
  export interface CategoryFindUniqueArgs extends CategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category base type for findFirst actions
   */
  export type CategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     * 
    **/
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }

  /**
   * Category: findFirst
   */
  export interface CategoryFindFirstArgs extends CategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter, which Categories to fetch.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The data needed to create a Category.
     * 
    **/
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs = {
    /**
     * The data used to create many Categories.
     * 
    **/
    data: Enumerable<CategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The data needed to update a Category.
     * 
    **/
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs = {
    /**
     * The data used to update Categories.
     * 
    **/
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     * 
    **/
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The filter to search for the Category to update in case it exists.
     * 
    **/
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     * 
    **/
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter which Category to delete.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs = {
    /**
     * Filter which Categories to delete
     * 
    **/
    where?: CategoryWhereInput
  }


  /**
   * Category: findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs = CategoryFindUniqueArgsBase
      

  /**
   * Category: findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs = CategoryFindFirstArgsBase
      

  /**
   * Category without action
   */
  export type CategoryArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
  }



  /**
   * Model CategoryList
   */


  export type AggregateCategoryList = {
    _count: CategoryListCountAggregateOutputType | null
    _min: CategoryListMinAggregateOutputType | null
    _max: CategoryListMaxAggregateOutputType | null
  }

  export type CategoryListMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryListMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryListCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryListMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryListMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryListCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryListAggregateArgs = {
    /**
     * Filter which CategoryList to aggregate.
     * 
    **/
    where?: CategoryListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryLists to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CategoryListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryLists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoryLists
    **/
    _count?: true | CategoryListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryListMaxAggregateInputType
  }

  export type GetCategoryListAggregateType<T extends CategoryListAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryList[P]>
      : GetScalarType<T[P], AggregateCategoryList[P]>
  }




  export type CategoryListGroupByArgs = {
    where?: CategoryListWhereInput
    orderBy?: Enumerable<CategoryListOrderByWithAggregationInput>
    by: Array<CategoryListScalarFieldEnum>
    having?: CategoryListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryListCountAggregateInputType | true
    _min?: CategoryListMinAggregateInputType
    _max?: CategoryListMaxAggregateInputType
  }


  export type CategoryListGroupByOutputType = {
    id: string
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryListCountAggregateOutputType | null
    _min: CategoryListMinAggregateOutputType | null
    _max: CategoryListMaxAggregateOutputType | null
  }

  type GetCategoryListGroupByPayload<T extends CategoryListGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CategoryListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryListGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryListGroupByOutputType[P]>
        }
      >
    >


  export type CategoryListSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    categories?: boolean | CategoryFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | CategoryListCountOutputTypeArgs
  }

  export type CategoryListInclude = {
    categories?: boolean | CategoryFindManyArgs
    _count?: boolean | CategoryListCountOutputTypeArgs
  }

  export type CategoryListGetPayload<
    S extends boolean | null | undefined | CategoryListArgs,
    U = keyof S
      > = S extends true
        ? CategoryList
    : S extends undefined
    ? never
    : S extends CategoryListArgs | CategoryListFindManyArgs
    ?'include' extends U
    ? CategoryList  & {
    [P in TrueKeys<S['include']>]:
        P extends 'categories' ? Array < CategoryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CategoryListCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'categories' ? Array < CategoryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CategoryListCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof CategoryList ? CategoryList[P] : never
  } 
    : CategoryList
  : CategoryList


  type CategoryListCountArgs = Merge<
    Omit<CategoryListFindManyArgs, 'select' | 'include'> & {
      select?: CategoryListCountAggregateInputType | true
    }
  >

  export interface CategoryListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CategoryList that matches the filter.
     * @param {CategoryListFindUniqueArgs} args - Arguments to find a CategoryList
     * @example
     * // Get one CategoryList
     * const categoryList = await prisma.categoryList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryListFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryListFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CategoryList'> extends True ? CheckSelect<T, Prisma__CategoryListClient<CategoryList>, Prisma__CategoryListClient<CategoryListGetPayload<T>>> : CheckSelect<T, Prisma__CategoryListClient<CategoryList | null, null>, Prisma__CategoryListClient<CategoryListGetPayload<T> | null, null>>

    /**
     * Find the first CategoryList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListFindFirstArgs} args - Arguments to find a CategoryList
     * @example
     * // Get one CategoryList
     * const categoryList = await prisma.categoryList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryListFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryListFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CategoryList'> extends True ? CheckSelect<T, Prisma__CategoryListClient<CategoryList>, Prisma__CategoryListClient<CategoryListGetPayload<T>>> : CheckSelect<T, Prisma__CategoryListClient<CategoryList | null, null>, Prisma__CategoryListClient<CategoryListGetPayload<T> | null, null>>

    /**
     * Find zero or more CategoryLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoryLists
     * const categoryLists = await prisma.categoryList.findMany()
     * 
     * // Get first 10 CategoryLists
     * const categoryLists = await prisma.categoryList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryListWithIdOnly = await prisma.categoryList.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryListFindManyArgs>(
      args?: SelectSubset<T, CategoryListFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CategoryList>>, PrismaPromise<Array<CategoryListGetPayload<T>>>>

    /**
     * Create a CategoryList.
     * @param {CategoryListCreateArgs} args - Arguments to create a CategoryList.
     * @example
     * // Create one CategoryList
     * const CategoryList = await prisma.categoryList.create({
     *   data: {
     *     // ... data to create a CategoryList
     *   }
     * })
     * 
    **/
    create<T extends CategoryListCreateArgs>(
      args: SelectSubset<T, CategoryListCreateArgs>
    ): CheckSelect<T, Prisma__CategoryListClient<CategoryList>, Prisma__CategoryListClient<CategoryListGetPayload<T>>>

    /**
     * Create many CategoryLists.
     *     @param {CategoryListCreateManyArgs} args - Arguments to create many CategoryLists.
     *     @example
     *     // Create many CategoryLists
     *     const categoryList = await prisma.categoryList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryListCreateManyArgs>(
      args?: SelectSubset<T, CategoryListCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CategoryList.
     * @param {CategoryListDeleteArgs} args - Arguments to delete one CategoryList.
     * @example
     * // Delete one CategoryList
     * const CategoryList = await prisma.categoryList.delete({
     *   where: {
     *     // ... filter to delete one CategoryList
     *   }
     * })
     * 
    **/
    delete<T extends CategoryListDeleteArgs>(
      args: SelectSubset<T, CategoryListDeleteArgs>
    ): CheckSelect<T, Prisma__CategoryListClient<CategoryList>, Prisma__CategoryListClient<CategoryListGetPayload<T>>>

    /**
     * Update one CategoryList.
     * @param {CategoryListUpdateArgs} args - Arguments to update one CategoryList.
     * @example
     * // Update one CategoryList
     * const categoryList = await prisma.categoryList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryListUpdateArgs>(
      args: SelectSubset<T, CategoryListUpdateArgs>
    ): CheckSelect<T, Prisma__CategoryListClient<CategoryList>, Prisma__CategoryListClient<CategoryListGetPayload<T>>>

    /**
     * Delete zero or more CategoryLists.
     * @param {CategoryListDeleteManyArgs} args - Arguments to filter CategoryLists to delete.
     * @example
     * // Delete a few CategoryLists
     * const { count } = await prisma.categoryList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryListDeleteManyArgs>(
      args?: SelectSubset<T, CategoryListDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoryLists
     * const categoryList = await prisma.categoryList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryListUpdateManyArgs>(
      args: SelectSubset<T, CategoryListUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CategoryList.
     * @param {CategoryListUpsertArgs} args - Arguments to update or create a CategoryList.
     * @example
     * // Update or create a CategoryList
     * const categoryList = await prisma.categoryList.upsert({
     *   create: {
     *     // ... data to create a CategoryList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoryList we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryListUpsertArgs>(
      args: SelectSubset<T, CategoryListUpsertArgs>
    ): CheckSelect<T, Prisma__CategoryListClient<CategoryList>, Prisma__CategoryListClient<CategoryListGetPayload<T>>>

    /**
     * Find one CategoryList that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CategoryListFindUniqueOrThrowArgs} args - Arguments to find a CategoryList
     * @example
     * // Get one CategoryList
     * const categoryList = await prisma.categoryList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryListFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CategoryListFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CategoryListClient<CategoryList>, Prisma__CategoryListClient<CategoryListGetPayload<T>>>

    /**
     * Find the first CategoryList that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListFindFirstOrThrowArgs} args - Arguments to find a CategoryList
     * @example
     * // Get one CategoryList
     * const categoryList = await prisma.categoryList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryListFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CategoryListFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CategoryListClient<CategoryList>, Prisma__CategoryListClient<CategoryListGetPayload<T>>>

    /**
     * Count the number of CategoryLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListCountArgs} args - Arguments to filter CategoryLists to count.
     * @example
     * // Count the number of CategoryLists
     * const count = await prisma.categoryList.count({
     *   where: {
     *     // ... the filter for the CategoryLists we want to count
     *   }
     * })
    **/
    count<T extends CategoryListCountArgs>(
      args?: Subset<T, CategoryListCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoryList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryListAggregateArgs>(args: Subset<T, CategoryListAggregateArgs>): PrismaPromise<GetCategoryListAggregateType<T>>

    /**
     * Group by CategoryList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryListGroupByArgs['orderBy'] }
        : { orderBy?: CategoryListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryListGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoryList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryListClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    categories<T extends CategoryFindManyArgs = {}>(args?: Subset<T, CategoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Category>| Null>, PrismaPromise<Array<CategoryGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CategoryList base type for findUnique actions
   */
  export type CategoryListFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CategoryList
     * 
    **/
    select?: CategoryListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryListInclude | null
    /**
     * Filter, which CategoryList to fetch.
     * 
    **/
    where: CategoryListWhereUniqueInput
  }

  /**
   * CategoryList: findUnique
   */
  export interface CategoryListFindUniqueArgs extends CategoryListFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CategoryList base type for findFirst actions
   */
  export type CategoryListFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CategoryList
     * 
    **/
    select?: CategoryListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryListInclude | null
    /**
     * Filter, which CategoryList to fetch.
     * 
    **/
    where?: CategoryListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryLists to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryLists.
     * 
    **/
    cursor?: CategoryListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryLists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryLists.
     * 
    **/
    distinct?: Enumerable<CategoryListScalarFieldEnum>
  }

  /**
   * CategoryList: findFirst
   */
  export interface CategoryListFindFirstArgs extends CategoryListFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CategoryList findMany
   */
  export type CategoryListFindManyArgs = {
    /**
     * Select specific fields to fetch from the CategoryList
     * 
    **/
    select?: CategoryListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryListInclude | null
    /**
     * Filter, which CategoryLists to fetch.
     * 
    **/
    where?: CategoryListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryLists to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoryLists.
     * 
    **/
    cursor?: CategoryListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryLists.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoryListScalarFieldEnum>
  }


  /**
   * CategoryList create
   */
  export type CategoryListCreateArgs = {
    /**
     * Select specific fields to fetch from the CategoryList
     * 
    **/
    select?: CategoryListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryListInclude | null
    /**
     * The data needed to create a CategoryList.
     * 
    **/
    data: XOR<CategoryListCreateInput, CategoryListUncheckedCreateInput>
  }


  /**
   * CategoryList createMany
   */
  export type CategoryListCreateManyArgs = {
    /**
     * The data used to create many CategoryLists.
     * 
    **/
    data: Enumerable<CategoryListCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CategoryList update
   */
  export type CategoryListUpdateArgs = {
    /**
     * Select specific fields to fetch from the CategoryList
     * 
    **/
    select?: CategoryListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryListInclude | null
    /**
     * The data needed to update a CategoryList.
     * 
    **/
    data: XOR<CategoryListUpdateInput, CategoryListUncheckedUpdateInput>
    /**
     * Choose, which CategoryList to update.
     * 
    **/
    where: CategoryListWhereUniqueInput
  }


  /**
   * CategoryList updateMany
   */
  export type CategoryListUpdateManyArgs = {
    /**
     * The data used to update CategoryLists.
     * 
    **/
    data: XOR<CategoryListUpdateManyMutationInput, CategoryListUncheckedUpdateManyInput>
    /**
     * Filter which CategoryLists to update
     * 
    **/
    where?: CategoryListWhereInput
  }


  /**
   * CategoryList upsert
   */
  export type CategoryListUpsertArgs = {
    /**
     * Select specific fields to fetch from the CategoryList
     * 
    **/
    select?: CategoryListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryListInclude | null
    /**
     * The filter to search for the CategoryList to update in case it exists.
     * 
    **/
    where: CategoryListWhereUniqueInput
    /**
     * In case the CategoryList found by the `where` argument doesn't exist, create a new CategoryList with this data.
     * 
    **/
    create: XOR<CategoryListCreateInput, CategoryListUncheckedCreateInput>
    /**
     * In case the CategoryList was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CategoryListUpdateInput, CategoryListUncheckedUpdateInput>
  }


  /**
   * CategoryList delete
   */
  export type CategoryListDeleteArgs = {
    /**
     * Select specific fields to fetch from the CategoryList
     * 
    **/
    select?: CategoryListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryListInclude | null
    /**
     * Filter which CategoryList to delete.
     * 
    **/
    where: CategoryListWhereUniqueInput
  }


  /**
   * CategoryList deleteMany
   */
  export type CategoryListDeleteManyArgs = {
    /**
     * Filter which CategoryLists to delete
     * 
    **/
    where?: CategoryListWhereInput
  }


  /**
   * CategoryList: findUniqueOrThrow
   */
  export type CategoryListFindUniqueOrThrowArgs = CategoryListFindUniqueArgsBase
      

  /**
   * CategoryList: findFirstOrThrow
   */
  export type CategoryListFindFirstOrThrowArgs = CategoryListFindFirstArgsBase
      

  /**
   * CategoryList without action
   */
  export type CategoryListArgs = {
    /**
     * Select specific fields to fetch from the CategoryList
     * 
    **/
    select?: CategoryListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryListInclude | null
  }



  /**
   * Model ServiceList
   */


  export type AggregateServiceList = {
    _count: ServiceListCountAggregateOutputType | null
    _min: ServiceListMinAggregateOutputType | null
    _max: ServiceListMaxAggregateOutputType | null
  }

  export type ServiceListMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceListMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceListCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceListMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceListMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceListCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceListAggregateArgs = {
    /**
     * Filter which ServiceList to aggregate.
     * 
    **/
    where?: ServiceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceLists to fetch.
     * 
    **/
    orderBy?: Enumerable<ServiceListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ServiceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceLists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceLists
    **/
    _count?: true | ServiceListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceListMaxAggregateInputType
  }

  export type GetServiceListAggregateType<T extends ServiceListAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceList[P]>
      : GetScalarType<T[P], AggregateServiceList[P]>
  }




  export type ServiceListGroupByArgs = {
    where?: ServiceListWhereInput
    orderBy?: Enumerable<ServiceListOrderByWithAggregationInput>
    by: Array<ServiceListScalarFieldEnum>
    having?: ServiceListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceListCountAggregateInputType | true
    _min?: ServiceListMinAggregateInputType
    _max?: ServiceListMaxAggregateInputType
  }


  export type ServiceListGroupByOutputType = {
    id: string
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    _count: ServiceListCountAggregateOutputType | null
    _min: ServiceListMinAggregateOutputType | null
    _max: ServiceListMaxAggregateOutputType | null
  }

  type GetServiceListGroupByPayload<T extends ServiceListGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ServiceListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceListGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceListGroupByOutputType[P]>
        }
      >
    >


  export type ServiceListSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    services?: boolean | ServiceFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ServiceListCountOutputTypeArgs
  }

  export type ServiceListInclude = {
    services?: boolean | ServiceFindManyArgs
    _count?: boolean | ServiceListCountOutputTypeArgs
  }

  export type ServiceListGetPayload<
    S extends boolean | null | undefined | ServiceListArgs,
    U = keyof S
      > = S extends true
        ? ServiceList
    : S extends undefined
    ? never
    : S extends ServiceListArgs | ServiceListFindManyArgs
    ?'include' extends U
    ? ServiceList  & {
    [P in TrueKeys<S['include']>]:
        P extends 'services' ? Array < ServiceGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ServiceListCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'services' ? Array < ServiceGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ServiceListCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof ServiceList ? ServiceList[P] : never
  } 
    : ServiceList
  : ServiceList


  type ServiceListCountArgs = Merge<
    Omit<ServiceListFindManyArgs, 'select' | 'include'> & {
      select?: ServiceListCountAggregateInputType | true
    }
  >

  export interface ServiceListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ServiceList that matches the filter.
     * @param {ServiceListFindUniqueArgs} args - Arguments to find a ServiceList
     * @example
     * // Get one ServiceList
     * const serviceList = await prisma.serviceList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceListFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceListFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ServiceList'> extends True ? CheckSelect<T, Prisma__ServiceListClient<ServiceList>, Prisma__ServiceListClient<ServiceListGetPayload<T>>> : CheckSelect<T, Prisma__ServiceListClient<ServiceList | null, null>, Prisma__ServiceListClient<ServiceListGetPayload<T> | null, null>>

    /**
     * Find the first ServiceList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceListFindFirstArgs} args - Arguments to find a ServiceList
     * @example
     * // Get one ServiceList
     * const serviceList = await prisma.serviceList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceListFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceListFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ServiceList'> extends True ? CheckSelect<T, Prisma__ServiceListClient<ServiceList>, Prisma__ServiceListClient<ServiceListGetPayload<T>>> : CheckSelect<T, Prisma__ServiceListClient<ServiceList | null, null>, Prisma__ServiceListClient<ServiceListGetPayload<T> | null, null>>

    /**
     * Find zero or more ServiceLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceLists
     * const serviceLists = await prisma.serviceList.findMany()
     * 
     * // Get first 10 ServiceLists
     * const serviceLists = await prisma.serviceList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceListWithIdOnly = await prisma.serviceList.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceListFindManyArgs>(
      args?: SelectSubset<T, ServiceListFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ServiceList>>, PrismaPromise<Array<ServiceListGetPayload<T>>>>

    /**
     * Create a ServiceList.
     * @param {ServiceListCreateArgs} args - Arguments to create a ServiceList.
     * @example
     * // Create one ServiceList
     * const ServiceList = await prisma.serviceList.create({
     *   data: {
     *     // ... data to create a ServiceList
     *   }
     * })
     * 
    **/
    create<T extends ServiceListCreateArgs>(
      args: SelectSubset<T, ServiceListCreateArgs>
    ): CheckSelect<T, Prisma__ServiceListClient<ServiceList>, Prisma__ServiceListClient<ServiceListGetPayload<T>>>

    /**
     * Create many ServiceLists.
     *     @param {ServiceListCreateManyArgs} args - Arguments to create many ServiceLists.
     *     @example
     *     // Create many ServiceLists
     *     const serviceList = await prisma.serviceList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceListCreateManyArgs>(
      args?: SelectSubset<T, ServiceListCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceList.
     * @param {ServiceListDeleteArgs} args - Arguments to delete one ServiceList.
     * @example
     * // Delete one ServiceList
     * const ServiceList = await prisma.serviceList.delete({
     *   where: {
     *     // ... filter to delete one ServiceList
     *   }
     * })
     * 
    **/
    delete<T extends ServiceListDeleteArgs>(
      args: SelectSubset<T, ServiceListDeleteArgs>
    ): CheckSelect<T, Prisma__ServiceListClient<ServiceList>, Prisma__ServiceListClient<ServiceListGetPayload<T>>>

    /**
     * Update one ServiceList.
     * @param {ServiceListUpdateArgs} args - Arguments to update one ServiceList.
     * @example
     * // Update one ServiceList
     * const serviceList = await prisma.serviceList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceListUpdateArgs>(
      args: SelectSubset<T, ServiceListUpdateArgs>
    ): CheckSelect<T, Prisma__ServiceListClient<ServiceList>, Prisma__ServiceListClient<ServiceListGetPayload<T>>>

    /**
     * Delete zero or more ServiceLists.
     * @param {ServiceListDeleteManyArgs} args - Arguments to filter ServiceLists to delete.
     * @example
     * // Delete a few ServiceLists
     * const { count } = await prisma.serviceList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceListDeleteManyArgs>(
      args?: SelectSubset<T, ServiceListDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceLists
     * const serviceList = await prisma.serviceList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceListUpdateManyArgs>(
      args: SelectSubset<T, ServiceListUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceList.
     * @param {ServiceListUpsertArgs} args - Arguments to update or create a ServiceList.
     * @example
     * // Update or create a ServiceList
     * const serviceList = await prisma.serviceList.upsert({
     *   create: {
     *     // ... data to create a ServiceList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceList we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceListUpsertArgs>(
      args: SelectSubset<T, ServiceListUpsertArgs>
    ): CheckSelect<T, Prisma__ServiceListClient<ServiceList>, Prisma__ServiceListClient<ServiceListGetPayload<T>>>

    /**
     * Find one ServiceList that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ServiceListFindUniqueOrThrowArgs} args - Arguments to find a ServiceList
     * @example
     * // Get one ServiceList
     * const serviceList = await prisma.serviceList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceListFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ServiceListFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ServiceListClient<ServiceList>, Prisma__ServiceListClient<ServiceListGetPayload<T>>>

    /**
     * Find the first ServiceList that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceListFindFirstOrThrowArgs} args - Arguments to find a ServiceList
     * @example
     * // Get one ServiceList
     * const serviceList = await prisma.serviceList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceListFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceListFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ServiceListClient<ServiceList>, Prisma__ServiceListClient<ServiceListGetPayload<T>>>

    /**
     * Count the number of ServiceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceListCountArgs} args - Arguments to filter ServiceLists to count.
     * @example
     * // Count the number of ServiceLists
     * const count = await prisma.serviceList.count({
     *   where: {
     *     // ... the filter for the ServiceLists we want to count
     *   }
     * })
    **/
    count<T extends ServiceListCountArgs>(
      args?: Subset<T, ServiceListCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceListAggregateArgs>(args: Subset<T, ServiceListAggregateArgs>): PrismaPromise<GetServiceListAggregateType<T>>

    /**
     * Group by ServiceList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceListGroupByArgs['orderBy'] }
        : { orderBy?: ServiceListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceListGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceListClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    services<T extends ServiceFindManyArgs = {}>(args?: Subset<T, ServiceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Service>| Null>, PrismaPromise<Array<ServiceGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ServiceList base type for findUnique actions
   */
  export type ServiceListFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ServiceList
     * 
    **/
    select?: ServiceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceListInclude | null
    /**
     * Filter, which ServiceList to fetch.
     * 
    **/
    where: ServiceListWhereUniqueInput
  }

  /**
   * ServiceList: findUnique
   */
  export interface ServiceListFindUniqueArgs extends ServiceListFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceList base type for findFirst actions
   */
  export type ServiceListFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ServiceList
     * 
    **/
    select?: ServiceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceListInclude | null
    /**
     * Filter, which ServiceList to fetch.
     * 
    **/
    where?: ServiceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceLists to fetch.
     * 
    **/
    orderBy?: Enumerable<ServiceListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceLists.
     * 
    **/
    cursor?: ServiceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceLists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceLists.
     * 
    **/
    distinct?: Enumerable<ServiceListScalarFieldEnum>
  }

  /**
   * ServiceList: findFirst
   */
  export interface ServiceListFindFirstArgs extends ServiceListFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceList findMany
   */
  export type ServiceListFindManyArgs = {
    /**
     * Select specific fields to fetch from the ServiceList
     * 
    **/
    select?: ServiceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceListInclude | null
    /**
     * Filter, which ServiceLists to fetch.
     * 
    **/
    where?: ServiceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceLists to fetch.
     * 
    **/
    orderBy?: Enumerable<ServiceListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceLists.
     * 
    **/
    cursor?: ServiceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceLists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceLists.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ServiceListScalarFieldEnum>
  }


  /**
   * ServiceList create
   */
  export type ServiceListCreateArgs = {
    /**
     * Select specific fields to fetch from the ServiceList
     * 
    **/
    select?: ServiceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceListInclude | null
    /**
     * The data needed to create a ServiceList.
     * 
    **/
    data: XOR<ServiceListCreateInput, ServiceListUncheckedCreateInput>
  }


  /**
   * ServiceList createMany
   */
  export type ServiceListCreateManyArgs = {
    /**
     * The data used to create many ServiceLists.
     * 
    **/
    data: Enumerable<ServiceListCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ServiceList update
   */
  export type ServiceListUpdateArgs = {
    /**
     * Select specific fields to fetch from the ServiceList
     * 
    **/
    select?: ServiceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceListInclude | null
    /**
     * The data needed to update a ServiceList.
     * 
    **/
    data: XOR<ServiceListUpdateInput, ServiceListUncheckedUpdateInput>
    /**
     * Choose, which ServiceList to update.
     * 
    **/
    where: ServiceListWhereUniqueInput
  }


  /**
   * ServiceList updateMany
   */
  export type ServiceListUpdateManyArgs = {
    /**
     * The data used to update ServiceLists.
     * 
    **/
    data: XOR<ServiceListUpdateManyMutationInput, ServiceListUncheckedUpdateManyInput>
    /**
     * Filter which ServiceLists to update
     * 
    **/
    where?: ServiceListWhereInput
  }


  /**
   * ServiceList upsert
   */
  export type ServiceListUpsertArgs = {
    /**
     * Select specific fields to fetch from the ServiceList
     * 
    **/
    select?: ServiceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceListInclude | null
    /**
     * The filter to search for the ServiceList to update in case it exists.
     * 
    **/
    where: ServiceListWhereUniqueInput
    /**
     * In case the ServiceList found by the `where` argument doesn't exist, create a new ServiceList with this data.
     * 
    **/
    create: XOR<ServiceListCreateInput, ServiceListUncheckedCreateInput>
    /**
     * In case the ServiceList was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ServiceListUpdateInput, ServiceListUncheckedUpdateInput>
  }


  /**
   * ServiceList delete
   */
  export type ServiceListDeleteArgs = {
    /**
     * Select specific fields to fetch from the ServiceList
     * 
    **/
    select?: ServiceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceListInclude | null
    /**
     * Filter which ServiceList to delete.
     * 
    **/
    where: ServiceListWhereUniqueInput
  }


  /**
   * ServiceList deleteMany
   */
  export type ServiceListDeleteManyArgs = {
    /**
     * Filter which ServiceLists to delete
     * 
    **/
    where?: ServiceListWhereInput
  }


  /**
   * ServiceList: findUniqueOrThrow
   */
  export type ServiceListFindUniqueOrThrowArgs = ServiceListFindUniqueArgsBase
      

  /**
   * ServiceList: findFirstOrThrow
   */
  export type ServiceListFindFirstOrThrowArgs = ServiceListFindFirstArgsBase
      

  /**
   * ServiceList without action
   */
  export type ServiceListArgs = {
    /**
     * Select specific fields to fetch from the ServiceList
     * 
    **/
    select?: ServiceListSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceListInclude | null
  }



  /**
   * Model Service
   */


  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    slug: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    slug: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    slug: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    slug?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    slug?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    slug?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs = {
    /**
     * Filter which Service to aggregate.
     * 
    **/
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     * 
    **/
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs = {
    where?: ServiceWhereInput
    orderBy?: Enumerable<ServiceOrderByWithAggregationInput>
    by: Array<ServiceScalarFieldEnum>
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }


  export type ServiceGroupByOutputType = {
    id: string
    title: string
    subtitle: string | null
    slug: string
    icon: string
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    slug?: boolean
    icon?: boolean
    serviceLists?: boolean | ServiceListFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ServiceCountOutputTypeArgs
  }

  export type ServiceInclude = {
    serviceLists?: boolean | ServiceListFindManyArgs
    _count?: boolean | ServiceCountOutputTypeArgs
  }

  export type ServiceGetPayload<
    S extends boolean | null | undefined | ServiceArgs,
    U = keyof S
      > = S extends true
        ? Service
    : S extends undefined
    ? never
    : S extends ServiceArgs | ServiceFindManyArgs
    ?'include' extends U
    ? Service  & {
    [P in TrueKeys<S['include']>]:
        P extends 'serviceLists' ? Array < ServiceListGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ServiceCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'serviceLists' ? Array < ServiceListGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ServiceCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Service ? Service[P] : never
  } 
    : Service
  : Service


  type ServiceCountArgs = Merge<
    Omit<ServiceFindManyArgs, 'select' | 'include'> & {
      select?: ServiceCountAggregateInputType | true
    }
  >

  export interface ServiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Service'> extends True ? CheckSelect<T, Prisma__ServiceClient<Service>, Prisma__ServiceClient<ServiceGetPayload<T>>> : CheckSelect<T, Prisma__ServiceClient<Service | null, null>, Prisma__ServiceClient<ServiceGetPayload<T> | null, null>>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Service'> extends True ? CheckSelect<T, Prisma__ServiceClient<Service>, Prisma__ServiceClient<ServiceGetPayload<T>>> : CheckSelect<T, Prisma__ServiceClient<Service | null, null>, Prisma__ServiceClient<ServiceGetPayload<T> | null, null>>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceFindManyArgs>(
      args?: SelectSubset<T, ServiceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Service>>, PrismaPromise<Array<ServiceGetPayload<T>>>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
    **/
    create<T extends ServiceCreateArgs>(
      args: SelectSubset<T, ServiceCreateArgs>
    ): CheckSelect<T, Prisma__ServiceClient<Service>, Prisma__ServiceClient<ServiceGetPayload<T>>>

    /**
     * Create many Services.
     *     @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const service = await prisma.service.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceCreateManyArgs>(
      args?: SelectSubset<T, ServiceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
    **/
    delete<T extends ServiceDeleteArgs>(
      args: SelectSubset<T, ServiceDeleteArgs>
    ): CheckSelect<T, Prisma__ServiceClient<Service>, Prisma__ServiceClient<ServiceGetPayload<T>>>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceUpdateArgs>(
      args: SelectSubset<T, ServiceUpdateArgs>
    ): CheckSelect<T, Prisma__ServiceClient<Service>, Prisma__ServiceClient<ServiceGetPayload<T>>>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceDeleteManyArgs>(
      args?: SelectSubset<T, ServiceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceUpdateManyArgs>(
      args: SelectSubset<T, ServiceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceUpsertArgs>(
      args: SelectSubset<T, ServiceUpsertArgs>
    ): CheckSelect<T, Prisma__ServiceClient<Service>, Prisma__ServiceClient<ServiceGetPayload<T>>>

    /**
     * Find one Service that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ServiceFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ServiceClient<Service>, Prisma__ServiceClient<ServiceGetPayload<T>>>

    /**
     * Find the first Service that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ServiceClient<Service>, Prisma__ServiceClient<ServiceGetPayload<T>>>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    serviceLists<T extends ServiceListFindManyArgs = {}>(args?: Subset<T, ServiceListFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ServiceList>| Null>, PrismaPromise<Array<ServiceListGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Service base type for findUnique actions
   */
  export type ServiceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Service
     * 
    **/
    select?: ServiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceInclude | null
    /**
     * Filter, which Service to fetch.
     * 
    **/
    where: ServiceWhereUniqueInput
  }

  /**
   * Service: findUnique
   */
  export interface ServiceFindUniqueArgs extends ServiceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Service base type for findFirst actions
   */
  export type ServiceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Service
     * 
    **/
    select?: ServiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceInclude | null
    /**
     * Filter, which Service to fetch.
     * 
    **/
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     * 
    **/
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     * 
    **/
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     * 
    **/
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }

  /**
   * Service: findFirst
   */
  export interface ServiceFindFirstArgs extends ServiceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Service
     * 
    **/
    select?: ServiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceInclude | null
    /**
     * Filter, which Services to fetch.
     * 
    **/
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     * 
    **/
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     * 
    **/
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Service create
   */
  export type ServiceCreateArgs = {
    /**
     * Select specific fields to fetch from the Service
     * 
    **/
    select?: ServiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceInclude | null
    /**
     * The data needed to create a Service.
     * 
    **/
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }


  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs = {
    /**
     * The data used to create many Services.
     * 
    **/
    data: Enumerable<ServiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Service update
   */
  export type ServiceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Service
     * 
    **/
    select?: ServiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceInclude | null
    /**
     * The data needed to update a Service.
     * 
    **/
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     * 
    **/
    where: ServiceWhereUniqueInput
  }


  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs = {
    /**
     * The data used to update Services.
     * 
    **/
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     * 
    **/
    where?: ServiceWhereInput
  }


  /**
   * Service upsert
   */
  export type ServiceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Service
     * 
    **/
    select?: ServiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceInclude | null
    /**
     * The filter to search for the Service to update in case it exists.
     * 
    **/
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     * 
    **/
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }


  /**
   * Service delete
   */
  export type ServiceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Service
     * 
    **/
    select?: ServiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceInclude | null
    /**
     * Filter which Service to delete.
     * 
    **/
    where: ServiceWhereUniqueInput
  }


  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs = {
    /**
     * Filter which Services to delete
     * 
    **/
    where?: ServiceWhereInput
  }


  /**
   * Service: findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs = ServiceFindUniqueArgsBase
      

  /**
   * Service: findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs = ServiceFindFirstArgsBase
      

  /**
   * Service without action
   */
  export type ServiceArgs = {
    /**
     * Select specific fields to fetch from the Service
     * 
    **/
    select?: ServiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServiceInclude | null
  }



  /**
   * Model Review
   */


  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    rating: number | null
    comment: string | null
    productId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    rating: number | null
    comment: string | null
    productId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    rating: number
    comment: number
    productId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    productId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    productId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    productId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs = {
    /**
     * Filter which Review to aggregate.
     * 
    **/
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<ReviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs = {
    where?: ReviewWhereInput
    orderBy?: Enumerable<ReviewOrderByWithAggregationInput>
    by: Array<ReviewScalarFieldEnum>
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }


  export type ReviewGroupByOutputType = {
    id: string
    rating: number
    comment: string | null
    productId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect = {
    id?: boolean
    rating?: boolean
    comment?: boolean
    productId?: boolean
    product?: boolean | ProductArgs
    userId?: boolean
    user?: boolean | UserArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewInclude = {
    product?: boolean | ProductArgs
    user?: boolean | UserArgs
  }

  export type ReviewGetPayload<
    S extends boolean | null | undefined | ReviewArgs,
    U = keyof S
      > = S extends true
        ? Review
    : S extends undefined
    ? never
    : S extends ReviewArgs | ReviewFindManyArgs
    ?'include' extends U
    ? Review  & {
    [P in TrueKeys<S['include']>]:
        P extends 'product' ? ProductGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'product' ? ProductGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Review ? Review[P] : never
  } 
    : Review
  : Review


  type ReviewCountArgs = Merge<
    Omit<ReviewFindManyArgs, 'select' | 'include'> & {
      select?: ReviewCountAggregateInputType | true
    }
  >

  export interface ReviewDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Review'> extends True ? CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>> : CheckSelect<T, Prisma__ReviewClient<Review | null, null>, Prisma__ReviewClient<ReviewGetPayload<T> | null, null>>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Review'> extends True ? CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>> : CheckSelect<T, Prisma__ReviewClient<Review | null, null>, Prisma__ReviewClient<ReviewGetPayload<T> | null, null>>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReviewFindManyArgs>(
      args?: SelectSubset<T, ReviewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Review>>, PrismaPromise<Array<ReviewGetPayload<T>>>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
    **/
    create<T extends ReviewCreateArgs>(
      args: SelectSubset<T, ReviewCreateArgs>
    ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>

    /**
     * Create many Reviews.
     *     @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     *     @example
     *     // Create many Reviews
     *     const review = await prisma.review.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReviewCreateManyArgs>(
      args?: SelectSubset<T, ReviewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
    **/
    delete<T extends ReviewDeleteArgs>(
      args: SelectSubset<T, ReviewDeleteArgs>
    ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReviewUpdateArgs>(
      args: SelectSubset<T, ReviewUpdateArgs>
    ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReviewDeleteManyArgs>(
      args?: SelectSubset<T, ReviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReviewUpdateManyArgs>(
      args: SelectSubset<T, ReviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
    **/
    upsert<T extends ReviewUpsertArgs>(
      args: SelectSubset<T, ReviewUpsertArgs>
    ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>

    /**
     * Find one Review that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReviewFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>

    /**
     * Find the first Review that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReviewFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReviewClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | Null>, Prisma__ProductClient<ProductGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Review base type for findUnique actions
   */
  export type ReviewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
    /**
     * Filter, which Review to fetch.
     * 
    **/
    where: ReviewWhereUniqueInput
  }

  /**
   * Review: findUnique
   */
  export interface ReviewFindUniqueArgs extends ReviewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Review base type for findFirst actions
   */
  export type ReviewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
    /**
     * Filter, which Review to fetch.
     * 
    **/
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<ReviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     * 
    **/
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     * 
    **/
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }

  /**
   * Review: findFirst
   */
  export interface ReviewFindFirstArgs extends ReviewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
    /**
     * Filter, which Reviews to fetch.
     * 
    **/
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<ReviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     * 
    **/
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * Review create
   */
  export type ReviewCreateArgs = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
    /**
     * The data needed to create a Review.
     * 
    **/
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }


  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs = {
    /**
     * The data used to create many Reviews.
     * 
    **/
    data: Enumerable<ReviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Review update
   */
  export type ReviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
    /**
     * The data needed to update a Review.
     * 
    **/
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     * 
    **/
    where: ReviewWhereUniqueInput
  }


  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs = {
    /**
     * The data used to update Reviews.
     * 
    **/
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     * 
    **/
    where?: ReviewWhereInput
  }


  /**
   * Review upsert
   */
  export type ReviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
    /**
     * The filter to search for the Review to update in case it exists.
     * 
    **/
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     * 
    **/
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }


  /**
   * Review delete
   */
  export type ReviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
    /**
     * Filter which Review to delete.
     * 
    **/
    where: ReviewWhereUniqueInput
  }


  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs = {
    /**
     * Filter which Reviews to delete
     * 
    **/
    where?: ReviewWhereInput
  }


  /**
   * Review: findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs = ReviewFindUniqueArgsBase
      

  /**
   * Review: findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs = ReviewFindFirstArgsBase
      

  /**
   * Review without action
   */
  export type ReviewArgs = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
  }



  /**
   * Model SiteSetting
   */


  export type AggregateSiteSetting = {
    _count: SiteSettingCountAggregateOutputType | null
    _min: SiteSettingMinAggregateOutputType | null
    _max: SiteSettingMaxAggregateOutputType | null
  }

  export type SiteSettingMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    description: string | null
    title: string | null
    bannerText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteSettingMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    description: string | null
    title: string | null
    bannerText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteSettingCountAggregateOutputType = {
    id: number
    organizationId: number
    description: number
    title: number
    bannerText: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SiteSettingMinAggregateInputType = {
    id?: true
    organizationId?: true
    description?: true
    title?: true
    bannerText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteSettingMaxAggregateInputType = {
    id?: true
    organizationId?: true
    description?: true
    title?: true
    bannerText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteSettingCountAggregateInputType = {
    id?: true
    organizationId?: true
    description?: true
    title?: true
    bannerText?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SiteSettingAggregateArgs = {
    /**
     * Filter which SiteSetting to aggregate.
     * 
    **/
    where?: SiteSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<SiteSettingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SiteSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteSettings
    **/
    _count?: true | SiteSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteSettingMaxAggregateInputType
  }

  export type GetSiteSettingAggregateType<T extends SiteSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteSetting[P]>
      : GetScalarType<T[P], AggregateSiteSetting[P]>
  }




  export type SiteSettingGroupByArgs = {
    where?: SiteSettingWhereInput
    orderBy?: Enumerable<SiteSettingOrderByWithAggregationInput>
    by: Array<SiteSettingScalarFieldEnum>
    having?: SiteSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteSettingCountAggregateInputType | true
    _min?: SiteSettingMinAggregateInputType
    _max?: SiteSettingMaxAggregateInputType
  }


  export type SiteSettingGroupByOutputType = {
    id: string
    organizationId: string
    description: string | null
    title: string
    bannerText: string | null
    createdAt: Date
    updatedAt: Date
    _count: SiteSettingCountAggregateOutputType | null
    _min: SiteSettingMinAggregateOutputType | null
    _max: SiteSettingMaxAggregateOutputType | null
  }

  type GetSiteSettingGroupByPayload<T extends SiteSettingGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SiteSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SiteSettingGroupByOutputType[P]>
        }
      >
    >


  export type SiteSettingSelect = {
    id?: boolean
    organizationId?: boolean
    description?: boolean
    title?: boolean
    bannerText?: boolean
    organization?: boolean | OrganizationArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SiteSettingInclude = {
    organization?: boolean | OrganizationArgs
  }

  export type SiteSettingGetPayload<
    S extends boolean | null | undefined | SiteSettingArgs,
    U = keyof S
      > = S extends true
        ? SiteSetting
    : S extends undefined
    ? never
    : S extends SiteSettingArgs | SiteSettingFindManyArgs
    ?'include' extends U
    ? SiteSetting  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organization' ? OrganizationGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organization' ? OrganizationGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SiteSetting ? SiteSetting[P] : never
  } 
    : SiteSetting
  : SiteSetting


  type SiteSettingCountArgs = Merge<
    Omit<SiteSettingFindManyArgs, 'select' | 'include'> & {
      select?: SiteSettingCountAggregateInputType | true
    }
  >

  export interface SiteSettingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SiteSetting that matches the filter.
     * @param {SiteSettingFindUniqueArgs} args - Arguments to find a SiteSetting
     * @example
     * // Get one SiteSetting
     * const siteSetting = await prisma.siteSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SiteSettingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SiteSettingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SiteSetting'> extends True ? CheckSelect<T, Prisma__SiteSettingClient<SiteSetting>, Prisma__SiteSettingClient<SiteSettingGetPayload<T>>> : CheckSelect<T, Prisma__SiteSettingClient<SiteSetting | null, null>, Prisma__SiteSettingClient<SiteSettingGetPayload<T> | null, null>>

    /**
     * Find the first SiteSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingFindFirstArgs} args - Arguments to find a SiteSetting
     * @example
     * // Get one SiteSetting
     * const siteSetting = await prisma.siteSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SiteSettingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SiteSettingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SiteSetting'> extends True ? CheckSelect<T, Prisma__SiteSettingClient<SiteSetting>, Prisma__SiteSettingClient<SiteSettingGetPayload<T>>> : CheckSelect<T, Prisma__SiteSettingClient<SiteSetting | null, null>, Prisma__SiteSettingClient<SiteSettingGetPayload<T> | null, null>>

    /**
     * Find zero or more SiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteSettings
     * const siteSettings = await prisma.siteSetting.findMany()
     * 
     * // Get first 10 SiteSettings
     * const siteSettings = await prisma.siteSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteSettingWithIdOnly = await prisma.siteSetting.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SiteSettingFindManyArgs>(
      args?: SelectSubset<T, SiteSettingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SiteSetting>>, PrismaPromise<Array<SiteSettingGetPayload<T>>>>

    /**
     * Create a SiteSetting.
     * @param {SiteSettingCreateArgs} args - Arguments to create a SiteSetting.
     * @example
     * // Create one SiteSetting
     * const SiteSetting = await prisma.siteSetting.create({
     *   data: {
     *     // ... data to create a SiteSetting
     *   }
     * })
     * 
    **/
    create<T extends SiteSettingCreateArgs>(
      args: SelectSubset<T, SiteSettingCreateArgs>
    ): CheckSelect<T, Prisma__SiteSettingClient<SiteSetting>, Prisma__SiteSettingClient<SiteSettingGetPayload<T>>>

    /**
     * Create many SiteSettings.
     *     @param {SiteSettingCreateManyArgs} args - Arguments to create many SiteSettings.
     *     @example
     *     // Create many SiteSettings
     *     const siteSetting = await prisma.siteSetting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SiteSettingCreateManyArgs>(
      args?: SelectSubset<T, SiteSettingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SiteSetting.
     * @param {SiteSettingDeleteArgs} args - Arguments to delete one SiteSetting.
     * @example
     * // Delete one SiteSetting
     * const SiteSetting = await prisma.siteSetting.delete({
     *   where: {
     *     // ... filter to delete one SiteSetting
     *   }
     * })
     * 
    **/
    delete<T extends SiteSettingDeleteArgs>(
      args: SelectSubset<T, SiteSettingDeleteArgs>
    ): CheckSelect<T, Prisma__SiteSettingClient<SiteSetting>, Prisma__SiteSettingClient<SiteSettingGetPayload<T>>>

    /**
     * Update one SiteSetting.
     * @param {SiteSettingUpdateArgs} args - Arguments to update one SiteSetting.
     * @example
     * // Update one SiteSetting
     * const siteSetting = await prisma.siteSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SiteSettingUpdateArgs>(
      args: SelectSubset<T, SiteSettingUpdateArgs>
    ): CheckSelect<T, Prisma__SiteSettingClient<SiteSetting>, Prisma__SiteSettingClient<SiteSettingGetPayload<T>>>

    /**
     * Delete zero or more SiteSettings.
     * @param {SiteSettingDeleteManyArgs} args - Arguments to filter SiteSettings to delete.
     * @example
     * // Delete a few SiteSettings
     * const { count } = await prisma.siteSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SiteSettingDeleteManyArgs>(
      args?: SelectSubset<T, SiteSettingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteSettings
     * const siteSetting = await prisma.siteSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SiteSettingUpdateManyArgs>(
      args: SelectSubset<T, SiteSettingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SiteSetting.
     * @param {SiteSettingUpsertArgs} args - Arguments to update or create a SiteSetting.
     * @example
     * // Update or create a SiteSetting
     * const siteSetting = await prisma.siteSetting.upsert({
     *   create: {
     *     // ... data to create a SiteSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteSetting we want to update
     *   }
     * })
    **/
    upsert<T extends SiteSettingUpsertArgs>(
      args: SelectSubset<T, SiteSettingUpsertArgs>
    ): CheckSelect<T, Prisma__SiteSettingClient<SiteSetting>, Prisma__SiteSettingClient<SiteSettingGetPayload<T>>>

    /**
     * Find one SiteSetting that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SiteSettingFindUniqueOrThrowArgs} args - Arguments to find a SiteSetting
     * @example
     * // Get one SiteSetting
     * const siteSetting = await prisma.siteSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SiteSettingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SiteSettingFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SiteSettingClient<SiteSetting>, Prisma__SiteSettingClient<SiteSettingGetPayload<T>>>

    /**
     * Find the first SiteSetting that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingFindFirstOrThrowArgs} args - Arguments to find a SiteSetting
     * @example
     * // Get one SiteSetting
     * const siteSetting = await prisma.siteSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SiteSettingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SiteSettingFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SiteSettingClient<SiteSetting>, Prisma__SiteSettingClient<SiteSettingGetPayload<T>>>

    /**
     * Count the number of SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingCountArgs} args - Arguments to filter SiteSettings to count.
     * @example
     * // Count the number of SiteSettings
     * const count = await prisma.siteSetting.count({
     *   where: {
     *     // ... the filter for the SiteSettings we want to count
     *   }
     * })
    **/
    count<T extends SiteSettingCountArgs>(
      args?: Subset<T, SiteSettingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteSettingAggregateArgs>(args: Subset<T, SiteSettingAggregateArgs>): PrismaPromise<GetSiteSettingAggregateType<T>>

    /**
     * Group by SiteSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteSettingGroupByArgs['orderBy'] }
        : { orderBy?: SiteSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteSettingGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SiteSettingClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organization<T extends OrganizationArgs = {}>(args?: Subset<T, OrganizationArgs>): CheckSelect<T, Prisma__OrganizationClient<Organization | Null>, Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SiteSetting base type for findUnique actions
   */
  export type SiteSettingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SiteSetting
     * 
    **/
    select?: SiteSettingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SiteSettingInclude | null
    /**
     * Filter, which SiteSetting to fetch.
     * 
    **/
    where: SiteSettingWhereUniqueInput
  }

  /**
   * SiteSetting: findUnique
   */
  export interface SiteSettingFindUniqueArgs extends SiteSettingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SiteSetting base type for findFirst actions
   */
  export type SiteSettingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SiteSetting
     * 
    **/
    select?: SiteSettingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SiteSettingInclude | null
    /**
     * Filter, which SiteSetting to fetch.
     * 
    **/
    where?: SiteSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<SiteSettingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteSettings.
     * 
    **/
    cursor?: SiteSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteSettings.
     * 
    **/
    distinct?: Enumerable<SiteSettingScalarFieldEnum>
  }

  /**
   * SiteSetting: findFirst
   */
  export interface SiteSettingFindFirstArgs extends SiteSettingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SiteSetting findMany
   */
  export type SiteSettingFindManyArgs = {
    /**
     * Select specific fields to fetch from the SiteSetting
     * 
    **/
    select?: SiteSettingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SiteSettingInclude | null
    /**
     * Filter, which SiteSettings to fetch.
     * 
    **/
    where?: SiteSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<SiteSettingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteSettings.
     * 
    **/
    cursor?: SiteSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SiteSettingScalarFieldEnum>
  }


  /**
   * SiteSetting create
   */
  export type SiteSettingCreateArgs = {
    /**
     * Select specific fields to fetch from the SiteSetting
     * 
    **/
    select?: SiteSettingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SiteSettingInclude | null
    /**
     * The data needed to create a SiteSetting.
     * 
    **/
    data: XOR<SiteSettingCreateInput, SiteSettingUncheckedCreateInput>
  }


  /**
   * SiteSetting createMany
   */
  export type SiteSettingCreateManyArgs = {
    /**
     * The data used to create many SiteSettings.
     * 
    **/
    data: Enumerable<SiteSettingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SiteSetting update
   */
  export type SiteSettingUpdateArgs = {
    /**
     * Select specific fields to fetch from the SiteSetting
     * 
    **/
    select?: SiteSettingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SiteSettingInclude | null
    /**
     * The data needed to update a SiteSetting.
     * 
    **/
    data: XOR<SiteSettingUpdateInput, SiteSettingUncheckedUpdateInput>
    /**
     * Choose, which SiteSetting to update.
     * 
    **/
    where: SiteSettingWhereUniqueInput
  }


  /**
   * SiteSetting updateMany
   */
  export type SiteSettingUpdateManyArgs = {
    /**
     * The data used to update SiteSettings.
     * 
    **/
    data: XOR<SiteSettingUpdateManyMutationInput, SiteSettingUncheckedUpdateManyInput>
    /**
     * Filter which SiteSettings to update
     * 
    **/
    where?: SiteSettingWhereInput
  }


  /**
   * SiteSetting upsert
   */
  export type SiteSettingUpsertArgs = {
    /**
     * Select specific fields to fetch from the SiteSetting
     * 
    **/
    select?: SiteSettingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SiteSettingInclude | null
    /**
     * The filter to search for the SiteSetting to update in case it exists.
     * 
    **/
    where: SiteSettingWhereUniqueInput
    /**
     * In case the SiteSetting found by the `where` argument doesn't exist, create a new SiteSetting with this data.
     * 
    **/
    create: XOR<SiteSettingCreateInput, SiteSettingUncheckedCreateInput>
    /**
     * In case the SiteSetting was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SiteSettingUpdateInput, SiteSettingUncheckedUpdateInput>
  }


  /**
   * SiteSetting delete
   */
  export type SiteSettingDeleteArgs = {
    /**
     * Select specific fields to fetch from the SiteSetting
     * 
    **/
    select?: SiteSettingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SiteSettingInclude | null
    /**
     * Filter which SiteSetting to delete.
     * 
    **/
    where: SiteSettingWhereUniqueInput
  }


  /**
   * SiteSetting deleteMany
   */
  export type SiteSettingDeleteManyArgs = {
    /**
     * Filter which SiteSettings to delete
     * 
    **/
    where?: SiteSettingWhereInput
  }


  /**
   * SiteSetting: findUniqueOrThrow
   */
  export type SiteSettingFindUniqueOrThrowArgs = SiteSettingFindUniqueArgsBase
      

  /**
   * SiteSetting: findFirstOrThrow
   */
  export type SiteSettingFindFirstOrThrowArgs = SiteSettingFindFirstArgsBase
      

  /**
   * SiteSetting without action
   */
  export type SiteSettingArgs = {
    /**
     * Select specific fields to fetch from the SiteSetting
     * 
    **/
    select?: SiteSettingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SiteSettingInclude | null
  }



  /**
   * Model SubDomain
   */


  export type AggregateSubDomain = {
    _count: SubDomainCountAggregateOutputType | null
    _min: SubDomainMinAggregateOutputType | null
    _max: SubDomainMaxAggregateOutputType | null
  }

  export type SubDomainMinAggregateOutputType = {
    subdomain: string | null
    isValid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubDomainMaxAggregateOutputType = {
    subdomain: string | null
    isValid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubDomainCountAggregateOutputType = {
    subdomain: number
    isValid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubDomainMinAggregateInputType = {
    subdomain?: true
    isValid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubDomainMaxAggregateInputType = {
    subdomain?: true
    isValid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubDomainCountAggregateInputType = {
    subdomain?: true
    isValid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubDomainAggregateArgs = {
    /**
     * Filter which SubDomain to aggregate.
     * 
    **/
    where?: SubDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubDomains to fetch.
     * 
    **/
    orderBy?: Enumerable<SubDomainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubDomains from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubDomains.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubDomains
    **/
    _count?: true | SubDomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubDomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubDomainMaxAggregateInputType
  }

  export type GetSubDomainAggregateType<T extends SubDomainAggregateArgs> = {
        [P in keyof T & keyof AggregateSubDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubDomain[P]>
      : GetScalarType<T[P], AggregateSubDomain[P]>
  }




  export type SubDomainGroupByArgs = {
    where?: SubDomainWhereInput
    orderBy?: Enumerable<SubDomainOrderByWithAggregationInput>
    by: Array<SubDomainScalarFieldEnum>
    having?: SubDomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubDomainCountAggregateInputType | true
    _min?: SubDomainMinAggregateInputType
    _max?: SubDomainMaxAggregateInputType
  }


  export type SubDomainGroupByOutputType = {
    subdomain: string
    isValid: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubDomainCountAggregateOutputType | null
    _min: SubDomainMinAggregateOutputType | null
    _max: SubDomainMaxAggregateOutputType | null
  }

  type GetSubDomainGroupByPayload<T extends SubDomainGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubDomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubDomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubDomainGroupByOutputType[P]>
            : GetScalarType<T[P], SubDomainGroupByOutputType[P]>
        }
      >
    >


  export type SubDomainSelect = {
    subdomain?: boolean
    organization?: boolean | OrganizationFindManyArgs
    isValid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | SubDomainCountOutputTypeArgs
  }

  export type SubDomainInclude = {
    organization?: boolean | OrganizationFindManyArgs
    _count?: boolean | SubDomainCountOutputTypeArgs
  }

  export type SubDomainGetPayload<
    S extends boolean | null | undefined | SubDomainArgs,
    U = keyof S
      > = S extends true
        ? SubDomain
    : S extends undefined
    ? never
    : S extends SubDomainArgs | SubDomainFindManyArgs
    ?'include' extends U
    ? SubDomain  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organization' ? Array < OrganizationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? SubDomainCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organization' ? Array < OrganizationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? SubDomainCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SubDomain ? SubDomain[P] : never
  } 
    : SubDomain
  : SubDomain


  type SubDomainCountArgs = Merge<
    Omit<SubDomainFindManyArgs, 'select' | 'include'> & {
      select?: SubDomainCountAggregateInputType | true
    }
  >

  export interface SubDomainDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SubDomain that matches the filter.
     * @param {SubDomainFindUniqueArgs} args - Arguments to find a SubDomain
     * @example
     * // Get one SubDomain
     * const subDomain = await prisma.subDomain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubDomainFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubDomainFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubDomain'> extends True ? CheckSelect<T, Prisma__SubDomainClient<SubDomain>, Prisma__SubDomainClient<SubDomainGetPayload<T>>> : CheckSelect<T, Prisma__SubDomainClient<SubDomain | null, null>, Prisma__SubDomainClient<SubDomainGetPayload<T> | null, null>>

    /**
     * Find the first SubDomain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubDomainFindFirstArgs} args - Arguments to find a SubDomain
     * @example
     * // Get one SubDomain
     * const subDomain = await prisma.subDomain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubDomainFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubDomainFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubDomain'> extends True ? CheckSelect<T, Prisma__SubDomainClient<SubDomain>, Prisma__SubDomainClient<SubDomainGetPayload<T>>> : CheckSelect<T, Prisma__SubDomainClient<SubDomain | null, null>, Prisma__SubDomainClient<SubDomainGetPayload<T> | null, null>>

    /**
     * Find zero or more SubDomains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubDomainFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubDomains
     * const subDomains = await prisma.subDomain.findMany()
     * 
     * // Get first 10 SubDomains
     * const subDomains = await prisma.subDomain.findMany({ take: 10 })
     * 
     * // Only select the `subdomain`
     * const subDomainWithSubdomainOnly = await prisma.subDomain.findMany({ select: { subdomain: true } })
     * 
    **/
    findMany<T extends SubDomainFindManyArgs>(
      args?: SelectSubset<T, SubDomainFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SubDomain>>, PrismaPromise<Array<SubDomainGetPayload<T>>>>

    /**
     * Create a SubDomain.
     * @param {SubDomainCreateArgs} args - Arguments to create a SubDomain.
     * @example
     * // Create one SubDomain
     * const SubDomain = await prisma.subDomain.create({
     *   data: {
     *     // ... data to create a SubDomain
     *   }
     * })
     * 
    **/
    create<T extends SubDomainCreateArgs>(
      args: SelectSubset<T, SubDomainCreateArgs>
    ): CheckSelect<T, Prisma__SubDomainClient<SubDomain>, Prisma__SubDomainClient<SubDomainGetPayload<T>>>

    /**
     * Create many SubDomains.
     *     @param {SubDomainCreateManyArgs} args - Arguments to create many SubDomains.
     *     @example
     *     // Create many SubDomains
     *     const subDomain = await prisma.subDomain.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubDomainCreateManyArgs>(
      args?: SelectSubset<T, SubDomainCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SubDomain.
     * @param {SubDomainDeleteArgs} args - Arguments to delete one SubDomain.
     * @example
     * // Delete one SubDomain
     * const SubDomain = await prisma.subDomain.delete({
     *   where: {
     *     // ... filter to delete one SubDomain
     *   }
     * })
     * 
    **/
    delete<T extends SubDomainDeleteArgs>(
      args: SelectSubset<T, SubDomainDeleteArgs>
    ): CheckSelect<T, Prisma__SubDomainClient<SubDomain>, Prisma__SubDomainClient<SubDomainGetPayload<T>>>

    /**
     * Update one SubDomain.
     * @param {SubDomainUpdateArgs} args - Arguments to update one SubDomain.
     * @example
     * // Update one SubDomain
     * const subDomain = await prisma.subDomain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubDomainUpdateArgs>(
      args: SelectSubset<T, SubDomainUpdateArgs>
    ): CheckSelect<T, Prisma__SubDomainClient<SubDomain>, Prisma__SubDomainClient<SubDomainGetPayload<T>>>

    /**
     * Delete zero or more SubDomains.
     * @param {SubDomainDeleteManyArgs} args - Arguments to filter SubDomains to delete.
     * @example
     * // Delete a few SubDomains
     * const { count } = await prisma.subDomain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubDomainDeleteManyArgs>(
      args?: SelectSubset<T, SubDomainDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubDomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubDomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubDomains
     * const subDomain = await prisma.subDomain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubDomainUpdateManyArgs>(
      args: SelectSubset<T, SubDomainUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubDomain.
     * @param {SubDomainUpsertArgs} args - Arguments to update or create a SubDomain.
     * @example
     * // Update or create a SubDomain
     * const subDomain = await prisma.subDomain.upsert({
     *   create: {
     *     // ... data to create a SubDomain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubDomain we want to update
     *   }
     * })
    **/
    upsert<T extends SubDomainUpsertArgs>(
      args: SelectSubset<T, SubDomainUpsertArgs>
    ): CheckSelect<T, Prisma__SubDomainClient<SubDomain>, Prisma__SubDomainClient<SubDomainGetPayload<T>>>

    /**
     * Find one SubDomain that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SubDomainFindUniqueOrThrowArgs} args - Arguments to find a SubDomain
     * @example
     * // Get one SubDomain
     * const subDomain = await prisma.subDomain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubDomainFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubDomainFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SubDomainClient<SubDomain>, Prisma__SubDomainClient<SubDomainGetPayload<T>>>

    /**
     * Find the first SubDomain that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubDomainFindFirstOrThrowArgs} args - Arguments to find a SubDomain
     * @example
     * // Get one SubDomain
     * const subDomain = await prisma.subDomain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubDomainFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubDomainFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SubDomainClient<SubDomain>, Prisma__SubDomainClient<SubDomainGetPayload<T>>>

    /**
     * Count the number of SubDomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubDomainCountArgs} args - Arguments to filter SubDomains to count.
     * @example
     * // Count the number of SubDomains
     * const count = await prisma.subDomain.count({
     *   where: {
     *     // ... the filter for the SubDomains we want to count
     *   }
     * })
    **/
    count<T extends SubDomainCountArgs>(
      args?: Subset<T, SubDomainCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubDomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubDomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubDomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubDomainAggregateArgs>(args: Subset<T, SubDomainAggregateArgs>): PrismaPromise<GetSubDomainAggregateType<T>>

    /**
     * Group by SubDomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubDomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubDomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubDomainGroupByArgs['orderBy'] }
        : { orderBy?: SubDomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubDomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubDomainGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SubDomain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubDomainClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organization<T extends OrganizationFindManyArgs = {}>(args?: Subset<T, OrganizationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Organization>| Null>, PrismaPromise<Array<OrganizationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SubDomain base type for findUnique actions
   */
  export type SubDomainFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SubDomain
     * 
    **/
    select?: SubDomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubDomainInclude | null
    /**
     * Filter, which SubDomain to fetch.
     * 
    **/
    where: SubDomainWhereUniqueInput
  }

  /**
   * SubDomain: findUnique
   */
  export interface SubDomainFindUniqueArgs extends SubDomainFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubDomain base type for findFirst actions
   */
  export type SubDomainFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SubDomain
     * 
    **/
    select?: SubDomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubDomainInclude | null
    /**
     * Filter, which SubDomain to fetch.
     * 
    **/
    where?: SubDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubDomains to fetch.
     * 
    **/
    orderBy?: Enumerable<SubDomainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubDomains.
     * 
    **/
    cursor?: SubDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubDomains from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubDomains.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubDomains.
     * 
    **/
    distinct?: Enumerable<SubDomainScalarFieldEnum>
  }

  /**
   * SubDomain: findFirst
   */
  export interface SubDomainFindFirstArgs extends SubDomainFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubDomain findMany
   */
  export type SubDomainFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubDomain
     * 
    **/
    select?: SubDomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubDomainInclude | null
    /**
     * Filter, which SubDomains to fetch.
     * 
    **/
    where?: SubDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubDomains to fetch.
     * 
    **/
    orderBy?: Enumerable<SubDomainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubDomains.
     * 
    **/
    cursor?: SubDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubDomains from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubDomains.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubDomainScalarFieldEnum>
  }


  /**
   * SubDomain create
   */
  export type SubDomainCreateArgs = {
    /**
     * Select specific fields to fetch from the SubDomain
     * 
    **/
    select?: SubDomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubDomainInclude | null
    /**
     * The data needed to create a SubDomain.
     * 
    **/
    data: XOR<SubDomainCreateInput, SubDomainUncheckedCreateInput>
  }


  /**
   * SubDomain createMany
   */
  export type SubDomainCreateManyArgs = {
    /**
     * The data used to create many SubDomains.
     * 
    **/
    data: Enumerable<SubDomainCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubDomain update
   */
  export type SubDomainUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubDomain
     * 
    **/
    select?: SubDomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubDomainInclude | null
    /**
     * The data needed to update a SubDomain.
     * 
    **/
    data: XOR<SubDomainUpdateInput, SubDomainUncheckedUpdateInput>
    /**
     * Choose, which SubDomain to update.
     * 
    **/
    where: SubDomainWhereUniqueInput
  }


  /**
   * SubDomain updateMany
   */
  export type SubDomainUpdateManyArgs = {
    /**
     * The data used to update SubDomains.
     * 
    **/
    data: XOR<SubDomainUpdateManyMutationInput, SubDomainUncheckedUpdateManyInput>
    /**
     * Filter which SubDomains to update
     * 
    **/
    where?: SubDomainWhereInput
  }


  /**
   * SubDomain upsert
   */
  export type SubDomainUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubDomain
     * 
    **/
    select?: SubDomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubDomainInclude | null
    /**
     * The filter to search for the SubDomain to update in case it exists.
     * 
    **/
    where: SubDomainWhereUniqueInput
    /**
     * In case the SubDomain found by the `where` argument doesn't exist, create a new SubDomain with this data.
     * 
    **/
    create: XOR<SubDomainCreateInput, SubDomainUncheckedCreateInput>
    /**
     * In case the SubDomain was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubDomainUpdateInput, SubDomainUncheckedUpdateInput>
  }


  /**
   * SubDomain delete
   */
  export type SubDomainDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubDomain
     * 
    **/
    select?: SubDomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubDomainInclude | null
    /**
     * Filter which SubDomain to delete.
     * 
    **/
    where: SubDomainWhereUniqueInput
  }


  /**
   * SubDomain deleteMany
   */
  export type SubDomainDeleteManyArgs = {
    /**
     * Filter which SubDomains to delete
     * 
    **/
    where?: SubDomainWhereInput
  }


  /**
   * SubDomain: findUniqueOrThrow
   */
  export type SubDomainFindUniqueOrThrowArgs = SubDomainFindUniqueArgsBase
      

  /**
   * SubDomain: findFirstOrThrow
   */
  export type SubDomainFindFirstOrThrowArgs = SubDomainFindFirstArgsBase
      

  /**
   * SubDomain without action
   */
  export type SubDomainArgs = {
    /**
     * Select specific fields to fetch from the SubDomain
     * 
    **/
    select?: SubDomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubDomainInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    oauth_token_secret: 'oauth_token_secret',
    oauth_token: 'oauth_token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    street1: 'street1',
    street2: 'street2',
    city: 'city',
    state: 'state',
    zipcode: 'zipcode',
    country: 'country',
    countryCode: 'countryCode',
    coordinateId: 'coordinateId',
    userId: 'userId',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const CategoryListScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryListScalarFieldEnum = (typeof CategoryListScalarFieldEnum)[keyof typeof CategoryListScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const CoordinatesScalarFieldEnum: {
    id: 'id',
    latitude: 'latitude',
    longitude: 'longitude',
    radius: 'radius',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoordinatesScalarFieldEnum = (typeof CoordinatesScalarFieldEnum)[keyof typeof CoordinatesScalarFieldEnum]


  export const DriverScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DriverScalarFieldEnum = (typeof DriverScalarFieldEnum)[keyof typeof DriverScalarFieldEnum]


  export const ImageOrganizationScalarFieldEnum: {
    id: 'id',
    location: 'location',
    organizationId: 'organizationId',
    blurhash: 'blurhash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImageOrganizationScalarFieldEnum = (typeof ImageOrganizationScalarFieldEnum)[keyof typeof ImageOrganizationScalarFieldEnum]


  export const ImageProductScalarFieldEnum: {
    id: 'id',
    location: 'location',
    productId: 'productId',
    blurhash: 'blurhash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImageProductScalarFieldEnum = (typeof ImageProductScalarFieldEnum)[keyof typeof ImageProductScalarFieldEnum]


  export const ImageUserScalarFieldEnum: {
    id: 'id',
    location: 'location',
    userId: 'userId',
    blurhash: 'blurhash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImageUserScalarFieldEnum = (typeof ImageUserScalarFieldEnum)[keyof typeof ImageUserScalarFieldEnum]


  export const ImageVendorScalarFieldEnum: {
    id: 'id',
    location: 'location',
    blurhash: 'blurhash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImageVendorScalarFieldEnum = (typeof ImageVendorScalarFieldEnum)[keyof typeof ImageVendorScalarFieldEnum]


  export const MembershipScalarFieldEnum: {
    id: 'id',
    role: 'role',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MembershipScalarFieldEnum = (typeof MembershipScalarFieldEnum)[keyof typeof MembershipScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    total: 'total',
    status: 'status',
    customerId: 'customerId',
    driverId: 'driverId',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrganizationMembershipScalarFieldEnum: {
    organizationId: 'organizationId',
    membershipId: 'membershipId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationMembershipScalarFieldEnum = (typeof OrganizationMembershipScalarFieldEnum)[keyof typeof OrganizationMembershipScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    dialCode: 'dialCode',
    phone: 'phone',
    vendorId: 'vendorId',
    subdomainId: 'subdomainId',
    termsAccepted: 'termsAccepted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    features: 'features',
    unit: 'unit',
    size: 'size',
    basePrice: 'basePrice',
    currency: 'currency',
    discount: 'discount',
    quantity: 'quantity',
    stock: 'stock',
    organizationId: 'organizationId',
    rating: 'rating',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    rating: 'rating',
    comment: 'comment',
    productId: 'productId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ServiceListScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceListScalarFieldEnum = (typeof ServiceListScalarFieldEnum)[keyof typeof ServiceListScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    slug: 'slug',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SiteSettingScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    description: 'description',
    title: 'title',
    bannerText: 'bannerText',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SiteSettingScalarFieldEnum = (typeof SiteSettingScalarFieldEnum)[keyof typeof SiteSettingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SubDomainScalarFieldEnum: {
    subdomain: 'subdomain',
    isValid: 'isValid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubDomainScalarFieldEnum = (typeof SubDomainScalarFieldEnum)[keyof typeof SubDomainScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    username: 'username',
    email: 'email',
    emailVerified: 'emailVerified',
    hashedPassword: 'hashedPassword',
    dialCode: 'dialCode',
    phone: 'phone',
    termsAccepted: 'termsAccepted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    publicName: 'publicName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refresh_token?: StringNullableFilter | string | null
    access_token?: StringNullableFilter | string | null
    expires_at?: IntNullableFilter | number | null
    token_type?: StringNullableFilter | string | null
    scope?: StringNullableFilter | string | null
    id_token?: StringNullableFilter | string | null
    session_state?: StringNullableFilter | string | null
    oauth_token_secret?: StringNullableFilter | string | null
    oauth_token?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
    user?: UserOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountWhereUniqueInput = {
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    provider?: StringWithAggregatesFilter | string
    providerAccountId?: StringWithAggregatesFilter | string
    refresh_token?: StringNullableWithAggregatesFilter | string | null
    access_token?: StringNullableWithAggregatesFilter | string | null
    expires_at?: IntNullableWithAggregatesFilter | number | null
    token_type?: StringNullableWithAggregatesFilter | string | null
    scope?: StringNullableWithAggregatesFilter | string | null
    id_token?: StringNullableWithAggregatesFilter | string | null
    session_state?: StringNullableWithAggregatesFilter | string | null
    oauth_token_secret?: StringNullableWithAggregatesFilter | string | null
    oauth_token?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SessionWhereInput = {
    AND?: Enumerable<SessionWhereInput>
    OR?: Enumerable<SessionWhereInput>
    NOT?: Enumerable<SessionWhereInput>
    id?: StringFilter | string
    sessionToken?: StringFilter | string
    userId?: StringFilter | string
    expires?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionWhereUniqueInput = {
    id?: string
    sessionToken?: string
    userId?: string
  }

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SessionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    sessionToken?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    expires?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    username?: StringNullableFilter | string | null
    email?: StringFilter | string
    emailVerified?: BoolFilter | boolean
    hashedPassword?: StringNullableFilter | string | null
    dialCode?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    address?: AddressListRelationFilter
    termsAccepted?: BoolFilter | boolean
    imageUser?: ImageUserListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    reviews?: ReviewListRelationFilter
    memberships?: MembershipListRelationFilter
    orders?: OrderListRelationFilter
    driver?: XOR<DriverRelationFilter, DriverWhereInput> | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    hashedPassword?: SortOrder
    dialCode?: SortOrder
    phone?: SortOrder
    address?: AddressOrderByRelationAggregateInput
    termsAccepted?: SortOrder
    imageUser?: ImageUserOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    memberships?: MembershipOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    driver?: DriverOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: string
    username?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    hashedPassword?: SortOrder
    dialCode?: SortOrder
    phone?: SortOrder
    termsAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    username?: StringNullableWithAggregatesFilter | string | null
    email?: StringWithAggregatesFilter | string
    emailVerified?: BoolWithAggregatesFilter | boolean
    hashedPassword?: StringNullableWithAggregatesFilter | string | null
    dialCode?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    termsAccepted?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DriverWhereInput = {
    AND?: Enumerable<DriverWhereInput>
    OR?: Enumerable<DriverWhereInput>
    NOT?: Enumerable<DriverWhereInput>
    id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DriverOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverWhereUniqueInput = {
    id?: string
  }

  export type DriverOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DriverCountOrderByAggregateInput
    _max?: DriverMaxOrderByAggregateInput
    _min?: DriverMinOrderByAggregateInput
  }

  export type DriverScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DriverScalarWhereWithAggregatesInput>
    OR?: Enumerable<DriverScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DriverScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VendorWhereInput = {
    AND?: Enumerable<VendorWhereInput>
    OR?: Enumerable<VendorWhereInput>
    NOT?: Enumerable<VendorWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    publicName?: StringFilter | string
    organizations?: OrganizationListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    publicName?: SortOrder
    organizations?: OrganizationOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorWhereUniqueInput = {
    id?: string
  }

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    publicName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VendorScalarWhereWithAggregatesInput>
    OR?: Enumerable<VendorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VendorScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    publicName?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    id?: StringFilter | string
    street1?: StringFilter | string
    street2?: StringNullableFilter | string | null
    city?: StringFilter | string
    state?: StringFilter | string
    zipcode?: StringFilter | string
    country?: StringFilter | string
    countryCode?: StringNullableFilter | string | null
    coordinateId?: StringNullableFilter | string | null
    coordinates?: XOR<CoordinatesRelationFilter, CoordinatesWhereInput> | null
    userId?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    organizationId?: StringNullableFilter | string | null
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput> | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    coordinateId?: SortOrder
    coordinates?: CoordinatesOrderByWithRelationInput
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressWhereUniqueInput = {
    id?: string
    organizationId?: string
  }

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    coordinateId?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<AddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AddressScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    street1?: StringWithAggregatesFilter | string
    street2?: StringNullableWithAggregatesFilter | string | null
    city?: StringWithAggregatesFilter | string
    state?: StringWithAggregatesFilter | string
    zipcode?: StringWithAggregatesFilter | string
    country?: StringWithAggregatesFilter | string
    countryCode?: StringNullableWithAggregatesFilter | string | null
    coordinateId?: StringNullableWithAggregatesFilter | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
    organizationId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ImageOrganizationWhereInput = {
    AND?: Enumerable<ImageOrganizationWhereInput>
    OR?: Enumerable<ImageOrganizationWhereInput>
    NOT?: Enumerable<ImageOrganizationWhereInput>
    id?: StringFilter | string
    location?: StringFilter | string
    organizationId?: StringFilter | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    blurhash?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ImageOrganizationOrderByWithRelationInput = {
    id?: SortOrder
    location?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageOrganizationWhereUniqueInput = {
    id?: string
  }

  export type ImageOrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    location?: SortOrder
    organizationId?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImageOrganizationCountOrderByAggregateInput
    _max?: ImageOrganizationMaxOrderByAggregateInput
    _min?: ImageOrganizationMinOrderByAggregateInput
  }

  export type ImageOrganizationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ImageOrganizationScalarWhereWithAggregatesInput>
    OR?: Enumerable<ImageOrganizationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ImageOrganizationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    location?: StringWithAggregatesFilter | string
    organizationId?: StringWithAggregatesFilter | string
    blurhash?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ImageProductWhereInput = {
    AND?: Enumerable<ImageProductWhereInput>
    OR?: Enumerable<ImageProductWhereInput>
    NOT?: Enumerable<ImageProductWhereInput>
    id?: StringFilter | string
    location?: StringFilter | string
    productId?: StringFilter | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    blurhash?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ImageProductOrderByWithRelationInput = {
    id?: SortOrder
    location?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageProductWhereUniqueInput = {
    id?: string
  }

  export type ImageProductOrderByWithAggregationInput = {
    id?: SortOrder
    location?: SortOrder
    productId?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImageProductCountOrderByAggregateInput
    _max?: ImageProductMaxOrderByAggregateInput
    _min?: ImageProductMinOrderByAggregateInput
  }

  export type ImageProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ImageProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ImageProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ImageProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    location?: StringWithAggregatesFilter | string
    productId?: StringWithAggregatesFilter | string
    blurhash?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ImageUserWhereInput = {
    AND?: Enumerable<ImageUserWhereInput>
    OR?: Enumerable<ImageUserWhereInput>
    NOT?: Enumerable<ImageUserWhereInput>
    id?: StringFilter | string
    location?: StringFilter | string
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    blurhash?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ImageUserOrderByWithRelationInput = {
    id?: SortOrder
    location?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageUserWhereUniqueInput = {
    id?: string
  }

  export type ImageUserOrderByWithAggregationInput = {
    id?: SortOrder
    location?: SortOrder
    userId?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImageUserCountOrderByAggregateInput
    _max?: ImageUserMaxOrderByAggregateInput
    _min?: ImageUserMinOrderByAggregateInput
  }

  export type ImageUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ImageUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<ImageUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ImageUserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    location?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    blurhash?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ImageVendorWhereInput = {
    AND?: Enumerable<ImageVendorWhereInput>
    OR?: Enumerable<ImageVendorWhereInput>
    NOT?: Enumerable<ImageVendorWhereInput>
    id?: StringFilter | string
    location?: StringFilter | string
    blurhash?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ImageVendorOrderByWithRelationInput = {
    id?: SortOrder
    location?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageVendorWhereUniqueInput = {
    id?: string
  }

  export type ImageVendorOrderByWithAggregationInput = {
    id?: SortOrder
    location?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImageVendorCountOrderByAggregateInput
    _max?: ImageVendorMaxOrderByAggregateInput
    _min?: ImageVendorMinOrderByAggregateInput
  }

  export type ImageVendorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ImageVendorScalarWhereWithAggregatesInput>
    OR?: Enumerable<ImageVendorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ImageVendorScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    location?: StringWithAggregatesFilter | string
    blurhash?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CoordinatesWhereInput = {
    AND?: Enumerable<CoordinatesWhereInput>
    OR?: Enumerable<CoordinatesWhereInput>
    NOT?: Enumerable<CoordinatesWhereInput>
    id?: StringFilter | string
    latitude?: FloatFilter | number
    longitude?: FloatFilter | number
    radius?: FloatNullableFilter | number | null
    addresses?: AddressListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CoordinatesOrderByWithRelationInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    radius?: SortOrder
    addresses?: AddressOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoordinatesWhereUniqueInput = {
    id?: string
  }

  export type CoordinatesOrderByWithAggregationInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    radius?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoordinatesCountOrderByAggregateInput
    _avg?: CoordinatesAvgOrderByAggregateInput
    _max?: CoordinatesMaxOrderByAggregateInput
    _min?: CoordinatesMinOrderByAggregateInput
    _sum?: CoordinatesSumOrderByAggregateInput
  }

  export type CoordinatesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CoordinatesScalarWhereWithAggregatesInput>
    OR?: Enumerable<CoordinatesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CoordinatesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    latitude?: FloatWithAggregatesFilter | number
    longitude?: FloatWithAggregatesFilter | number
    radius?: FloatNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MembershipWhereInput = {
    AND?: Enumerable<MembershipWhereInput>
    OR?: Enumerable<MembershipWhereInput>
    NOT?: Enumerable<MembershipWhereInput>
    id?: StringFilter | string
    role?: EnumMembershipRoleFilter | MembershipRole
    organizations?: OrganizationMembershipListRelationFilter
    userId?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MembershipOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    organizations?: organizationMembershipOrderByRelationAggregateInput
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipWhereUniqueInput = {
    id?: string
  }

  export type MembershipOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MembershipCountOrderByAggregateInput
    _max?: MembershipMaxOrderByAggregateInput
    _min?: MembershipMinOrderByAggregateInput
  }

  export type MembershipScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MembershipScalarWhereWithAggregatesInput>
    OR?: Enumerable<MembershipScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MembershipScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    role?: EnumMembershipRoleWithAggregatesFilter | MembershipRole
    userId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrderWhereInput = {
    AND?: Enumerable<OrderWhereInput>
    OR?: Enumerable<OrderWhereInput>
    NOT?: Enumerable<OrderWhereInput>
    id?: StringFilter | string
    total?: IntFilter | number
    status?: EnumOrderStatusFilter | OrderStatus
    items?: ProductListRelationFilter
    customerId?: StringFilter | string
    customer?: XOR<UserRelationFilter, UserWhereInput>
    driverId?: StringNullableFilter | string | null
    driver?: XOR<DriverRelationFilter, DriverWhereInput> | null
    organizationId?: StringFilter | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    total?: SortOrder
    status?: SortOrder
    items?: ProductOrderByRelationAggregateInput
    customerId?: SortOrder
    customer?: UserOrderByWithRelationInput
    driverId?: SortOrder
    driver?: DriverOrderByWithRelationInput
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderWhereUniqueInput = {
    id?: string
  }

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    total?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    driverId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    total?: IntWithAggregatesFilter | number
    status?: EnumOrderStatusWithAggregatesFilter | OrderStatus
    customerId?: StringWithAggregatesFilter | string
    driverId?: StringNullableWithAggregatesFilter | string | null
    organizationId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PaymentWhereInput = {
    AND?: Enumerable<PaymentWhereInput>
    OR?: Enumerable<PaymentWhereInput>
    NOT?: Enumerable<PaymentWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentWhereUniqueInput = {
    id?: string
  }

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: Enumerable<OrganizationWhereInput>
    OR?: Enumerable<OrganizationWhereInput>
    NOT?: Enumerable<OrganizationWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    address?: XOR<AddressRelationFilter, AddressWhereInput> | null
    email?: StringFilter | string
    emailVerified?: BoolFilter | boolean
    dialCode?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    images?: ImageOrganizationListRelationFilter
    memberships?: OrganizationMembershipListRelationFilter
    products?: ProductListRelationFilter
    vendorId?: StringFilter | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    subdomainId?: StringFilter | string
    termsAccepted?: BoolFilter | boolean
    subdomain?: XOR<SubDomainRelationFilter, SubDomainWhereInput>
    siteSetting?: XOR<SiteSettingRelationFilter, SiteSettingWhereInput> | null
    orders?: OrderListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: AddressOrderByWithRelationInput
    email?: SortOrder
    emailVerified?: SortOrder
    dialCode?: SortOrder
    phone?: SortOrder
    images?: ImageOrganizationOrderByRelationAggregateInput
    memberships?: organizationMembershipOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    vendorId?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    subdomainId?: SortOrder
    termsAccepted?: SortOrder
    subdomain?: SubDomainOrderByWithRelationInput
    siteSetting?: SiteSettingOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    dialCode?: SortOrder
    phone?: SortOrder
    vendorId?: SortOrder
    subdomainId?: SortOrder
    termsAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrganizationScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrganizationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrganizationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    emailVerified?: BoolWithAggregatesFilter | boolean
    dialCode?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    vendorId?: StringWithAggregatesFilter | string
    subdomainId?: StringWithAggregatesFilter | string
    termsAccepted?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type organizationMembershipWhereInput = {
    AND?: Enumerable<organizationMembershipWhereInput>
    OR?: Enumerable<organizationMembershipWhereInput>
    NOT?: Enumerable<organizationMembershipWhereInput>
    organizationId?: StringFilter | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    membershipId?: StringFilter | string
    membership?: XOR<MembershipRelationFilter, MembershipWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type organizationMembershipOrderByWithRelationInput = {
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    membershipId?: SortOrder
    membership?: MembershipOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type organizationMembershipWhereUniqueInput = {
    organizationId_membershipId?: organizationMembershipOrganizationIdMembershipIdCompoundUniqueInput
  }

  export type organizationMembershipOrderByWithAggregationInput = {
    organizationId?: SortOrder
    membershipId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: organizationMembershipCountOrderByAggregateInput
    _max?: organizationMembershipMaxOrderByAggregateInput
    _min?: organizationMembershipMinOrderByAggregateInput
  }

  export type organizationMembershipScalarWhereWithAggregatesInput = {
    AND?: Enumerable<organizationMembershipScalarWhereWithAggregatesInput>
    OR?: Enumerable<organizationMembershipScalarWhereWithAggregatesInput>
    NOT?: Enumerable<organizationMembershipScalarWhereWithAggregatesInput>
    organizationId?: StringWithAggregatesFilter | string
    membershipId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    features?: StringNullableFilter | string | null
    categories?: CategoryListRelationFilter
    unit?: EnumUnitFilter | Unit
    size?: FloatFilter | number
    basePrice?: IntFilter | number
    currency?: EnumCurrencyFilter | Currency
    discount?: IntFilter | number
    quantity?: IntFilter | number
    stock?: IntFilter | number
    images?: ImageProductListRelationFilter
    organizationId?: StringFilter | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    orders?: OrderListRelationFilter
    reviews?: ReviewListRelationFilter
    rating?: FloatNullableFilter | number | null
    tags?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    features?: SortOrder
    categories?: CategoryOrderByRelationAggregateInput
    unit?: SortOrder
    size?: SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    discount?: SortOrder
    quantity?: SortOrder
    stock?: SortOrder
    images?: ImageProductOrderByRelationAggregateInput
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    rating?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductWhereUniqueInput = {
    id?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    features?: SortOrder
    unit?: SortOrder
    size?: SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    discount?: SortOrder
    quantity?: SortOrder
    stock?: SortOrder
    organizationId?: SortOrder
    rating?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    features?: StringNullableWithAggregatesFilter | string | null
    unit?: EnumUnitWithAggregatesFilter | Unit
    size?: FloatWithAggregatesFilter | number
    basePrice?: IntWithAggregatesFilter | number
    currency?: EnumCurrencyWithAggregatesFilter | Currency
    discount?: IntWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
    stock?: IntWithAggregatesFilter | number
    organizationId?: StringWithAggregatesFilter | string
    rating?: FloatNullableWithAggregatesFilter | number | null
    tags?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CategoryWhereInput = {
    AND?: Enumerable<CategoryWhereInput>
    OR?: Enumerable<CategoryWhereInput>
    NOT?: Enumerable<CategoryWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    icon?: StringFilter | string
    products?: ProductListRelationFilter
    categoryLists?: CategoryListListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    categoryLists?: CategoryListOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryWhereUniqueInput = {
    id?: string
    slug?: string
  }

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    icon?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CategoryListWhereInput = {
    AND?: Enumerable<CategoryListWhereInput>
    OR?: Enumerable<CategoryListWhereInput>
    NOT?: Enumerable<CategoryListWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    categories?: CategoryListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CategoryListOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    categories?: CategoryOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryListWhereUniqueInput = {
    id?: string
    slug?: string
  }

  export type CategoryListOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryListCountOrderByAggregateInput
    _max?: CategoryListMaxOrderByAggregateInput
    _min?: CategoryListMinOrderByAggregateInput
  }

  export type CategoryListScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryListScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryListScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryListScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ServiceListWhereInput = {
    AND?: Enumerable<ServiceListWhereInput>
    OR?: Enumerable<ServiceListWhereInput>
    NOT?: Enumerable<ServiceListWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    services?: ServiceListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ServiceListOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceListWhereUniqueInput = {
    id?: string
    slug?: string
  }

  export type ServiceListOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceListCountOrderByAggregateInput
    _max?: ServiceListMaxOrderByAggregateInput
    _min?: ServiceListMinOrderByAggregateInput
  }

  export type ServiceListScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceListScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceListScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceListScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ServiceWhereInput = {
    AND?: Enumerable<ServiceWhereInput>
    OR?: Enumerable<ServiceWhereInput>
    NOT?: Enumerable<ServiceWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    subtitle?: StringNullableFilter | string | null
    slug?: StringFilter | string
    icon?: StringFilter | string
    serviceLists?: ServiceListListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    serviceLists?: ServiceListOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceWhereUniqueInput = {
    id?: string
    slug?: string
  }

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    subtitle?: StringNullableWithAggregatesFilter | string | null
    slug?: StringWithAggregatesFilter | string
    icon?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ReviewWhereInput = {
    AND?: Enumerable<ReviewWhereInput>
    OR?: Enumerable<ReviewWhereInput>
    NOT?: Enumerable<ReviewWhereInput>
    id?: StringFilter | string
    rating?: IntFilter | number
    comment?: StringNullableFilter | string | null
    productId?: StringFilter | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewWhereUniqueInput = {
    id?: string
    productId?: string
  }

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReviewScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    rating?: IntWithAggregatesFilter | number
    comment?: StringNullableWithAggregatesFilter | string | null
    productId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SiteSettingWhereInput = {
    AND?: Enumerable<SiteSettingWhereInput>
    OR?: Enumerable<SiteSettingWhereInput>
    NOT?: Enumerable<SiteSettingWhereInput>
    id?: StringFilter | string
    organizationId?: StringFilter | string
    description?: StringNullableFilter | string | null
    title?: StringFilter | string
    bannerText?: StringNullableFilter | string | null
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SiteSettingOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    description?: SortOrder
    title?: SortOrder
    bannerText?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingWhereUniqueInput = {
    id?: string
    organizationId?: string
    id_organizationId?: SiteSettingIdOrganizationIdCompoundUniqueInput
  }

  export type SiteSettingOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    description?: SortOrder
    title?: SortOrder
    bannerText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SiteSettingCountOrderByAggregateInput
    _max?: SiteSettingMaxOrderByAggregateInput
    _min?: SiteSettingMinOrderByAggregateInput
  }

  export type SiteSettingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SiteSettingScalarWhereWithAggregatesInput>
    OR?: Enumerable<SiteSettingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SiteSettingScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    organizationId?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    title?: StringWithAggregatesFilter | string
    bannerText?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubDomainWhereInput = {
    AND?: Enumerable<SubDomainWhereInput>
    OR?: Enumerable<SubDomainWhereInput>
    NOT?: Enumerable<SubDomainWhereInput>
    subdomain?: StringFilter | string
    organization?: OrganizationListRelationFilter
    isValid?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SubDomainOrderByWithRelationInput = {
    subdomain?: SortOrder
    organization?: OrganizationOrderByRelationAggregateInput
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubDomainWhereUniqueInput = {
    subdomain?: string
  }

  export type SubDomainOrderByWithAggregationInput = {
    subdomain?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubDomainCountOrderByAggregateInput
    _max?: SubDomainMaxOrderByAggregateInput
    _min?: SubDomainMinOrderByAggregateInput
  }

  export type SubDomainScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubDomainScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubDomainScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubDomainScalarWhereWithAggregatesInput>
    subdomain?: StringWithAggregatesFilter | string
    isValid?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    imageUser?: ImageUserCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    memberships?: MembershipCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    driver?: DriverCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    imageUser?: ImageUserUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    driver?: DriverUncheckedCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    driver?: DriverUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    driver?: DriverUncheckedUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    termsAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateInput = {
    user: UserCreateNestedOneWithoutDriverInput
    orders?: OrderCreateNestedManyWithoutDriverInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverUncheckedCreateInput = {
    id: string
    orders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverUpdateInput = {
    user?: UserUpdateOneRequiredWithoutDriverNestedInput
    orders?: OrderUpdateManyWithoutDriverNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    id?: string
    name: string
    publicName: string
    organizations?: OrganizationCreateNestedManyWithoutVendorInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUncheckedCreateInput = {
    id?: string
    name: string
    publicName: string
    organizations?: OrganizationUncheckedCreateNestedManyWithoutVendorInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicName?: StringFieldUpdateOperationsInput | string
    organizations?: OrganizationUpdateManyWithoutVendorNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicName?: StringFieldUpdateOperationsInput | string
    organizations?: OrganizationUncheckedUpdateManyWithoutVendorNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateManyInput = {
    id?: string
    name: string
    publicName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    id?: string
    street1: string
    street2?: string | null
    city: string
    state: string
    zipcode: string
    country: string
    countryCode?: string | null
    coordinates?: CoordinatesCreateNestedOneWithoutAddressesInput
    user?: UserCreateNestedOneWithoutAddressInput
    organization?: OrganizationCreateNestedOneWithoutAddressInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    street1: string
    street2?: string | null
    city: string
    state: string
    zipcode: string
    country: string
    countryCode?: string | null
    coordinateId?: string | null
    userId?: string | null
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: CoordinatesUpdateOneWithoutAddressesNestedInput
    user?: UserUpdateOneWithoutAddressNestedInput
    organization?: OrganizationUpdateOneWithoutAddressNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    coordinateId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyInput = {
    id?: string
    street1: string
    street2?: string | null
    city: string
    state: string
    zipcode: string
    country: string
    countryCode?: string | null
    coordinateId?: string | null
    userId?: string | null
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    coordinateId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageOrganizationCreateInput = {
    id?: string
    location: string
    organization: OrganizationCreateNestedOneWithoutImagesInput
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageOrganizationUncheckedCreateInput = {
    id?: string
    location: string
    organizationId: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageOrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutImagesNestedInput
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageOrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageOrganizationCreateManyInput = {
    id?: string
    location: string
    organizationId: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageOrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageOrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageProductCreateInput = {
    id?: string
    location: string
    product: ProductCreateNestedOneWithoutImagesInput
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageProductUncheckedCreateInput = {
    id?: string
    location: string
    productId: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutImagesNestedInput
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageProductCreateManyInput = {
    id?: string
    location: string
    productId: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUserCreateInput = {
    id?: string
    location: string
    user: UserCreateNestedOneWithoutImageUserInput
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUserUncheckedCreateInput = {
    id?: string
    location: string
    userId: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutImageUserNestedInput
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUserCreateManyInput = {
    id?: string
    location: string
    userId: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageVendorCreateInput = {
    id?: string
    location: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageVendorUncheckedCreateInput = {
    id?: string
    location: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageVendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageVendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageVendorCreateManyInput = {
    id?: string
    location: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageVendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageVendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoordinatesCreateInput = {
    id?: string
    latitude: number
    longitude: number
    radius?: number | null
    addresses?: AddressCreateNestedManyWithoutCoordinatesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoordinatesUncheckedCreateInput = {
    id?: string
    latitude: number
    longitude: number
    radius?: number | null
    addresses?: AddressUncheckedCreateNestedManyWithoutCoordinatesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoordinatesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    addresses?: AddressUpdateManyWithoutCoordinatesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoordinatesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    addresses?: AddressUncheckedUpdateManyWithoutCoordinatesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoordinatesCreateManyInput = {
    id?: string
    latitude: number
    longitude: number
    radius?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoordinatesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoordinatesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipCreateInput = {
    id?: string
    role: MembershipRole
    organizations?: organizationMembershipCreateNestedManyWithoutMembershipInput
    user?: UserCreateNestedOneWithoutMembershipsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUncheckedCreateInput = {
    id?: string
    role: MembershipRole
    organizations?: organizationMembershipUncheckedCreateNestedManyWithoutMembershipInput
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | MembershipRole
    organizations?: organizationMembershipUpdateManyWithoutMembershipNestedInput
    user?: UserUpdateOneWithoutMembershipsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | MembershipRole
    organizations?: organizationMembershipUncheckedUpdateManyWithoutMembershipNestedInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipCreateManyInput = {
    id?: string
    role: MembershipRole
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | MembershipRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | MembershipRole
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    total: number
    status?: OrderStatus
    items?: ProductCreateNestedManyWithoutOrdersInput
    customer: UserCreateNestedOneWithoutOrdersInput
    driver?: DriverCreateNestedOneWithoutOrdersInput
    organization: OrganizationCreateNestedOneWithoutOrdersInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    total: number
    status?: OrderStatus
    items?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    customerId: string
    driverId?: string | null
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    items?: ProductUpdateManyWithoutOrdersNestedInput
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    driver?: DriverUpdateOneWithoutOrdersNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutOrdersNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    items?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    customerId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyInput = {
    id?: string
    total: number
    status?: OrderStatus
    customerId: string
    driverId?: string | null
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    customerId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    address?: AddressCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationCreateNestedManyWithoutOrganizationInput
    memberships?: organizationMembershipCreateNestedManyWithoutOrganizationInput
    products?: ProductCreateNestedManyWithoutOrganizationInput
    vendor: VendorCreateNestedOneWithoutOrganizationsInput
    termsAccepted?: boolean
    subdomain: SubDomainCreateNestedOneWithoutOrganizationInput
    siteSetting?: SiteSettingCreateNestedOneWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    address?: AddressUncheckedCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    memberships?: organizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganizationInput
    vendorId: string
    subdomainId: string
    termsAccepted?: boolean
    siteSetting?: SiteSettingUncheckedCreateNestedOneWithoutOrganizationInput
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUpdateManyWithoutOrganizationNestedInput
    memberships?: organizationMembershipUpdateManyWithoutOrganizationNestedInput
    products?: ProductUpdateManyWithoutOrganizationNestedInput
    vendor?: VendorUpdateOneRequiredWithoutOrganizationsNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    subdomain?: SubDomainUpdateOneRequiredWithoutOrganizationNestedInput
    siteSetting?: SiteSettingUpdateOneWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    memberships?: organizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganizationNestedInput
    vendorId?: StringFieldUpdateOperationsInput | string
    subdomainId?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    siteSetting?: SiteSettingUncheckedUpdateOneWithoutOrganizationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    vendorId: string
    subdomainId: string
    termsAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: StringFieldUpdateOperationsInput | string
    subdomainId?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationMembershipCreateInput = {
    organization: OrganizationCreateNestedOneWithoutMembershipsInput
    membership: MembershipCreateNestedOneWithoutOrganizationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationMembershipUncheckedCreateInput = {
    organizationId: string
    membershipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationMembershipUpdateInput = {
    organization?: OrganizationUpdateOneRequiredWithoutMembershipsNestedInput
    membership?: MembershipUpdateOneRequiredWithoutOrganizationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationMembershipUncheckedUpdateInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    membershipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationMembershipCreateManyInput = {
    organizationId: string
    membershipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationMembershipUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationMembershipUncheckedUpdateManyInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    membershipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    features?: string | null
    categories?: CategoryCreateNestedManyWithoutProductsInput
    unit?: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    images?: ImageProductCreateNestedManyWithoutProductInput
    organization: OrganizationCreateNestedOneWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutItemsInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    rating?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    features?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    unit?: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    images?: ImageProductUncheckedCreateNestedManyWithoutProductInput
    organizationId: string
    orders?: OrderUncheckedCreateNestedManyWithoutItemsInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    rating?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    images?: ImageProductUpdateManyWithoutProductNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutItemsNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    images?: ImageProductUncheckedUpdateManyWithoutProductNestedInput
    organizationId?: StringFieldUpdateOperationsInput | string
    orders?: OrderUncheckedUpdateManyWithoutItemsNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    features?: string | null
    unit?: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    organizationId: string
    rating?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    organizationId?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    icon: string
    products?: ProductCreateNestedManyWithoutCategoriesInput
    categoryLists?: CategoryListCreateNestedManyWithoutCategoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    icon: string
    products?: ProductUncheckedCreateNestedManyWithoutCategoriesInput
    categoryLists?: CategoryListUncheckedCreateNestedManyWithoutCategoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutCategoriesNestedInput
    categoryLists?: CategoryListUpdateManyWithoutCategoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutCategoriesNestedInput
    categoryLists?: CategoryListUncheckedUpdateManyWithoutCategoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    icon: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryListCreateInput = {
    id?: string
    name: string
    slug: string
    categories?: CategoryCreateNestedManyWithoutCategoryListsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryListUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    categories?: CategoryUncheckedCreateNestedManyWithoutCategoryListsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    categories?: CategoryUpdateManyWithoutCategoryListsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    categories?: CategoryUncheckedUpdateManyWithoutCategoryListsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryListCreateManyInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceListCreateInput = {
    id?: string
    name: string
    slug: string
    services?: ServiceCreateNestedManyWithoutServiceListsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceListUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    services?: ServiceUncheckedCreateNestedManyWithoutServiceListsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    services?: ServiceUpdateManyWithoutServiceListsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    services?: ServiceUncheckedUpdateManyWithoutServiceListsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceListCreateManyInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    icon: string
    serviceLists?: ServiceListCreateNestedManyWithoutServicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    icon: string
    serviceLists?: ServiceListUncheckedCreateNestedManyWithoutServicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    serviceLists?: ServiceListUpdateManyWithoutServicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    serviceLists?: ServiceListUncheckedUpdateManyWithoutServicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    icon: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    product: ProductCreateNestedOneWithoutReviewsInput
    user: UserCreateNestedOneWithoutReviewsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    productId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    rating: number
    comment?: string | null
    productId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingCreateInput = {
    id: string
    description?: string | null
    title: string
    bannerText?: string | null
    organization: OrganizationCreateNestedOneWithoutSiteSettingInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteSettingUncheckedCreateInput = {
    id: string
    organizationId: string
    description?: string | null
    title: string
    bannerText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneRequiredWithoutSiteSettingNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingCreateManyInput = {
    id: string
    organizationId: string
    description?: string | null
    title: string
    bannerText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubDomainCreateInput = {
    subdomain: string
    organization?: OrganizationCreateNestedManyWithoutSubdomainInput
    isValid: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubDomainUncheckedCreateInput = {
    subdomain: string
    organization?: OrganizationUncheckedCreateNestedManyWithoutSubdomainInput
    isValid: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubDomainUpdateInput = {
    subdomain?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateManyWithoutSubdomainNestedInput
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubDomainUncheckedUpdateInput = {
    subdomain?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUncheckedUpdateManyWithoutSubdomainNestedInput
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubDomainCreateManyInput = {
    subdomain: string
    isValid: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubDomainUpdateManyMutationInput = {
    subdomain?: StringFieldUpdateOperationsInput | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubDomainUncheckedUpdateManyInput = {
    subdomain?: StringFieldUpdateOperationsInput | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type ImageUserListRelationFilter = {
    every?: ImageUserWhereInput
    some?: ImageUserWhereInput
    none?: ImageUserWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type MembershipListRelationFilter = {
    every?: MembershipWhereInput
    some?: MembershipWhereInput
    none?: MembershipWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type DriverRelationFilter = {
    is?: DriverWhereInput | null
    isNot?: DriverWhereInput | null
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    hashedPassword?: SortOrder
    dialCode?: SortOrder
    phone?: SortOrder
    termsAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    hashedPassword?: SortOrder
    dialCode?: SortOrder
    phone?: SortOrder
    termsAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    hashedPassword?: SortOrder
    dialCode?: SortOrder
    phone?: SortOrder
    termsAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DriverCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationListRelationFilter = {
    every?: OrganizationWhereInput
    some?: OrganizationWhereInput
    none?: OrganizationWhereInput
  }

  export type OrganizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    publicName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    publicName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    publicName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoordinatesRelationFilter = {
    is?: CoordinatesWhereInput | null
    isNot?: CoordinatesWhereInput | null
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    coordinateId?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    coordinateId?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    coordinateId?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageOrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    organizationId?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageOrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    organizationId?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageOrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    organizationId?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ImageProductCountOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    productId?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageProductMaxOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    productId?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageProductMinOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    productId?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageUserCountOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    userId?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageUserMaxOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    userId?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageUserMinOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    userId?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageVendorCountOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageVendorMaxOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageVendorMinOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    blurhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type CoordinatesCountOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    radius?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoordinatesAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    radius?: SortOrder
  }

  export type CoordinatesMaxOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    radius?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoordinatesMinOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    radius?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoordinatesSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    radius?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type EnumMembershipRoleFilter = {
    equals?: MembershipRole
    in?: Enumerable<MembershipRole>
    notIn?: Enumerable<MembershipRole>
    not?: NestedEnumMembershipRoleFilter | MembershipRole
  }

  export type OrganizationMembershipListRelationFilter = {
    every?: organizationMembershipWhereInput
    some?: organizationMembershipWhereInput
    none?: organizationMembershipWhereInput
  }

  export type organizationMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MembershipCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMembershipRoleWithAggregatesFilter = {
    equals?: MembershipRole
    in?: Enumerable<MembershipRole>
    notIn?: Enumerable<MembershipRole>
    not?: NestedEnumMembershipRoleWithAggregatesFilter | MembershipRole
    _count?: NestedIntFilter
    _min?: NestedEnumMembershipRoleFilter
    _max?: NestedEnumMembershipRoleFilter
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type EnumOrderStatusFilter = {
    equals?: OrderStatus
    in?: Enumerable<OrderStatus>
    notIn?: Enumerable<OrderStatus>
    not?: NestedEnumOrderStatusFilter | OrderStatus
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    driverId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    driverId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    driverId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type EnumOrderStatusWithAggregatesFilter = {
    equals?: OrderStatus
    in?: Enumerable<OrderStatus>
    notIn?: Enumerable<OrderStatus>
    not?: NestedEnumOrderStatusWithAggregatesFilter | OrderStatus
    _count?: NestedIntFilter
    _min?: NestedEnumOrderStatusFilter
    _max?: NestedEnumOrderStatusFilter
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type ImageOrganizationListRelationFilter = {
    every?: ImageOrganizationWhereInput
    some?: ImageOrganizationWhereInput
    none?: ImageOrganizationWhereInput
  }

  export type VendorRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type SubDomainRelationFilter = {
    is?: SubDomainWhereInput
    isNot?: SubDomainWhereInput
  }

  export type SiteSettingRelationFilter = {
    is?: SiteSettingWhereInput | null
    isNot?: SiteSettingWhereInput | null
  }

  export type ImageOrganizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    dialCode?: SortOrder
    phone?: SortOrder
    vendorId?: SortOrder
    subdomainId?: SortOrder
    termsAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    dialCode?: SortOrder
    phone?: SortOrder
    vendorId?: SortOrder
    subdomainId?: SortOrder
    termsAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    dialCode?: SortOrder
    phone?: SortOrder
    vendorId?: SortOrder
    subdomainId?: SortOrder
    termsAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipRelationFilter = {
    is?: MembershipWhereInput
    isNot?: MembershipWhereInput
  }

  export type organizationMembershipOrganizationIdMembershipIdCompoundUniqueInput = {
    organizationId: string
    membershipId: string
  }

  export type organizationMembershipCountOrderByAggregateInput = {
    organizationId?: SortOrder
    membershipId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type organizationMembershipMaxOrderByAggregateInput = {
    organizationId?: SortOrder
    membershipId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type organizationMembershipMinOrderByAggregateInput = {
    organizationId?: SortOrder
    membershipId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type EnumUnitFilter = {
    equals?: Unit
    in?: Enumerable<Unit>
    notIn?: Enumerable<Unit>
    not?: NestedEnumUnitFilter | Unit
  }

  export type EnumCurrencyFilter = {
    equals?: Currency
    in?: Enumerable<Currency>
    notIn?: Enumerable<Currency>
    not?: NestedEnumCurrencyFilter | Currency
  }

  export type ImageProductListRelationFilter = {
    every?: ImageProductWhereInput
    some?: ImageProductWhereInput
    none?: ImageProductWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    features?: SortOrder
    unit?: SortOrder
    size?: SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    discount?: SortOrder
    quantity?: SortOrder
    stock?: SortOrder
    organizationId?: SortOrder
    rating?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    size?: SortOrder
    basePrice?: SortOrder
    discount?: SortOrder
    quantity?: SortOrder
    stock?: SortOrder
    rating?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    features?: SortOrder
    unit?: SortOrder
    size?: SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    discount?: SortOrder
    quantity?: SortOrder
    stock?: SortOrder
    organizationId?: SortOrder
    rating?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    features?: SortOrder
    unit?: SortOrder
    size?: SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    discount?: SortOrder
    quantity?: SortOrder
    stock?: SortOrder
    organizationId?: SortOrder
    rating?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    size?: SortOrder
    basePrice?: SortOrder
    discount?: SortOrder
    quantity?: SortOrder
    stock?: SortOrder
    rating?: SortOrder
  }

  export type EnumUnitWithAggregatesFilter = {
    equals?: Unit
    in?: Enumerable<Unit>
    notIn?: Enumerable<Unit>
    not?: NestedEnumUnitWithAggregatesFilter | Unit
    _count?: NestedIntFilter
    _min?: NestedEnumUnitFilter
    _max?: NestedEnumUnitFilter
  }

  export type EnumCurrencyWithAggregatesFilter = {
    equals?: Currency
    in?: Enumerable<Currency>
    notIn?: Enumerable<Currency>
    not?: NestedEnumCurrencyWithAggregatesFilter | Currency
    _count?: NestedIntFilter
    _min?: NestedEnumCurrencyFilter
    _max?: NestedEnumCurrencyFilter
  }

  export type CategoryListListRelationFilter = {
    every?: CategoryListWhereInput
    some?: CategoryListWhereInput
    none?: CategoryListWhereInput
  }

  export type CategoryListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryListCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryListMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryListMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceListCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceListMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceListMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceListListRelationFilter = {
    every?: ServiceListWhereInput
    some?: ServiceListWhereInput
    none?: ServiceListWhereInput
  }

  export type ServiceListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type SiteSettingIdOrganizationIdCompoundUniqueInput = {
    id: string
    organizationId: string
  }

  export type SiteSettingCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    description?: SortOrder
    title?: SortOrder
    bannerText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    description?: SortOrder
    title?: SortOrder
    bannerText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    description?: SortOrder
    title?: SortOrder
    bannerText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubDomainCountOrderByAggregateInput = {
    subdomain?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubDomainMaxOrderByAggregateInput = {
    subdomain?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubDomainMinOrderByAggregateInput = {
    subdomain?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AddressCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AddressCreateWithoutUserInput>, Enumerable<AddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutUserInput>
    createMany?: AddressCreateManyUserInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type ImageUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ImageUserCreateWithoutUserInput>, Enumerable<ImageUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageUserCreateOrConnectWithoutUserInput>
    createMany?: ImageUserCreateManyUserInputEnvelope
    connect?: Enumerable<ImageUserWhereUniqueInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutUserInput>, Enumerable<ReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutUserInput>
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type MembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<MembershipCreateWithoutUserInput>, Enumerable<MembershipUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MembershipCreateOrConnectWithoutUserInput>
    createMany?: MembershipCreateManyUserInputEnvelope
    connect?: Enumerable<MembershipWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCustomerInput>, Enumerable<OrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCustomerInput>
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type DriverCreateNestedOneWithoutUserInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    connect?: DriverWhereUniqueInput
  }

  export type AddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AddressCreateWithoutUserInput>, Enumerable<AddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutUserInput>
    createMany?: AddressCreateManyUserInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type ImageUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ImageUserCreateWithoutUserInput>, Enumerable<ImageUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageUserCreateOrConnectWithoutUserInput>
    createMany?: ImageUserCreateManyUserInputEnvelope
    connect?: Enumerable<ImageUserWhereUniqueInput>
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutUserInput>, Enumerable<ReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutUserInput>
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type MembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<MembershipCreateWithoutUserInput>, Enumerable<MembershipUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MembershipCreateOrConnectWithoutUserInput>
    createMany?: MembershipCreateManyUserInputEnvelope
    connect?: Enumerable<MembershipWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCustomerInput>, Enumerable<OrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCustomerInput>
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type DriverUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    connect?: DriverWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AddressUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AddressCreateWithoutUserInput>, Enumerable<AddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AddressCreateManyUserInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type ImageUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ImageUserCreateWithoutUserInput>, Enumerable<ImageUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ImageUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ImageUserCreateManyUserInputEnvelope
    set?: Enumerable<ImageUserWhereUniqueInput>
    disconnect?: Enumerable<ImageUserWhereUniqueInput>
    delete?: Enumerable<ImageUserWhereUniqueInput>
    connect?: Enumerable<ImageUserWhereUniqueInput>
    update?: Enumerable<ImageUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ImageUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ImageUserScalarWhereInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    connect?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutUserInput>, Enumerable<ReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type MembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<MembershipCreateWithoutUserInput>, Enumerable<MembershipUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MembershipCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<MembershipUpsertWithWhereUniqueWithoutUserInput>
    createMany?: MembershipCreateManyUserInputEnvelope
    set?: Enumerable<MembershipWhereUniqueInput>
    disconnect?: Enumerable<MembershipWhereUniqueInput>
    delete?: Enumerable<MembershipWhereUniqueInput>
    connect?: Enumerable<MembershipWhereUniqueInput>
    update?: Enumerable<MembershipUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<MembershipUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<MembershipScalarWhereInput>
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCustomerInput>, Enumerable<OrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type DriverUpdateOneWithoutUserNestedInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    upsert?: DriverUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<DriverUpdateWithoutUserInput, DriverUncheckedUpdateWithoutUserInput>
  }

  export type AddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AddressCreateWithoutUserInput>, Enumerable<AddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AddressCreateManyUserInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type ImageUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ImageUserCreateWithoutUserInput>, Enumerable<ImageUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ImageUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ImageUserCreateManyUserInputEnvelope
    set?: Enumerable<ImageUserWhereUniqueInput>
    disconnect?: Enumerable<ImageUserWhereUniqueInput>
    delete?: Enumerable<ImageUserWhereUniqueInput>
    connect?: Enumerable<ImageUserWhereUniqueInput>
    update?: Enumerable<ImageUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ImageUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ImageUserScalarWhereInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    connect?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutUserInput>, Enumerable<ReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type MembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<MembershipCreateWithoutUserInput>, Enumerable<MembershipUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MembershipCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<MembershipUpsertWithWhereUniqueWithoutUserInput>
    createMany?: MembershipCreateManyUserInputEnvelope
    set?: Enumerable<MembershipWhereUniqueInput>
    disconnect?: Enumerable<MembershipWhereUniqueInput>
    delete?: Enumerable<MembershipWhereUniqueInput>
    connect?: Enumerable<MembershipWhereUniqueInput>
    update?: Enumerable<MembershipUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<MembershipUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<MembershipScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCustomerInput>, Enumerable<OrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type DriverUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    upsert?: DriverUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<DriverUpdateWithoutUserInput, DriverUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutDriverInput = {
    create?: XOR<UserCreateWithoutDriverInput, UserUncheckedCreateWithoutDriverInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriverInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutDriverInput = {
    create?: XOR<Enumerable<OrderCreateWithoutDriverInput>, Enumerable<OrderUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutDriverInput>
    createMany?: OrderCreateManyDriverInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<Enumerable<OrderCreateWithoutDriverInput>, Enumerable<OrderUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutDriverInput>
    createMany?: OrderCreateManyDriverInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutDriverNestedInput = {
    create?: XOR<UserCreateWithoutDriverInput, UserUncheckedCreateWithoutDriverInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriverInput
    upsert?: UserUpsertWithoutDriverInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDriverInput, UserUncheckedUpdateWithoutDriverInput>
  }

  export type OrderUpdateManyWithoutDriverNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutDriverInput>, Enumerable<OrderUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutDriverInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutDriverInput>
    createMany?: OrderCreateManyDriverInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutDriverInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutDriverInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutDriverInput>, Enumerable<OrderUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutDriverInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutDriverInput>
    createMany?: OrderCreateManyDriverInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutDriverInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutDriverInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrganizationCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<OrganizationCreateWithoutVendorInput>, Enumerable<OrganizationUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<OrganizationCreateOrConnectWithoutVendorInput>
    createMany?: OrganizationCreateManyVendorInputEnvelope
    connect?: Enumerable<OrganizationWhereUniqueInput>
  }

  export type OrganizationUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<OrganizationCreateWithoutVendorInput>, Enumerable<OrganizationUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<OrganizationCreateOrConnectWithoutVendorInput>
    createMany?: OrganizationCreateManyVendorInputEnvelope
    connect?: Enumerable<OrganizationWhereUniqueInput>
  }

  export type OrganizationUpdateManyWithoutVendorNestedInput = {
    create?: XOR<Enumerable<OrganizationCreateWithoutVendorInput>, Enumerable<OrganizationUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<OrganizationCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<OrganizationUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: OrganizationCreateManyVendorInputEnvelope
    set?: Enumerable<OrganizationWhereUniqueInput>
    disconnect?: Enumerable<OrganizationWhereUniqueInput>
    delete?: Enumerable<OrganizationWhereUniqueInput>
    connect?: Enumerable<OrganizationWhereUniqueInput>
    update?: Enumerable<OrganizationUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<OrganizationUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<OrganizationScalarWhereInput>
  }

  export type OrganizationUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<Enumerable<OrganizationCreateWithoutVendorInput>, Enumerable<OrganizationUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<OrganizationCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<OrganizationUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: OrganizationCreateManyVendorInputEnvelope
    set?: Enumerable<OrganizationWhereUniqueInput>
    disconnect?: Enumerable<OrganizationWhereUniqueInput>
    delete?: Enumerable<OrganizationWhereUniqueInput>
    connect?: Enumerable<OrganizationWhereUniqueInput>
    update?: Enumerable<OrganizationUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<OrganizationUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<OrganizationScalarWhereInput>
  }

  export type CoordinatesCreateNestedOneWithoutAddressesInput = {
    create?: XOR<CoordinatesCreateWithoutAddressesInput, CoordinatesUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CoordinatesCreateOrConnectWithoutAddressesInput
    connect?: CoordinatesWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAddressInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutAddressInput = {
    create?: XOR<OrganizationCreateWithoutAddressInput, OrganizationUncheckedCreateWithoutAddressInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAddressInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CoordinatesUpdateOneWithoutAddressesNestedInput = {
    create?: XOR<CoordinatesCreateWithoutAddressesInput, CoordinatesUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CoordinatesCreateOrConnectWithoutAddressesInput
    upsert?: CoordinatesUpsertWithoutAddressesInput
    disconnect?: boolean
    delete?: boolean
    connect?: CoordinatesWhereUniqueInput
    update?: XOR<CoordinatesUpdateWithoutAddressesInput, CoordinatesUncheckedUpdateWithoutAddressesInput>
  }

  export type UserUpdateOneWithoutAddressNestedInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    upsert?: UserUpsertWithoutAddressInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
  }

  export type OrganizationUpdateOneWithoutAddressNestedInput = {
    create?: XOR<OrganizationCreateWithoutAddressInput, OrganizationUncheckedCreateWithoutAddressInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAddressInput
    upsert?: OrganizationUpsertWithoutAddressInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutAddressInput, OrganizationUncheckedUpdateWithoutAddressInput>
  }

  export type OrganizationCreateNestedOneWithoutImagesInput = {
    create?: XOR<OrganizationCreateWithoutImagesInput, OrganizationUncheckedCreateWithoutImagesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutImagesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<OrganizationCreateWithoutImagesInput, OrganizationUncheckedCreateWithoutImagesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutImagesInput
    upsert?: OrganizationUpsertWithoutImagesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutImagesInput, OrganizationUncheckedUpdateWithoutImagesInput>
  }

  export type ProductCreateNestedOneWithoutImagesInput = {
    create?: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImagesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImagesInput
    upsert?: ProductUpsertWithoutImagesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutImagesInput, ProductUncheckedUpdateWithoutImagesInput>
  }

  export type UserCreateNestedOneWithoutImageUserInput = {
    create?: XOR<UserCreateWithoutImageUserInput, UserUncheckedCreateWithoutImageUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutImageUserNestedInput = {
    create?: XOR<UserCreateWithoutImageUserInput, UserUncheckedCreateWithoutImageUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageUserInput
    upsert?: UserUpsertWithoutImageUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutImageUserInput, UserUncheckedUpdateWithoutImageUserInput>
  }

  export type AddressCreateNestedManyWithoutCoordinatesInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCoordinatesInput>, Enumerable<AddressUncheckedCreateWithoutCoordinatesInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCoordinatesInput>
    createMany?: AddressCreateManyCoordinatesInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedManyWithoutCoordinatesInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCoordinatesInput>, Enumerable<AddressUncheckedCreateWithoutCoordinatesInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCoordinatesInput>
    createMany?: AddressCreateManyCoordinatesInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AddressUpdateManyWithoutCoordinatesNestedInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCoordinatesInput>, Enumerable<AddressUncheckedCreateWithoutCoordinatesInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCoordinatesInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutCoordinatesInput>
    createMany?: AddressCreateManyCoordinatesInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutCoordinatesInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutCoordinatesInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type AddressUncheckedUpdateManyWithoutCoordinatesNestedInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCoordinatesInput>, Enumerable<AddressUncheckedCreateWithoutCoordinatesInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCoordinatesInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutCoordinatesInput>
    createMany?: AddressCreateManyCoordinatesInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutCoordinatesInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutCoordinatesInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type organizationMembershipCreateNestedManyWithoutMembershipInput = {
    create?: XOR<Enumerable<organizationMembershipCreateWithoutMembershipInput>, Enumerable<organizationMembershipUncheckedCreateWithoutMembershipInput>>
    connectOrCreate?: Enumerable<organizationMembershipCreateOrConnectWithoutMembershipInput>
    createMany?: organizationMembershipCreateManyMembershipInputEnvelope
    connect?: Enumerable<organizationMembershipWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type organizationMembershipUncheckedCreateNestedManyWithoutMembershipInput = {
    create?: XOR<Enumerable<organizationMembershipCreateWithoutMembershipInput>, Enumerable<organizationMembershipUncheckedCreateWithoutMembershipInput>>
    connectOrCreate?: Enumerable<organizationMembershipCreateOrConnectWithoutMembershipInput>
    createMany?: organizationMembershipCreateManyMembershipInputEnvelope
    connect?: Enumerable<organizationMembershipWhereUniqueInput>
  }

  export type EnumMembershipRoleFieldUpdateOperationsInput = {
    set?: MembershipRole
  }

  export type organizationMembershipUpdateManyWithoutMembershipNestedInput = {
    create?: XOR<Enumerable<organizationMembershipCreateWithoutMembershipInput>, Enumerable<organizationMembershipUncheckedCreateWithoutMembershipInput>>
    connectOrCreate?: Enumerable<organizationMembershipCreateOrConnectWithoutMembershipInput>
    upsert?: Enumerable<organizationMembershipUpsertWithWhereUniqueWithoutMembershipInput>
    createMany?: organizationMembershipCreateManyMembershipInputEnvelope
    set?: Enumerable<organizationMembershipWhereUniqueInput>
    disconnect?: Enumerable<organizationMembershipWhereUniqueInput>
    delete?: Enumerable<organizationMembershipWhereUniqueInput>
    connect?: Enumerable<organizationMembershipWhereUniqueInput>
    update?: Enumerable<organizationMembershipUpdateWithWhereUniqueWithoutMembershipInput>
    updateMany?: Enumerable<organizationMembershipUpdateManyWithWhereWithoutMembershipInput>
    deleteMany?: Enumerable<organizationMembershipScalarWhereInput>
  }

  export type UserUpdateOneWithoutMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    upsert?: UserUpsertWithoutMembershipsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type organizationMembershipUncheckedUpdateManyWithoutMembershipNestedInput = {
    create?: XOR<Enumerable<organizationMembershipCreateWithoutMembershipInput>, Enumerable<organizationMembershipUncheckedCreateWithoutMembershipInput>>
    connectOrCreate?: Enumerable<organizationMembershipCreateOrConnectWithoutMembershipInput>
    upsert?: Enumerable<organizationMembershipUpsertWithWhereUniqueWithoutMembershipInput>
    createMany?: organizationMembershipCreateManyMembershipInputEnvelope
    set?: Enumerable<organizationMembershipWhereUniqueInput>
    disconnect?: Enumerable<organizationMembershipWhereUniqueInput>
    delete?: Enumerable<organizationMembershipWhereUniqueInput>
    connect?: Enumerable<organizationMembershipWhereUniqueInput>
    update?: Enumerable<organizationMembershipUpdateWithWhereUniqueWithoutMembershipInput>
    updateMany?: Enumerable<organizationMembershipUpdateManyWithWhereWithoutMembershipInput>
    deleteMany?: Enumerable<organizationMembershipScalarWhereInput>
  }

  export type ProductCreateNestedManyWithoutOrdersInput = {
    create?: XOR<Enumerable<ProductCreateWithoutOrdersInput>, Enumerable<ProductUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutOrdersInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type DriverCreateNestedOneWithoutOrdersInput = {
    create?: XOR<DriverCreateWithoutOrdersInput, DriverUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: DriverCreateOrConnectWithoutOrdersInput
    connect?: DriverWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutOrdersInput = {
    create?: XOR<OrganizationCreateWithoutOrdersInput, OrganizationUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrdersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<Enumerable<ProductCreateWithoutOrdersInput>, Enumerable<ProductUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutOrdersInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: OrderStatus
  }

  export type ProductUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutOrdersInput>, Enumerable<ProductUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutOrdersInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutOrdersInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutOrdersInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutOrdersInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type DriverUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<DriverCreateWithoutOrdersInput, DriverUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: DriverCreateOrConnectWithoutOrdersInput
    upsert?: DriverUpsertWithoutOrdersInput
    disconnect?: boolean
    delete?: boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<DriverUpdateWithoutOrdersInput, DriverUncheckedUpdateWithoutOrdersInput>
  }

  export type OrganizationUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<OrganizationCreateWithoutOrdersInput, OrganizationUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrdersInput
    upsert?: OrganizationUpsertWithoutOrdersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutOrdersInput, OrganizationUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutOrdersInput>, Enumerable<ProductUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutOrdersInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutOrdersInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutOrdersInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutOrdersInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type AddressCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<AddressCreateWithoutOrganizationInput, AddressUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: AddressCreateOrConnectWithoutOrganizationInput
    connect?: AddressWhereUniqueInput
  }

  export type ImageOrganizationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<ImageOrganizationCreateWithoutOrganizationInput>, Enumerable<ImageOrganizationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ImageOrganizationCreateOrConnectWithoutOrganizationInput>
    createMany?: ImageOrganizationCreateManyOrganizationInputEnvelope
    connect?: Enumerable<ImageOrganizationWhereUniqueInput>
  }

  export type organizationMembershipCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<organizationMembershipCreateWithoutOrganizationInput>, Enumerable<organizationMembershipUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<organizationMembershipCreateOrConnectWithoutOrganizationInput>
    createMany?: organizationMembershipCreateManyOrganizationInputEnvelope
    connect?: Enumerable<organizationMembershipWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<ProductCreateWithoutOrganizationInput>, Enumerable<ProductUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutOrganizationInput>
    createMany?: ProductCreateManyOrganizationInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type VendorCreateNestedOneWithoutOrganizationsInput = {
    create?: XOR<VendorCreateWithoutOrganizationsInput, VendorUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutOrganizationsInput
    connect?: VendorWhereUniqueInput
  }

  export type SubDomainCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<SubDomainCreateWithoutOrganizationInput, SubDomainUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: SubDomainCreateOrConnectWithoutOrganizationInput
    connect?: SubDomainWhereUniqueInput
  }

  export type SiteSettingCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<SiteSettingCreateWithoutOrganizationInput, SiteSettingUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: SiteSettingCreateOrConnectWithoutOrganizationInput
    connect?: SiteSettingWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<OrderCreateWithoutOrganizationInput>, Enumerable<OrderUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutOrganizationInput>
    createMany?: OrderCreateManyOrganizationInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<AddressCreateWithoutOrganizationInput, AddressUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: AddressCreateOrConnectWithoutOrganizationInput
    connect?: AddressWhereUniqueInput
  }

  export type ImageOrganizationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<ImageOrganizationCreateWithoutOrganizationInput>, Enumerable<ImageOrganizationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ImageOrganizationCreateOrConnectWithoutOrganizationInput>
    createMany?: ImageOrganizationCreateManyOrganizationInputEnvelope
    connect?: Enumerable<ImageOrganizationWhereUniqueInput>
  }

  export type organizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<organizationMembershipCreateWithoutOrganizationInput>, Enumerable<organizationMembershipUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<organizationMembershipCreateOrConnectWithoutOrganizationInput>
    createMany?: organizationMembershipCreateManyOrganizationInputEnvelope
    connect?: Enumerable<organizationMembershipWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<ProductCreateWithoutOrganizationInput>, Enumerable<ProductUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutOrganizationInput>
    createMany?: ProductCreateManyOrganizationInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type SiteSettingUncheckedCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<SiteSettingCreateWithoutOrganizationInput, SiteSettingUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: SiteSettingCreateOrConnectWithoutOrganizationInput
    connect?: SiteSettingWhereUniqueInput
  }

  export type OrderUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<OrderCreateWithoutOrganizationInput>, Enumerable<OrderUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutOrganizationInput>
    createMany?: OrderCreateManyOrganizationInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type AddressUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<AddressCreateWithoutOrganizationInput, AddressUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: AddressCreateOrConnectWithoutOrganizationInput
    upsert?: AddressUpsertWithoutOrganizationInput
    disconnect?: boolean
    delete?: boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<AddressUpdateWithoutOrganizationInput, AddressUncheckedUpdateWithoutOrganizationInput>
  }

  export type ImageOrganizationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<ImageOrganizationCreateWithoutOrganizationInput>, Enumerable<ImageOrganizationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ImageOrganizationCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<ImageOrganizationUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: ImageOrganizationCreateManyOrganizationInputEnvelope
    set?: Enumerable<ImageOrganizationWhereUniqueInput>
    disconnect?: Enumerable<ImageOrganizationWhereUniqueInput>
    delete?: Enumerable<ImageOrganizationWhereUniqueInput>
    connect?: Enumerable<ImageOrganizationWhereUniqueInput>
    update?: Enumerable<ImageOrganizationUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<ImageOrganizationUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<ImageOrganizationScalarWhereInput>
  }

  export type organizationMembershipUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<organizationMembershipCreateWithoutOrganizationInput>, Enumerable<organizationMembershipUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<organizationMembershipCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<organizationMembershipUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: organizationMembershipCreateManyOrganizationInputEnvelope
    set?: Enumerable<organizationMembershipWhereUniqueInput>
    disconnect?: Enumerable<organizationMembershipWhereUniqueInput>
    delete?: Enumerable<organizationMembershipWhereUniqueInput>
    connect?: Enumerable<organizationMembershipWhereUniqueInput>
    update?: Enumerable<organizationMembershipUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<organizationMembershipUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<organizationMembershipScalarWhereInput>
  }

  export type ProductUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutOrganizationInput>, Enumerable<ProductUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: ProductCreateManyOrganizationInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type VendorUpdateOneRequiredWithoutOrganizationsNestedInput = {
    create?: XOR<VendorCreateWithoutOrganizationsInput, VendorUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutOrganizationsInput
    upsert?: VendorUpsertWithoutOrganizationsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<VendorUpdateWithoutOrganizationsInput, VendorUncheckedUpdateWithoutOrganizationsInput>
  }

  export type SubDomainUpdateOneRequiredWithoutOrganizationNestedInput = {
    create?: XOR<SubDomainCreateWithoutOrganizationInput, SubDomainUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: SubDomainCreateOrConnectWithoutOrganizationInput
    upsert?: SubDomainUpsertWithoutOrganizationInput
    connect?: SubDomainWhereUniqueInput
    update?: XOR<SubDomainUpdateWithoutOrganizationInput, SubDomainUncheckedUpdateWithoutOrganizationInput>
  }

  export type SiteSettingUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<SiteSettingCreateWithoutOrganizationInput, SiteSettingUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: SiteSettingCreateOrConnectWithoutOrganizationInput
    upsert?: SiteSettingUpsertWithoutOrganizationInput
    disconnect?: boolean
    delete?: boolean
    connect?: SiteSettingWhereUniqueInput
    update?: XOR<SiteSettingUpdateWithoutOrganizationInput, SiteSettingUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrderUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutOrganizationInput>, Enumerable<OrderUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: OrderCreateManyOrganizationInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type AddressUncheckedUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<AddressCreateWithoutOrganizationInput, AddressUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: AddressCreateOrConnectWithoutOrganizationInput
    upsert?: AddressUpsertWithoutOrganizationInput
    disconnect?: boolean
    delete?: boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<AddressUpdateWithoutOrganizationInput, AddressUncheckedUpdateWithoutOrganizationInput>
  }

  export type ImageOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<ImageOrganizationCreateWithoutOrganizationInput>, Enumerable<ImageOrganizationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ImageOrganizationCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<ImageOrganizationUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: ImageOrganizationCreateManyOrganizationInputEnvelope
    set?: Enumerable<ImageOrganizationWhereUniqueInput>
    disconnect?: Enumerable<ImageOrganizationWhereUniqueInput>
    delete?: Enumerable<ImageOrganizationWhereUniqueInput>
    connect?: Enumerable<ImageOrganizationWhereUniqueInput>
    update?: Enumerable<ImageOrganizationUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<ImageOrganizationUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<ImageOrganizationScalarWhereInput>
  }

  export type organizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<organizationMembershipCreateWithoutOrganizationInput>, Enumerable<organizationMembershipUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<organizationMembershipCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<organizationMembershipUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: organizationMembershipCreateManyOrganizationInputEnvelope
    set?: Enumerable<organizationMembershipWhereUniqueInput>
    disconnect?: Enumerable<organizationMembershipWhereUniqueInput>
    delete?: Enumerable<organizationMembershipWhereUniqueInput>
    connect?: Enumerable<organizationMembershipWhereUniqueInput>
    update?: Enumerable<organizationMembershipUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<organizationMembershipUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<organizationMembershipScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutOrganizationInput>, Enumerable<ProductUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: ProductCreateManyOrganizationInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type SiteSettingUncheckedUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<SiteSettingCreateWithoutOrganizationInput, SiteSettingUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: SiteSettingCreateOrConnectWithoutOrganizationInput
    upsert?: SiteSettingUpsertWithoutOrganizationInput
    disconnect?: boolean
    delete?: boolean
    connect?: SiteSettingWhereUniqueInput
    update?: XOR<SiteSettingUpdateWithoutOrganizationInput, SiteSettingUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrderUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutOrganizationInput>, Enumerable<OrderUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: OrderCreateManyOrganizationInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrganizationCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<OrganizationCreateWithoutMembershipsInput, OrganizationUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembershipsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type MembershipCreateNestedOneWithoutOrganizationsInput = {
    create?: XOR<MembershipCreateWithoutOrganizationsInput, MembershipUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: MembershipCreateOrConnectWithoutOrganizationsInput
    connect?: MembershipWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembershipsInput, OrganizationUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembershipsInput
    upsert?: OrganizationUpsertWithoutMembershipsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutMembershipsInput, OrganizationUncheckedUpdateWithoutMembershipsInput>
  }

  export type MembershipUpdateOneRequiredWithoutOrganizationsNestedInput = {
    create?: XOR<MembershipCreateWithoutOrganizationsInput, MembershipUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: MembershipCreateOrConnectWithoutOrganizationsInput
    upsert?: MembershipUpsertWithoutOrganizationsInput
    connect?: MembershipWhereUniqueInput
    update?: XOR<MembershipUpdateWithoutOrganizationsInput, MembershipUncheckedUpdateWithoutOrganizationsInput>
  }

  export type CategoryCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutProductsInput>, Enumerable<CategoryUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type ImageProductCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ImageProductCreateWithoutProductInput>, Enumerable<ImageProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ImageProductCreateOrConnectWithoutProductInput>
    createMany?: ImageProductCreateManyProductInputEnvelope
    connect?: Enumerable<ImageProductWhereUniqueInput>
  }

  export type OrganizationCreateNestedOneWithoutProductsInput = {
    create?: XOR<OrganizationCreateWithoutProductsInput, OrganizationUncheckedCreateWithoutProductsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProductsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutItemsInput = {
    create?: XOR<Enumerable<OrderCreateWithoutItemsInput>, Enumerable<OrderUncheckedCreateWithoutItemsInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutItemsInput>
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type ReviewCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutProductInput>, Enumerable<ReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutProductInput>
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type CategoryUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutProductsInput>, Enumerable<CategoryUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type ImageProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ImageProductCreateWithoutProductInput>, Enumerable<ImageProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ImageProductCreateOrConnectWithoutProductInput>
    createMany?: ImageProductCreateManyProductInputEnvelope
    connect?: Enumerable<ImageProductWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutItemsInput = {
    create?: XOR<Enumerable<OrderCreateWithoutItemsInput>, Enumerable<OrderUncheckedCreateWithoutItemsInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutItemsInput>
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type ReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutProductInput>, Enumerable<ReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutProductInput>
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type CategoryUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutProductsInput>, Enumerable<CategoryUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type EnumUnitFieldUpdateOperationsInput = {
    set?: Unit
  }

  export type EnumCurrencyFieldUpdateOperationsInput = {
    set?: Currency
  }

  export type ImageProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ImageProductCreateWithoutProductInput>, Enumerable<ImageProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ImageProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ImageProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ImageProductCreateManyProductInputEnvelope
    set?: Enumerable<ImageProductWhereUniqueInput>
    disconnect?: Enumerable<ImageProductWhereUniqueInput>
    delete?: Enumerable<ImageProductWhereUniqueInput>
    connect?: Enumerable<ImageProductWhereUniqueInput>
    update?: Enumerable<ImageProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ImageProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ImageProductScalarWhereInput>
  }

  export type OrganizationUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<OrganizationCreateWithoutProductsInput, OrganizationUncheckedCreateWithoutProductsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProductsInput
    upsert?: OrganizationUpsertWithoutProductsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutProductsInput, OrganizationUncheckedUpdateWithoutProductsInput>
  }

  export type OrderUpdateManyWithoutItemsNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutItemsInput>, Enumerable<OrderUncheckedCreateWithoutItemsInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutItemsInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutItemsInput>
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutItemsInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutItemsInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type ReviewUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutProductInput>, Enumerable<ReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type CategoryUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutProductsInput>, Enumerable<CategoryUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type ImageProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ImageProductCreateWithoutProductInput>, Enumerable<ImageProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ImageProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ImageProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ImageProductCreateManyProductInputEnvelope
    set?: Enumerable<ImageProductWhereUniqueInput>
    disconnect?: Enumerable<ImageProductWhereUniqueInput>
    delete?: Enumerable<ImageProductWhereUniqueInput>
    connect?: Enumerable<ImageProductWhereUniqueInput>
    update?: Enumerable<ImageProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ImageProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ImageProductScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutItemsNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutItemsInput>, Enumerable<OrderUncheckedCreateWithoutItemsInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutItemsInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutItemsInput>
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutItemsInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutItemsInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type ReviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutProductInput>, Enumerable<ReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type ProductCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCategoriesInput>, Enumerable<ProductUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCategoriesInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type CategoryListCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<Enumerable<CategoryListCreateWithoutCategoriesInput>, Enumerable<CategoryListUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<CategoryListCreateOrConnectWithoutCategoriesInput>
    connect?: Enumerable<CategoryListWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCategoriesInput>, Enumerable<ProductUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCategoriesInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type CategoryListUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<Enumerable<CategoryListCreateWithoutCategoriesInput>, Enumerable<CategoryListUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<CategoryListCreateOrConnectWithoutCategoriesInput>
    connect?: Enumerable<CategoryListWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCategoriesInput>, Enumerable<ProductUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCategoriesInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutCategoriesInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutCategoriesInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutCategoriesInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type CategoryListUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<Enumerable<CategoryListCreateWithoutCategoriesInput>, Enumerable<CategoryListUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<CategoryListCreateOrConnectWithoutCategoriesInput>
    upsert?: Enumerable<CategoryListUpsertWithWhereUniqueWithoutCategoriesInput>
    set?: Enumerable<CategoryListWhereUniqueInput>
    disconnect?: Enumerable<CategoryListWhereUniqueInput>
    delete?: Enumerable<CategoryListWhereUniqueInput>
    connect?: Enumerable<CategoryListWhereUniqueInput>
    update?: Enumerable<CategoryListUpdateWithWhereUniqueWithoutCategoriesInput>
    updateMany?: Enumerable<CategoryListUpdateManyWithWhereWithoutCategoriesInput>
    deleteMany?: Enumerable<CategoryListScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCategoriesInput>, Enumerable<ProductUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCategoriesInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutCategoriesInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutCategoriesInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutCategoriesInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type CategoryListUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<Enumerable<CategoryListCreateWithoutCategoriesInput>, Enumerable<CategoryListUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<CategoryListCreateOrConnectWithoutCategoriesInput>
    upsert?: Enumerable<CategoryListUpsertWithWhereUniqueWithoutCategoriesInput>
    set?: Enumerable<CategoryListWhereUniqueInput>
    disconnect?: Enumerable<CategoryListWhereUniqueInput>
    delete?: Enumerable<CategoryListWhereUniqueInput>
    connect?: Enumerable<CategoryListWhereUniqueInput>
    update?: Enumerable<CategoryListUpdateWithWhereUniqueWithoutCategoriesInput>
    updateMany?: Enumerable<CategoryListUpdateManyWithWhereWithoutCategoriesInput>
    deleteMany?: Enumerable<CategoryListScalarWhereInput>
  }

  export type CategoryCreateNestedManyWithoutCategoryListsInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutCategoryListsInput>, Enumerable<CategoryUncheckedCreateWithoutCategoryListsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutCategoryListsInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type CategoryUncheckedCreateNestedManyWithoutCategoryListsInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutCategoryListsInput>, Enumerable<CategoryUncheckedCreateWithoutCategoryListsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutCategoryListsInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type CategoryUpdateManyWithoutCategoryListsNestedInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutCategoryListsInput>, Enumerable<CategoryUncheckedCreateWithoutCategoryListsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutCategoryListsInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutCategoryListsInput>
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutCategoryListsInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutCategoryListsInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type CategoryUncheckedUpdateManyWithoutCategoryListsNestedInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutCategoryListsInput>, Enumerable<CategoryUncheckedCreateWithoutCategoryListsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutCategoryListsInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutCategoryListsInput>
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutCategoryListsInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutCategoryListsInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type ServiceCreateNestedManyWithoutServiceListsInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutServiceListsInput>, Enumerable<ServiceUncheckedCreateWithoutServiceListsInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutServiceListsInput>
    connect?: Enumerable<ServiceWhereUniqueInput>
  }

  export type ServiceUncheckedCreateNestedManyWithoutServiceListsInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutServiceListsInput>, Enumerable<ServiceUncheckedCreateWithoutServiceListsInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutServiceListsInput>
    connect?: Enumerable<ServiceWhereUniqueInput>
  }

  export type ServiceUpdateManyWithoutServiceListsNestedInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutServiceListsInput>, Enumerable<ServiceUncheckedCreateWithoutServiceListsInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutServiceListsInput>
    upsert?: Enumerable<ServiceUpsertWithWhereUniqueWithoutServiceListsInput>
    set?: Enumerable<ServiceWhereUniqueInput>
    disconnect?: Enumerable<ServiceWhereUniqueInput>
    delete?: Enumerable<ServiceWhereUniqueInput>
    connect?: Enumerable<ServiceWhereUniqueInput>
    update?: Enumerable<ServiceUpdateWithWhereUniqueWithoutServiceListsInput>
    updateMany?: Enumerable<ServiceUpdateManyWithWhereWithoutServiceListsInput>
    deleteMany?: Enumerable<ServiceScalarWhereInput>
  }

  export type ServiceUncheckedUpdateManyWithoutServiceListsNestedInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutServiceListsInput>, Enumerable<ServiceUncheckedCreateWithoutServiceListsInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutServiceListsInput>
    upsert?: Enumerable<ServiceUpsertWithWhereUniqueWithoutServiceListsInput>
    set?: Enumerable<ServiceWhereUniqueInput>
    disconnect?: Enumerable<ServiceWhereUniqueInput>
    delete?: Enumerable<ServiceWhereUniqueInput>
    connect?: Enumerable<ServiceWhereUniqueInput>
    update?: Enumerable<ServiceUpdateWithWhereUniqueWithoutServiceListsInput>
    updateMany?: Enumerable<ServiceUpdateManyWithWhereWithoutServiceListsInput>
    deleteMany?: Enumerable<ServiceScalarWhereInput>
  }

  export type ServiceListCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<ServiceListCreateWithoutServicesInput>, Enumerable<ServiceListUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<ServiceListCreateOrConnectWithoutServicesInput>
    connect?: Enumerable<ServiceListWhereUniqueInput>
  }

  export type ServiceListUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<ServiceListCreateWithoutServicesInput>, Enumerable<ServiceListUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<ServiceListCreateOrConnectWithoutServicesInput>
    connect?: Enumerable<ServiceListWhereUniqueInput>
  }

  export type ServiceListUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<ServiceListCreateWithoutServicesInput>, Enumerable<ServiceListUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<ServiceListCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<ServiceListUpsertWithWhereUniqueWithoutServicesInput>
    set?: Enumerable<ServiceListWhereUniqueInput>
    disconnect?: Enumerable<ServiceListWhereUniqueInput>
    delete?: Enumerable<ServiceListWhereUniqueInput>
    connect?: Enumerable<ServiceListWhereUniqueInput>
    update?: Enumerable<ServiceListUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<ServiceListUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<ServiceListScalarWhereInput>
  }

  export type ServiceListUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<ServiceListCreateWithoutServicesInput>, Enumerable<ServiceListUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<ServiceListCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<ServiceListUpsertWithWhereUniqueWithoutServicesInput>
    set?: Enumerable<ServiceListWhereUniqueInput>
    disconnect?: Enumerable<ServiceListWhereUniqueInput>
    delete?: Enumerable<ServiceListWhereUniqueInput>
    connect?: Enumerable<ServiceListWhereUniqueInput>
    update?: Enumerable<ServiceListUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<ServiceListUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<ServiceListScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    upsert?: ProductUpsertWithoutReviewsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type OrganizationCreateNestedOneWithoutSiteSettingInput = {
    create?: XOR<OrganizationCreateWithoutSiteSettingInput, OrganizationUncheckedCreateWithoutSiteSettingInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSiteSettingInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutSiteSettingNestedInput = {
    create?: XOR<OrganizationCreateWithoutSiteSettingInput, OrganizationUncheckedCreateWithoutSiteSettingInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSiteSettingInput
    upsert?: OrganizationUpsertWithoutSiteSettingInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutSiteSettingInput, OrganizationUncheckedUpdateWithoutSiteSettingInput>
  }

  export type OrganizationCreateNestedManyWithoutSubdomainInput = {
    create?: XOR<Enumerable<OrganizationCreateWithoutSubdomainInput>, Enumerable<OrganizationUncheckedCreateWithoutSubdomainInput>>
    connectOrCreate?: Enumerable<OrganizationCreateOrConnectWithoutSubdomainInput>
    createMany?: OrganizationCreateManySubdomainInputEnvelope
    connect?: Enumerable<OrganizationWhereUniqueInput>
  }

  export type OrganizationUncheckedCreateNestedManyWithoutSubdomainInput = {
    create?: XOR<Enumerable<OrganizationCreateWithoutSubdomainInput>, Enumerable<OrganizationUncheckedCreateWithoutSubdomainInput>>
    connectOrCreate?: Enumerable<OrganizationCreateOrConnectWithoutSubdomainInput>
    createMany?: OrganizationCreateManySubdomainInputEnvelope
    connect?: Enumerable<OrganizationWhereUniqueInput>
  }

  export type OrganizationUpdateManyWithoutSubdomainNestedInput = {
    create?: XOR<Enumerable<OrganizationCreateWithoutSubdomainInput>, Enumerable<OrganizationUncheckedCreateWithoutSubdomainInput>>
    connectOrCreate?: Enumerable<OrganizationCreateOrConnectWithoutSubdomainInput>
    upsert?: Enumerable<OrganizationUpsertWithWhereUniqueWithoutSubdomainInput>
    createMany?: OrganizationCreateManySubdomainInputEnvelope
    set?: Enumerable<OrganizationWhereUniqueInput>
    disconnect?: Enumerable<OrganizationWhereUniqueInput>
    delete?: Enumerable<OrganizationWhereUniqueInput>
    connect?: Enumerable<OrganizationWhereUniqueInput>
    update?: Enumerable<OrganizationUpdateWithWhereUniqueWithoutSubdomainInput>
    updateMany?: Enumerable<OrganizationUpdateManyWithWhereWithoutSubdomainInput>
    deleteMany?: Enumerable<OrganizationScalarWhereInput>
  }

  export type OrganizationUncheckedUpdateManyWithoutSubdomainNestedInput = {
    create?: XOR<Enumerable<OrganizationCreateWithoutSubdomainInput>, Enumerable<OrganizationUncheckedCreateWithoutSubdomainInput>>
    connectOrCreate?: Enumerable<OrganizationCreateOrConnectWithoutSubdomainInput>
    upsert?: Enumerable<OrganizationUpsertWithWhereUniqueWithoutSubdomainInput>
    createMany?: OrganizationCreateManySubdomainInputEnvelope
    set?: Enumerable<OrganizationWhereUniqueInput>
    disconnect?: Enumerable<OrganizationWhereUniqueInput>
    delete?: Enumerable<OrganizationWhereUniqueInput>
    connect?: Enumerable<OrganizationWhereUniqueInput>
    update?: Enumerable<OrganizationUpdateWithWhereUniqueWithoutSubdomainInput>
    updateMany?: Enumerable<OrganizationUpdateManyWithWhereWithoutSubdomainInput>
    deleteMany?: Enumerable<OrganizationScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedEnumMembershipRoleFilter = {
    equals?: MembershipRole
    in?: Enumerable<MembershipRole>
    notIn?: Enumerable<MembershipRole>
    not?: NestedEnumMembershipRoleFilter | MembershipRole
  }

  export type NestedEnumMembershipRoleWithAggregatesFilter = {
    equals?: MembershipRole
    in?: Enumerable<MembershipRole>
    notIn?: Enumerable<MembershipRole>
    not?: NestedEnumMembershipRoleWithAggregatesFilter | MembershipRole
    _count?: NestedIntFilter
    _min?: NestedEnumMembershipRoleFilter
    _max?: NestedEnumMembershipRoleFilter
  }

  export type NestedEnumOrderStatusFilter = {
    equals?: OrderStatus
    in?: Enumerable<OrderStatus>
    notIn?: Enumerable<OrderStatus>
    not?: NestedEnumOrderStatusFilter | OrderStatus
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedEnumOrderStatusWithAggregatesFilter = {
    equals?: OrderStatus
    in?: Enumerable<OrderStatus>
    notIn?: Enumerable<OrderStatus>
    not?: NestedEnumOrderStatusWithAggregatesFilter | OrderStatus
    _count?: NestedIntFilter
    _min?: NestedEnumOrderStatusFilter
    _max?: NestedEnumOrderStatusFilter
  }

  export type NestedEnumUnitFilter = {
    equals?: Unit
    in?: Enumerable<Unit>
    notIn?: Enumerable<Unit>
    not?: NestedEnumUnitFilter | Unit
  }

  export type NestedEnumCurrencyFilter = {
    equals?: Currency
    in?: Enumerable<Currency>
    notIn?: Enumerable<Currency>
    not?: NestedEnumCurrencyFilter | Currency
  }

  export type NestedEnumUnitWithAggregatesFilter = {
    equals?: Unit
    in?: Enumerable<Unit>
    notIn?: Enumerable<Unit>
    not?: NestedEnumUnitWithAggregatesFilter | Unit
    _count?: NestedIntFilter
    _min?: NestedEnumUnitFilter
    _max?: NestedEnumUnitFilter
  }

  export type NestedEnumCurrencyWithAggregatesFilter = {
    equals?: Currency
    in?: Enumerable<Currency>
    notIn?: Enumerable<Currency>
    not?: NestedEnumCurrencyWithAggregatesFilter | Currency
    _count?: NestedIntFilter
    _min?: NestedEnumCurrencyFilter
    _max?: NestedEnumCurrencyFilter
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    imageUser?: ImageUserCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    memberships?: MembershipCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    driver?: DriverCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    imageUser?: ImageUserUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    driver?: DriverUncheckedCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    driver?: DriverUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    driver?: DriverUncheckedUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    imageUser?: ImageUserCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    memberships?: MembershipCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    driver?: DriverCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    imageUser?: ImageUserUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    driver?: DriverUncheckedCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    driver?: DriverUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    driver?: DriverUncheckedUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateWithoutUserInput = {
    id?: string
    street1: string
    street2?: string | null
    city: string
    state: string
    zipcode: string
    country: string
    countryCode?: string | null
    coordinates?: CoordinatesCreateNestedOneWithoutAddressesInput
    organization?: OrganizationCreateNestedOneWithoutAddressInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateWithoutUserInput = {
    id?: string
    street1: string
    street2?: string | null
    city: string
    state: string
    zipcode: string
    country: string
    countryCode?: string | null
    coordinateId?: string | null
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutUserInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressCreateManyUserInputEnvelope = {
    data: Enumerable<AddressCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ImageUserCreateWithoutUserInput = {
    id?: string
    location: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUserUncheckedCreateWithoutUserInput = {
    id?: string
    location: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUserCreateOrConnectWithoutUserInput = {
    where: ImageUserWhereUniqueInput
    create: XOR<ImageUserCreateWithoutUserInput, ImageUserUncheckedCreateWithoutUserInput>
  }

  export type ImageUserCreateManyUserInputEnvelope = {
    data: Enumerable<ImageUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: Enumerable<AccountCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: Enumerable<SessionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    product: ProductCreateNestedOneWithoutReviewsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: Enumerable<ReviewCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type MembershipCreateWithoutUserInput = {
    id?: string
    role: MembershipRole
    organizations?: organizationMembershipCreateNestedManyWithoutMembershipInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUncheckedCreateWithoutUserInput = {
    id?: string
    role: MembershipRole
    organizations?: organizationMembershipUncheckedCreateNestedManyWithoutMembershipInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipCreateOrConnectWithoutUserInput = {
    where: MembershipWhereUniqueInput
    create: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
  }

  export type MembershipCreateManyUserInputEnvelope = {
    data: Enumerable<MembershipCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    total: number
    status?: OrderStatus
    items?: ProductCreateNestedManyWithoutOrdersInput
    driver?: DriverCreateNestedOneWithoutOrdersInput
    organization: OrganizationCreateNestedOneWithoutOrdersInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    total: number
    status?: OrderStatus
    items?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    driverId?: string | null
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: Enumerable<OrderCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type DriverCreateWithoutUserInput = {
    orders?: OrderCreateNestedManyWithoutDriverInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverUncheckedCreateWithoutUserInput = {
    orders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverCreateOrConnectWithoutUserInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
  }

  export type AddressUpsertWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
  }

  export type AddressUpdateManyWithWhereWithoutUserInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutAddressInput>
  }

  export type AddressScalarWhereInput = {
    AND?: Enumerable<AddressScalarWhereInput>
    OR?: Enumerable<AddressScalarWhereInput>
    NOT?: Enumerable<AddressScalarWhereInput>
    id?: StringFilter | string
    street1?: StringFilter | string
    street2?: StringNullableFilter | string | null
    city?: StringFilter | string
    state?: StringFilter | string
    zipcode?: StringFilter | string
    country?: StringFilter | string
    countryCode?: StringNullableFilter | string | null
    coordinateId?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    organizationId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ImageUserUpsertWithWhereUniqueWithoutUserInput = {
    where: ImageUserWhereUniqueInput
    update: XOR<ImageUserUpdateWithoutUserInput, ImageUserUncheckedUpdateWithoutUserInput>
    create: XOR<ImageUserCreateWithoutUserInput, ImageUserUncheckedCreateWithoutUserInput>
  }

  export type ImageUserUpdateWithWhereUniqueWithoutUserInput = {
    where: ImageUserWhereUniqueInput
    data: XOR<ImageUserUpdateWithoutUserInput, ImageUserUncheckedUpdateWithoutUserInput>
  }

  export type ImageUserUpdateManyWithWhereWithoutUserInput = {
    where: ImageUserScalarWhereInput
    data: XOR<ImageUserUpdateManyMutationInput, ImageUserUncheckedUpdateManyWithoutImageUserInput>
  }

  export type ImageUserScalarWhereInput = {
    AND?: Enumerable<ImageUserScalarWhereInput>
    OR?: Enumerable<ImageUserScalarWhereInput>
    NOT?: Enumerable<ImageUserScalarWhereInput>
    id?: StringFilter | string
    location?: StringFilter | string
    userId?: StringFilter | string
    blurhash?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountsInput>
  }

  export type AccountScalarWhereInput = {
    AND?: Enumerable<AccountScalarWhereInput>
    OR?: Enumerable<AccountScalarWhereInput>
    NOT?: Enumerable<AccountScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refresh_token?: StringNullableFilter | string | null
    access_token?: StringNullableFilter | string | null
    expires_at?: IntNullableFilter | number | null
    token_type?: StringNullableFilter | string | null
    scope?: StringNullableFilter | string | null
    id_token?: StringNullableFilter | string | null
    session_state?: StringNullableFilter | string | null
    oauth_token_secret?: StringNullableFilter | string | null
    oauth_token?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutSessionsInput>
  }

  export type SessionScalarWhereInput = {
    AND?: Enumerable<SessionScalarWhereInput>
    OR?: Enumerable<SessionScalarWhereInput>
    NOT?: Enumerable<SessionScalarWhereInput>
    id?: StringFilter | string
    sessionToken?: StringFilter | string
    userId?: StringFilter | string
    expires?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutReviewsInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: Enumerable<ReviewScalarWhereInput>
    OR?: Enumerable<ReviewScalarWhereInput>
    NOT?: Enumerable<ReviewScalarWhereInput>
    id?: StringFilter | string
    rating?: IntFilter | number
    comment?: StringNullableFilter | string | null
    productId?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: MembershipWhereUniqueInput
    update: XOR<MembershipUpdateWithoutUserInput, MembershipUncheckedUpdateWithoutUserInput>
    create: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
  }

  export type MembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: MembershipWhereUniqueInput
    data: XOR<MembershipUpdateWithoutUserInput, MembershipUncheckedUpdateWithoutUserInput>
  }

  export type MembershipUpdateManyWithWhereWithoutUserInput = {
    where: MembershipScalarWhereInput
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyWithoutMembershipsInput>
  }

  export type MembershipScalarWhereInput = {
    AND?: Enumerable<MembershipScalarWhereInput>
    OR?: Enumerable<MembershipScalarWhereInput>
    NOT?: Enumerable<MembershipScalarWhereInput>
    id?: StringFilter | string
    role?: EnumMembershipRoleFilter | MembershipRole
    userId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type OrderScalarWhereInput = {
    AND?: Enumerable<OrderScalarWhereInput>
    OR?: Enumerable<OrderScalarWhereInput>
    NOT?: Enumerable<OrderScalarWhereInput>
    id?: StringFilter | string
    total?: IntFilter | number
    status?: EnumOrderStatusFilter | OrderStatus
    customerId?: StringFilter | string
    driverId?: StringNullableFilter | string | null
    organizationId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DriverUpsertWithoutUserInput = {
    update: XOR<DriverUpdateWithoutUserInput, DriverUncheckedUpdateWithoutUserInput>
    create: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
  }

  export type DriverUpdateWithoutUserInput = {
    orders?: OrderUpdateManyWithoutDriverNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUncheckedUpdateWithoutUserInput = {
    orders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutDriverInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    imageUser?: ImageUserCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    memberships?: MembershipCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutDriverInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    imageUser?: ImageUserUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutDriverInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDriverInput, UserUncheckedCreateWithoutDriverInput>
  }

  export type OrderCreateWithoutDriverInput = {
    id?: string
    total: number
    status?: OrderStatus
    items?: ProductCreateNestedManyWithoutOrdersInput
    customer: UserCreateNestedOneWithoutOrdersInput
    organization: OrganizationCreateNestedOneWithoutOrdersInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUncheckedCreateWithoutDriverInput = {
    id?: string
    total: number
    status?: OrderStatus
    items?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    customerId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutDriverInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDriverInput, OrderUncheckedCreateWithoutDriverInput>
  }

  export type OrderCreateManyDriverInputEnvelope = {
    data: Enumerable<OrderCreateManyDriverInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDriverInput = {
    update: XOR<UserUpdateWithoutDriverInput, UserUncheckedUpdateWithoutDriverInput>
    create: XOR<UserCreateWithoutDriverInput, UserUncheckedCreateWithoutDriverInput>
  }

  export type UserUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutDriverInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutDriverInput, OrderUncheckedUpdateWithoutDriverInput>
    create: XOR<OrderCreateWithoutDriverInput, OrderUncheckedCreateWithoutDriverInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutDriverInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutDriverInput, OrderUncheckedUpdateWithoutDriverInput>
  }

  export type OrderUpdateManyWithWhereWithoutDriverInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type OrganizationCreateWithoutVendorInput = {
    id?: string
    name: string
    address?: AddressCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationCreateNestedManyWithoutOrganizationInput
    memberships?: organizationMembershipCreateNestedManyWithoutOrganizationInput
    products?: ProductCreateNestedManyWithoutOrganizationInput
    termsAccepted?: boolean
    subdomain: SubDomainCreateNestedOneWithoutOrganizationInput
    siteSetting?: SiteSettingCreateNestedOneWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUncheckedCreateWithoutVendorInput = {
    id?: string
    name: string
    address?: AddressUncheckedCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    memberships?: organizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganizationInput
    subdomainId: string
    termsAccepted?: boolean
    siteSetting?: SiteSettingUncheckedCreateNestedOneWithoutOrganizationInput
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationCreateOrConnectWithoutVendorInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutVendorInput, OrganizationUncheckedCreateWithoutVendorInput>
  }

  export type OrganizationCreateManyVendorInputEnvelope = {
    data: Enumerable<OrganizationCreateManyVendorInput>
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithWhereUniqueWithoutVendorInput = {
    where: OrganizationWhereUniqueInput
    update: XOR<OrganizationUpdateWithoutVendorInput, OrganizationUncheckedUpdateWithoutVendorInput>
    create: XOR<OrganizationCreateWithoutVendorInput, OrganizationUncheckedCreateWithoutVendorInput>
  }

  export type OrganizationUpdateWithWhereUniqueWithoutVendorInput = {
    where: OrganizationWhereUniqueInput
    data: XOR<OrganizationUpdateWithoutVendorInput, OrganizationUncheckedUpdateWithoutVendorInput>
  }

  export type OrganizationUpdateManyWithWhereWithoutVendorInput = {
    where: OrganizationScalarWhereInput
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type OrganizationScalarWhereInput = {
    AND?: Enumerable<OrganizationScalarWhereInput>
    OR?: Enumerable<OrganizationScalarWhereInput>
    NOT?: Enumerable<OrganizationScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    email?: StringFilter | string
    emailVerified?: BoolFilter | boolean
    dialCode?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    vendorId?: StringFilter | string
    subdomainId?: StringFilter | string
    termsAccepted?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CoordinatesCreateWithoutAddressesInput = {
    id?: string
    latitude: number
    longitude: number
    radius?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoordinatesUncheckedCreateWithoutAddressesInput = {
    id?: string
    latitude: number
    longitude: number
    radius?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoordinatesCreateOrConnectWithoutAddressesInput = {
    where: CoordinatesWhereUniqueInput
    create: XOR<CoordinatesCreateWithoutAddressesInput, CoordinatesUncheckedCreateWithoutAddressesInput>
  }

  export type UserCreateWithoutAddressInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    termsAccepted?: boolean
    imageUser?: ImageUserCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    memberships?: MembershipCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    driver?: DriverCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutAddressInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    termsAccepted?: boolean
    imageUser?: ImageUserUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    driver?: DriverUncheckedCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutAddressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
  }

  export type OrganizationCreateWithoutAddressInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationCreateNestedManyWithoutOrganizationInput
    memberships?: organizationMembershipCreateNestedManyWithoutOrganizationInput
    products?: ProductCreateNestedManyWithoutOrganizationInput
    vendor: VendorCreateNestedOneWithoutOrganizationsInput
    termsAccepted?: boolean
    subdomain: SubDomainCreateNestedOneWithoutOrganizationInput
    siteSetting?: SiteSettingCreateNestedOneWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUncheckedCreateWithoutAddressInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    memberships?: organizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganizationInput
    vendorId: string
    subdomainId: string
    termsAccepted?: boolean
    siteSetting?: SiteSettingUncheckedCreateNestedOneWithoutOrganizationInput
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationCreateOrConnectWithoutAddressInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutAddressInput, OrganizationUncheckedCreateWithoutAddressInput>
  }

  export type CoordinatesUpsertWithoutAddressesInput = {
    update: XOR<CoordinatesUpdateWithoutAddressesInput, CoordinatesUncheckedUpdateWithoutAddressesInput>
    create: XOR<CoordinatesCreateWithoutAddressesInput, CoordinatesUncheckedCreateWithoutAddressesInput>
  }

  export type CoordinatesUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoordinatesUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAddressInput = {
    update: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
  }

  export type UserUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    driver?: DriverUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    driver?: DriverUncheckedUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUpsertWithoutAddressInput = {
    update: XOR<OrganizationUpdateWithoutAddressInput, OrganizationUncheckedUpdateWithoutAddressInput>
    create: XOR<OrganizationCreateWithoutAddressInput, OrganizationUncheckedCreateWithoutAddressInput>
  }

  export type OrganizationUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUpdateManyWithoutOrganizationNestedInput
    memberships?: organizationMembershipUpdateManyWithoutOrganizationNestedInput
    products?: ProductUpdateManyWithoutOrganizationNestedInput
    vendor?: VendorUpdateOneRequiredWithoutOrganizationsNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    subdomain?: SubDomainUpdateOneRequiredWithoutOrganizationNestedInput
    siteSetting?: SiteSettingUpdateOneWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    memberships?: organizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganizationNestedInput
    vendorId?: StringFieldUpdateOperationsInput | string
    subdomainId?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    siteSetting?: SiteSettingUncheckedUpdateOneWithoutOrganizationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutImagesInput = {
    id?: string
    name: string
    address?: AddressCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    memberships?: organizationMembershipCreateNestedManyWithoutOrganizationInput
    products?: ProductCreateNestedManyWithoutOrganizationInput
    vendor: VendorCreateNestedOneWithoutOrganizationsInput
    termsAccepted?: boolean
    subdomain: SubDomainCreateNestedOneWithoutOrganizationInput
    siteSetting?: SiteSettingCreateNestedOneWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    address?: AddressUncheckedCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    memberships?: organizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganizationInput
    vendorId: string
    subdomainId: string
    termsAccepted?: boolean
    siteSetting?: SiteSettingUncheckedCreateNestedOneWithoutOrganizationInput
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationCreateOrConnectWithoutImagesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutImagesInput, OrganizationUncheckedCreateWithoutImagesInput>
  }

  export type OrganizationUpsertWithoutImagesInput = {
    update: XOR<OrganizationUpdateWithoutImagesInput, OrganizationUncheckedUpdateWithoutImagesInput>
    create: XOR<OrganizationCreateWithoutImagesInput, OrganizationUncheckedCreateWithoutImagesInput>
  }

  export type OrganizationUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    memberships?: organizationMembershipUpdateManyWithoutOrganizationNestedInput
    products?: ProductUpdateManyWithoutOrganizationNestedInput
    vendor?: VendorUpdateOneRequiredWithoutOrganizationsNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    subdomain?: SubDomainUpdateOneRequiredWithoutOrganizationNestedInput
    siteSetting?: SiteSettingUpdateOneWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    memberships?: organizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganizationNestedInput
    vendorId?: StringFieldUpdateOperationsInput | string
    subdomainId?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    siteSetting?: SiteSettingUncheckedUpdateOneWithoutOrganizationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutImagesInput = {
    id?: string
    name: string
    description?: string | null
    features?: string | null
    categories?: CategoryCreateNestedManyWithoutProductsInput
    unit?: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    organization: OrganizationCreateNestedOneWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutItemsInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    rating?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    description?: string | null
    features?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    unit?: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    organizationId: string
    orders?: OrderUncheckedCreateNestedManyWithoutItemsInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    rating?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutImagesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
  }

  export type ProductUpsertWithoutImagesInput = {
    update: XOR<ProductUpdateWithoutImagesInput, ProductUncheckedUpdateWithoutImagesInput>
    create: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
  }

  export type ProductUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutItemsNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    organizationId?: StringFieldUpdateOperationsInput | string
    orders?: OrderUncheckedUpdateManyWithoutItemsNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutImageUserInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    memberships?: MembershipCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    driver?: DriverCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutImageUserInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    driver?: DriverUncheckedCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutImageUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutImageUserInput, UserUncheckedCreateWithoutImageUserInput>
  }

  export type UserUpsertWithoutImageUserInput = {
    update: XOR<UserUpdateWithoutImageUserInput, UserUncheckedUpdateWithoutImageUserInput>
    create: XOR<UserCreateWithoutImageUserInput, UserUncheckedCreateWithoutImageUserInput>
  }

  export type UserUpdateWithoutImageUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    driver?: DriverUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutImageUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    driver?: DriverUncheckedUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateWithoutCoordinatesInput = {
    id?: string
    street1: string
    street2?: string | null
    city: string
    state: string
    zipcode: string
    country: string
    countryCode?: string | null
    user?: UserCreateNestedOneWithoutAddressInput
    organization?: OrganizationCreateNestedOneWithoutAddressInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateWithoutCoordinatesInput = {
    id?: string
    street1: string
    street2?: string | null
    city: string
    state: string
    zipcode: string
    country: string
    countryCode?: string | null
    userId?: string | null
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutCoordinatesInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCoordinatesInput, AddressUncheckedCreateWithoutCoordinatesInput>
  }

  export type AddressCreateManyCoordinatesInputEnvelope = {
    data: Enumerable<AddressCreateManyCoordinatesInput>
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutCoordinatesInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutCoordinatesInput, AddressUncheckedUpdateWithoutCoordinatesInput>
    create: XOR<AddressCreateWithoutCoordinatesInput, AddressUncheckedCreateWithoutCoordinatesInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutCoordinatesInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutCoordinatesInput, AddressUncheckedUpdateWithoutCoordinatesInput>
  }

  export type AddressUpdateManyWithWhereWithoutCoordinatesInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutAddressesInput>
  }

  export type organizationMembershipCreateWithoutMembershipInput = {
    organization: OrganizationCreateNestedOneWithoutMembershipsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationMembershipUncheckedCreateWithoutMembershipInput = {
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationMembershipCreateOrConnectWithoutMembershipInput = {
    where: organizationMembershipWhereUniqueInput
    create: XOR<organizationMembershipCreateWithoutMembershipInput, organizationMembershipUncheckedCreateWithoutMembershipInput>
  }

  export type organizationMembershipCreateManyMembershipInputEnvelope = {
    data: Enumerable<organizationMembershipCreateManyMembershipInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutMembershipsInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    imageUser?: ImageUserCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    driver?: DriverCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    imageUser?: ImageUserUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    driver?: DriverUncheckedCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
  }

  export type organizationMembershipUpsertWithWhereUniqueWithoutMembershipInput = {
    where: organizationMembershipWhereUniqueInput
    update: XOR<organizationMembershipUpdateWithoutMembershipInput, organizationMembershipUncheckedUpdateWithoutMembershipInput>
    create: XOR<organizationMembershipCreateWithoutMembershipInput, organizationMembershipUncheckedCreateWithoutMembershipInput>
  }

  export type organizationMembershipUpdateWithWhereUniqueWithoutMembershipInput = {
    where: organizationMembershipWhereUniqueInput
    data: XOR<organizationMembershipUpdateWithoutMembershipInput, organizationMembershipUncheckedUpdateWithoutMembershipInput>
  }

  export type organizationMembershipUpdateManyWithWhereWithoutMembershipInput = {
    where: organizationMembershipScalarWhereInput
    data: XOR<organizationMembershipUpdateManyMutationInput, organizationMembershipUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type organizationMembershipScalarWhereInput = {
    AND?: Enumerable<organizationMembershipScalarWhereInput>
    OR?: Enumerable<organizationMembershipScalarWhereInput>
    NOT?: Enumerable<organizationMembershipScalarWhereInput>
    organizationId?: StringFilter | string
    membershipId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
  }

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    driver?: DriverUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    driver?: DriverUncheckedUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutOrdersInput = {
    id?: string
    name: string
    description?: string | null
    features?: string | null
    categories?: CategoryCreateNestedManyWithoutProductsInput
    unit?: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    images?: ImageProductCreateNestedManyWithoutProductInput
    organization: OrganizationCreateNestedOneWithoutProductsInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    rating?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    description?: string | null
    features?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    unit?: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    images?: ImageProductUncheckedCreateNestedManyWithoutProductInput
    organizationId: string
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    rating?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    imageUser?: ImageUserCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    memberships?: MembershipCreateNestedManyWithoutUserInput
    driver?: DriverCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    imageUser?: ImageUserUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    driver?: DriverUncheckedCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type DriverCreateWithoutOrdersInput = {
    user: UserCreateNestedOneWithoutDriverInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverUncheckedCreateWithoutOrdersInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverCreateOrConnectWithoutOrdersInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutOrdersInput, DriverUncheckedCreateWithoutOrdersInput>
  }

  export type OrganizationCreateWithoutOrdersInput = {
    id?: string
    name: string
    address?: AddressCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationCreateNestedManyWithoutOrganizationInput
    memberships?: organizationMembershipCreateNestedManyWithoutOrganizationInput
    products?: ProductCreateNestedManyWithoutOrganizationInput
    vendor: VendorCreateNestedOneWithoutOrganizationsInput
    termsAccepted?: boolean
    subdomain: SubDomainCreateNestedOneWithoutOrganizationInput
    siteSetting?: SiteSettingCreateNestedOneWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    address?: AddressUncheckedCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    memberships?: organizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganizationInput
    vendorId: string
    subdomainId: string
    termsAccepted?: boolean
    siteSetting?: SiteSettingUncheckedCreateNestedOneWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationCreateOrConnectWithoutOrdersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOrdersInput, OrganizationUncheckedCreateWithoutOrdersInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUpdateManyWithWhereWithoutOrdersInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutItemsInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    features?: StringNullableFilter | string | null
    unit?: EnumUnitFilter | Unit
    size?: FloatFilter | number
    basePrice?: IntFilter | number
    currency?: EnumCurrencyFilter | Currency
    discount?: IntFilter | number
    quantity?: IntFilter | number
    stock?: IntFilter | number
    organizationId?: StringFilter | string
    rating?: FloatNullableFilter | number | null
    tags?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    driver?: DriverUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    driver?: DriverUncheckedUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUpsertWithoutOrdersInput = {
    update: XOR<DriverUpdateWithoutOrdersInput, DriverUncheckedUpdateWithoutOrdersInput>
    create: XOR<DriverCreateWithoutOrdersInput, DriverUncheckedCreateWithoutOrdersInput>
  }

  export type DriverUpdateWithoutOrdersInput = {
    user?: UserUpdateOneRequiredWithoutDriverNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUpsertWithoutOrdersInput = {
    update: XOR<OrganizationUpdateWithoutOrdersInput, OrganizationUncheckedUpdateWithoutOrdersInput>
    create: XOR<OrganizationCreateWithoutOrdersInput, OrganizationUncheckedCreateWithoutOrdersInput>
  }

  export type OrganizationUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUpdateManyWithoutOrganizationNestedInput
    memberships?: organizationMembershipUpdateManyWithoutOrganizationNestedInput
    products?: ProductUpdateManyWithoutOrganizationNestedInput
    vendor?: VendorUpdateOneRequiredWithoutOrganizationsNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    subdomain?: SubDomainUpdateOneRequiredWithoutOrganizationNestedInput
    siteSetting?: SiteSettingUpdateOneWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    memberships?: organizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganizationNestedInput
    vendorId?: StringFieldUpdateOperationsInput | string
    subdomainId?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    siteSetting?: SiteSettingUncheckedUpdateOneWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateWithoutOrganizationInput = {
    id?: string
    street1: string
    street2?: string | null
    city: string
    state: string
    zipcode: string
    country: string
    countryCode?: string | null
    coordinates?: CoordinatesCreateNestedOneWithoutAddressesInput
    user?: UserCreateNestedOneWithoutAddressInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateWithoutOrganizationInput = {
    id?: string
    street1: string
    street2?: string | null
    city: string
    state: string
    zipcode: string
    country: string
    countryCode?: string | null
    coordinateId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutOrganizationInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutOrganizationInput, AddressUncheckedCreateWithoutOrganizationInput>
  }

  export type ImageOrganizationCreateWithoutOrganizationInput = {
    id?: string
    location: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageOrganizationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    location: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageOrganizationCreateOrConnectWithoutOrganizationInput = {
    where: ImageOrganizationWhereUniqueInput
    create: XOR<ImageOrganizationCreateWithoutOrganizationInput, ImageOrganizationUncheckedCreateWithoutOrganizationInput>
  }

  export type ImageOrganizationCreateManyOrganizationInputEnvelope = {
    data: Enumerable<ImageOrganizationCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type organizationMembershipCreateWithoutOrganizationInput = {
    membership: MembershipCreateNestedOneWithoutOrganizationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationMembershipUncheckedCreateWithoutOrganizationInput = {
    membershipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationMembershipCreateOrConnectWithoutOrganizationInput = {
    where: organizationMembershipWhereUniqueInput
    create: XOR<organizationMembershipCreateWithoutOrganizationInput, organizationMembershipUncheckedCreateWithoutOrganizationInput>
  }

  export type organizationMembershipCreateManyOrganizationInputEnvelope = {
    data: Enumerable<organizationMembershipCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    features?: string | null
    categories?: CategoryCreateNestedManyWithoutProductsInput
    unit?: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    images?: ImageProductCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutItemsInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    rating?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    features?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    unit?: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    images?: ImageProductUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutItemsInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    rating?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutOrganizationInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrganizationInput, ProductUncheckedCreateWithoutOrganizationInput>
  }

  export type ProductCreateManyOrganizationInputEnvelope = {
    data: Enumerable<ProductCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type VendorCreateWithoutOrganizationsInput = {
    id?: string
    name: string
    publicName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUncheckedCreateWithoutOrganizationsInput = {
    id?: string
    name: string
    publicName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorCreateOrConnectWithoutOrganizationsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutOrganizationsInput, VendorUncheckedCreateWithoutOrganizationsInput>
  }

  export type SubDomainCreateWithoutOrganizationInput = {
    subdomain: string
    isValid: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubDomainUncheckedCreateWithoutOrganizationInput = {
    subdomain: string
    isValid: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubDomainCreateOrConnectWithoutOrganizationInput = {
    where: SubDomainWhereUniqueInput
    create: XOR<SubDomainCreateWithoutOrganizationInput, SubDomainUncheckedCreateWithoutOrganizationInput>
  }

  export type SiteSettingCreateWithoutOrganizationInput = {
    id: string
    description?: string | null
    title: string
    bannerText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteSettingUncheckedCreateWithoutOrganizationInput = {
    id: string
    description?: string | null
    title: string
    bannerText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteSettingCreateOrConnectWithoutOrganizationInput = {
    where: SiteSettingWhereUniqueInput
    create: XOR<SiteSettingCreateWithoutOrganizationInput, SiteSettingUncheckedCreateWithoutOrganizationInput>
  }

  export type OrderCreateWithoutOrganizationInput = {
    id?: string
    total: number
    status?: OrderStatus
    items?: ProductCreateNestedManyWithoutOrdersInput
    customer: UserCreateNestedOneWithoutOrdersInput
    driver?: DriverCreateNestedOneWithoutOrdersInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUncheckedCreateWithoutOrganizationInput = {
    id?: string
    total: number
    status?: OrderStatus
    items?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    customerId: string
    driverId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutOrganizationInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrganizationInput, OrderUncheckedCreateWithoutOrganizationInput>
  }

  export type OrderCreateManyOrganizationInputEnvelope = {
    data: Enumerable<OrderCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithoutOrganizationInput = {
    update: XOR<AddressUpdateWithoutOrganizationInput, AddressUncheckedUpdateWithoutOrganizationInput>
    create: XOR<AddressCreateWithoutOrganizationInput, AddressUncheckedCreateWithoutOrganizationInput>
  }

  export type AddressUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: CoordinatesUpdateOneWithoutAddressesNestedInput
    user?: UserUpdateOneWithoutAddressNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    coordinateId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageOrganizationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ImageOrganizationWhereUniqueInput
    update: XOR<ImageOrganizationUpdateWithoutOrganizationInput, ImageOrganizationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ImageOrganizationCreateWithoutOrganizationInput, ImageOrganizationUncheckedCreateWithoutOrganizationInput>
  }

  export type ImageOrganizationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ImageOrganizationWhereUniqueInput
    data: XOR<ImageOrganizationUpdateWithoutOrganizationInput, ImageOrganizationUncheckedUpdateWithoutOrganizationInput>
  }

  export type ImageOrganizationUpdateManyWithWhereWithoutOrganizationInput = {
    where: ImageOrganizationScalarWhereInput
    data: XOR<ImageOrganizationUpdateManyMutationInput, ImageOrganizationUncheckedUpdateManyWithoutImagesInput>
  }

  export type ImageOrganizationScalarWhereInput = {
    AND?: Enumerable<ImageOrganizationScalarWhereInput>
    OR?: Enumerable<ImageOrganizationScalarWhereInput>
    NOT?: Enumerable<ImageOrganizationScalarWhereInput>
    id?: StringFilter | string
    location?: StringFilter | string
    organizationId?: StringFilter | string
    blurhash?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type organizationMembershipUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: organizationMembershipWhereUniqueInput
    update: XOR<organizationMembershipUpdateWithoutOrganizationInput, organizationMembershipUncheckedUpdateWithoutOrganizationInput>
    create: XOR<organizationMembershipCreateWithoutOrganizationInput, organizationMembershipUncheckedCreateWithoutOrganizationInput>
  }

  export type organizationMembershipUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: organizationMembershipWhereUniqueInput
    data: XOR<organizationMembershipUpdateWithoutOrganizationInput, organizationMembershipUncheckedUpdateWithoutOrganizationInput>
  }

  export type organizationMembershipUpdateManyWithWhereWithoutOrganizationInput = {
    where: organizationMembershipScalarWhereInput
    data: XOR<organizationMembershipUpdateManyMutationInput, organizationMembershipUncheckedUpdateManyWithoutMembershipsInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutOrganizationInput, ProductUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ProductCreateWithoutOrganizationInput, ProductUncheckedCreateWithoutOrganizationInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutOrganizationInput, ProductUncheckedUpdateWithoutOrganizationInput>
  }

  export type ProductUpdateManyWithWhereWithoutOrganizationInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type VendorUpsertWithoutOrganizationsInput = {
    update: XOR<VendorUpdateWithoutOrganizationsInput, VendorUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<VendorCreateWithoutOrganizationsInput, VendorUncheckedCreateWithoutOrganizationsInput>
  }

  export type VendorUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubDomainUpsertWithoutOrganizationInput = {
    update: XOR<SubDomainUpdateWithoutOrganizationInput, SubDomainUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SubDomainCreateWithoutOrganizationInput, SubDomainUncheckedCreateWithoutOrganizationInput>
  }

  export type SubDomainUpdateWithoutOrganizationInput = {
    subdomain?: StringFieldUpdateOperationsInput | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubDomainUncheckedUpdateWithoutOrganizationInput = {
    subdomain?: StringFieldUpdateOperationsInput | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingUpsertWithoutOrganizationInput = {
    update: XOR<SiteSettingUpdateWithoutOrganizationInput, SiteSettingUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SiteSettingCreateWithoutOrganizationInput, SiteSettingUncheckedCreateWithoutOrganizationInput>
  }

  export type SiteSettingUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutOrganizationInput, OrderUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrderCreateWithoutOrganizationInput, OrderUncheckedCreateWithoutOrganizationInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutOrganizationInput, OrderUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrderUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type OrganizationCreateWithoutMembershipsInput = {
    id?: string
    name: string
    address?: AddressCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationCreateNestedManyWithoutOrganizationInput
    products?: ProductCreateNestedManyWithoutOrganizationInput
    vendor: VendorCreateNestedOneWithoutOrganizationsInput
    termsAccepted?: boolean
    subdomain: SubDomainCreateNestedOneWithoutOrganizationInput
    siteSetting?: SiteSettingCreateNestedOneWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUncheckedCreateWithoutMembershipsInput = {
    id?: string
    name: string
    address?: AddressUncheckedCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganizationInput
    vendorId: string
    subdomainId: string
    termsAccepted?: boolean
    siteSetting?: SiteSettingUncheckedCreateNestedOneWithoutOrganizationInput
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationCreateOrConnectWithoutMembershipsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMembershipsInput, OrganizationUncheckedCreateWithoutMembershipsInput>
  }

  export type MembershipCreateWithoutOrganizationsInput = {
    id?: string
    role: MembershipRole
    user?: UserCreateNestedOneWithoutMembershipsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUncheckedCreateWithoutOrganizationsInput = {
    id?: string
    role: MembershipRole
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipCreateOrConnectWithoutOrganizationsInput = {
    where: MembershipWhereUniqueInput
    create: XOR<MembershipCreateWithoutOrganizationsInput, MembershipUncheckedCreateWithoutOrganizationsInput>
  }

  export type OrganizationUpsertWithoutMembershipsInput = {
    update: XOR<OrganizationUpdateWithoutMembershipsInput, OrganizationUncheckedUpdateWithoutMembershipsInput>
    create: XOR<OrganizationCreateWithoutMembershipsInput, OrganizationUncheckedCreateWithoutMembershipsInput>
  }

  export type OrganizationUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUpdateManyWithoutOrganizationNestedInput
    products?: ProductUpdateManyWithoutOrganizationNestedInput
    vendor?: VendorUpdateOneRequiredWithoutOrganizationsNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    subdomain?: SubDomainUpdateOneRequiredWithoutOrganizationNestedInput
    siteSetting?: SiteSettingUpdateOneWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganizationNestedInput
    vendorId?: StringFieldUpdateOperationsInput | string
    subdomainId?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    siteSetting?: SiteSettingUncheckedUpdateOneWithoutOrganizationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUpsertWithoutOrganizationsInput = {
    update: XOR<MembershipUpdateWithoutOrganizationsInput, MembershipUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<MembershipCreateWithoutOrganizationsInput, MembershipUncheckedCreateWithoutOrganizationsInput>
  }

  export type MembershipUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | MembershipRole
    user?: UserUpdateOneWithoutMembershipsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUncheckedUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | MembershipRole
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    icon: string
    categoryLists?: CategoryListCreateNestedManyWithoutCategoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    icon: string
    categoryLists?: CategoryListUncheckedCreateNestedManyWithoutCategoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type ImageProductCreateWithoutProductInput = {
    id?: string
    location: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageProductUncheckedCreateWithoutProductInput = {
    id?: string
    location: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageProductCreateOrConnectWithoutProductInput = {
    where: ImageProductWhereUniqueInput
    create: XOR<ImageProductCreateWithoutProductInput, ImageProductUncheckedCreateWithoutProductInput>
  }

  export type ImageProductCreateManyProductInputEnvelope = {
    data: Enumerable<ImageProductCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutProductsInput = {
    id?: string
    name: string
    address?: AddressCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationCreateNestedManyWithoutOrganizationInput
    memberships?: organizationMembershipCreateNestedManyWithoutOrganizationInput
    vendor: VendorCreateNestedOneWithoutOrganizationsInput
    termsAccepted?: boolean
    subdomain: SubDomainCreateNestedOneWithoutOrganizationInput
    siteSetting?: SiteSettingCreateNestedOneWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    address?: AddressUncheckedCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    memberships?: organizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    vendorId: string
    subdomainId: string
    termsAccepted?: boolean
    siteSetting?: SiteSettingUncheckedCreateNestedOneWithoutOrganizationInput
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationCreateOrConnectWithoutProductsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProductsInput, OrganizationUncheckedCreateWithoutProductsInput>
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    total: number
    status?: OrderStatus
    customer: UserCreateNestedOneWithoutOrdersInput
    driver?: DriverCreateNestedOneWithoutOrdersInput
    organization: OrganizationCreateNestedOneWithoutOrdersInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    total: number
    status?: OrderStatus
    customerId: string
    driverId?: string | null
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ReviewCreateWithoutProductInput = {
    id?: string
    rating: number
    comment?: string | null
    user: UserCreateNestedOneWithoutReviewsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUncheckedCreateWithoutProductInput = {
    id?: string
    rating: number
    comment?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutProductInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewCreateManyProductInputEnvelope = {
    data: Enumerable<ReviewCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithWhereUniqueWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateManyWithWhereWithoutProductsInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: Enumerable<CategoryScalarWhereInput>
    OR?: Enumerable<CategoryScalarWhereInput>
    NOT?: Enumerable<CategoryScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    icon?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ImageProductUpsertWithWhereUniqueWithoutProductInput = {
    where: ImageProductWhereUniqueInput
    update: XOR<ImageProductUpdateWithoutProductInput, ImageProductUncheckedUpdateWithoutProductInput>
    create: XOR<ImageProductCreateWithoutProductInput, ImageProductUncheckedCreateWithoutProductInput>
  }

  export type ImageProductUpdateWithWhereUniqueWithoutProductInput = {
    where: ImageProductWhereUniqueInput
    data: XOR<ImageProductUpdateWithoutProductInput, ImageProductUncheckedUpdateWithoutProductInput>
  }

  export type ImageProductUpdateManyWithWhereWithoutProductInput = {
    where: ImageProductScalarWhereInput
    data: XOR<ImageProductUpdateManyMutationInput, ImageProductUncheckedUpdateManyWithoutImagesInput>
  }

  export type ImageProductScalarWhereInput = {
    AND?: Enumerable<ImageProductScalarWhereInput>
    OR?: Enumerable<ImageProductScalarWhereInput>
    NOT?: Enumerable<ImageProductScalarWhereInput>
    id?: StringFilter | string
    location?: StringFilter | string
    productId?: StringFilter | string
    blurhash?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OrganizationUpsertWithoutProductsInput = {
    update: XOR<OrganizationUpdateWithoutProductsInput, OrganizationUncheckedUpdateWithoutProductsInput>
    create: XOR<OrganizationCreateWithoutProductsInput, OrganizationUncheckedCreateWithoutProductsInput>
  }

  export type OrganizationUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUpdateManyWithoutOrganizationNestedInput
    memberships?: organizationMembershipUpdateManyWithoutOrganizationNestedInput
    vendor?: VendorUpdateOneRequiredWithoutOrganizationsNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    subdomain?: SubDomainUpdateOneRequiredWithoutOrganizationNestedInput
    siteSetting?: SiteSettingUpdateOneWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    memberships?: organizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    vendorId?: StringFieldUpdateOperationsInput | string
    subdomainId?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    siteSetting?: SiteSettingUncheckedUpdateOneWithoutOrganizationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutItemsInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutItemsInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateManyWithWhereWithoutItemsInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
  }

  export type ReviewUpdateManyWithWhereWithoutProductInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutReviewsInput>
  }

  export type ProductCreateWithoutCategoriesInput = {
    id?: string
    name: string
    description?: string | null
    features?: string | null
    unit?: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    images?: ImageProductCreateNestedManyWithoutProductInput
    organization: OrganizationCreateNestedOneWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutItemsInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    rating?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    description?: string | null
    features?: string | null
    unit?: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    images?: ImageProductUncheckedCreateNestedManyWithoutProductInput
    organizationId: string
    orders?: OrderUncheckedCreateNestedManyWithoutItemsInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    rating?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryListCreateWithoutCategoriesInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryListUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryListCreateOrConnectWithoutCategoriesInput = {
    where: CategoryListWhereUniqueInput
    create: XOR<CategoryListCreateWithoutCategoriesInput, CategoryListUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoriesInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type CategoryListUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: CategoryListWhereUniqueInput
    update: XOR<CategoryListUpdateWithoutCategoriesInput, CategoryListUncheckedUpdateWithoutCategoriesInput>
    create: XOR<CategoryListCreateWithoutCategoriesInput, CategoryListUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryListUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: CategoryListWhereUniqueInput
    data: XOR<CategoryListUpdateWithoutCategoriesInput, CategoryListUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryListUpdateManyWithWhereWithoutCategoriesInput = {
    where: CategoryListScalarWhereInput
    data: XOR<CategoryListUpdateManyMutationInput, CategoryListUncheckedUpdateManyWithoutCategoryListsInput>
  }

  export type CategoryListScalarWhereInput = {
    AND?: Enumerable<CategoryListScalarWhereInput>
    OR?: Enumerable<CategoryListScalarWhereInput>
    NOT?: Enumerable<CategoryListScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CategoryCreateWithoutCategoryListsInput = {
    id?: string
    name: string
    slug: string
    icon: string
    products?: ProductCreateNestedManyWithoutCategoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutCategoryListsInput = {
    id?: string
    name: string
    slug: string
    icon: string
    products?: ProductUncheckedCreateNestedManyWithoutCategoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutCategoryListsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutCategoryListsInput, CategoryUncheckedCreateWithoutCategoryListsInput>
  }

  export type CategoryUpsertWithWhereUniqueWithoutCategoryListsInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutCategoryListsInput, CategoryUncheckedUpdateWithoutCategoryListsInput>
    create: XOR<CategoryCreateWithoutCategoryListsInput, CategoryUncheckedCreateWithoutCategoryListsInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutCategoryListsInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutCategoryListsInput, CategoryUncheckedUpdateWithoutCategoryListsInput>
  }

  export type CategoryUpdateManyWithWhereWithoutCategoryListsInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type ServiceCreateWithoutServiceListsInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    icon: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUncheckedCreateWithoutServiceListsInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    icon: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateOrConnectWithoutServiceListsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceListsInput, ServiceUncheckedCreateWithoutServiceListsInput>
  }

  export type ServiceUpsertWithWhereUniqueWithoutServiceListsInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutServiceListsInput, ServiceUncheckedUpdateWithoutServiceListsInput>
    create: XOR<ServiceCreateWithoutServiceListsInput, ServiceUncheckedCreateWithoutServiceListsInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutServiceListsInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutServiceListsInput, ServiceUncheckedUpdateWithoutServiceListsInput>
  }

  export type ServiceUpdateManyWithWhereWithoutServiceListsInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutServicesInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: Enumerable<ServiceScalarWhereInput>
    OR?: Enumerable<ServiceScalarWhereInput>
    NOT?: Enumerable<ServiceScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    subtitle?: StringNullableFilter | string | null
    slug?: StringFilter | string
    icon?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ServiceListCreateWithoutServicesInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceListUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceListCreateOrConnectWithoutServicesInput = {
    where: ServiceListWhereUniqueInput
    create: XOR<ServiceListCreateWithoutServicesInput, ServiceListUncheckedCreateWithoutServicesInput>
  }

  export type ServiceListUpsertWithWhereUniqueWithoutServicesInput = {
    where: ServiceListWhereUniqueInput
    update: XOR<ServiceListUpdateWithoutServicesInput, ServiceListUncheckedUpdateWithoutServicesInput>
    create: XOR<ServiceListCreateWithoutServicesInput, ServiceListUncheckedCreateWithoutServicesInput>
  }

  export type ServiceListUpdateWithWhereUniqueWithoutServicesInput = {
    where: ServiceListWhereUniqueInput
    data: XOR<ServiceListUpdateWithoutServicesInput, ServiceListUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceListUpdateManyWithWhereWithoutServicesInput = {
    where: ServiceListScalarWhereInput
    data: XOR<ServiceListUpdateManyMutationInput, ServiceListUncheckedUpdateManyWithoutServiceListsInput>
  }

  export type ServiceListScalarWhereInput = {
    AND?: Enumerable<ServiceListScalarWhereInput>
    OR?: Enumerable<ServiceListScalarWhereInput>
    NOT?: Enumerable<ServiceListScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductCreateWithoutReviewsInput = {
    id?: string
    name: string
    description?: string | null
    features?: string | null
    categories?: CategoryCreateNestedManyWithoutProductsInput
    unit?: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    images?: ImageProductCreateNestedManyWithoutProductInput
    organization: OrganizationCreateNestedOneWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutItemsInput
    rating?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    description?: string | null
    features?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    unit?: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    images?: ImageProductUncheckedCreateNestedManyWithoutProductInput
    organizationId: string
    orders?: OrderUncheckedCreateNestedManyWithoutItemsInput
    rating?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutReviewsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    imageUser?: ImageUserCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    memberships?: MembershipCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    driver?: DriverCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    firstName: string
    lastName: string
    username?: string | null
    email: string
    emailVerified?: boolean
    hashedPassword?: string | null
    dialCode?: string | null
    phone?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutUserInput
    termsAccepted?: boolean
    imageUser?: ImageUserUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    driver?: DriverUncheckedCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type ProductUpsertWithoutReviewsInput = {
    update: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
  }

  export type ProductUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    images?: ImageProductUpdateManyWithoutProductNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutItemsNestedInput
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    images?: ImageProductUncheckedUpdateManyWithoutProductNestedInput
    organizationId?: StringFieldUpdateOperationsInput | string
    orders?: OrderUncheckedUpdateManyWithoutItemsNestedInput
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    driver?: DriverUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutUserNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    imageUser?: ImageUserUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    driver?: DriverUncheckedUpdateOneWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutSiteSettingInput = {
    id?: string
    name: string
    address?: AddressCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationCreateNestedManyWithoutOrganizationInput
    memberships?: organizationMembershipCreateNestedManyWithoutOrganizationInput
    products?: ProductCreateNestedManyWithoutOrganizationInput
    vendor: VendorCreateNestedOneWithoutOrganizationsInput
    termsAccepted?: boolean
    subdomain: SubDomainCreateNestedOneWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUncheckedCreateWithoutSiteSettingInput = {
    id?: string
    name: string
    address?: AddressUncheckedCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    memberships?: organizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganizationInput
    vendorId: string
    subdomainId: string
    termsAccepted?: boolean
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationCreateOrConnectWithoutSiteSettingInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSiteSettingInput, OrganizationUncheckedCreateWithoutSiteSettingInput>
  }

  export type OrganizationUpsertWithoutSiteSettingInput = {
    update: XOR<OrganizationUpdateWithoutSiteSettingInput, OrganizationUncheckedUpdateWithoutSiteSettingInput>
    create: XOR<OrganizationCreateWithoutSiteSettingInput, OrganizationUncheckedCreateWithoutSiteSettingInput>
  }

  export type OrganizationUpdateWithoutSiteSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUpdateManyWithoutOrganizationNestedInput
    memberships?: organizationMembershipUpdateManyWithoutOrganizationNestedInput
    products?: ProductUpdateManyWithoutOrganizationNestedInput
    vendor?: VendorUpdateOneRequiredWithoutOrganizationsNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    subdomain?: SubDomainUpdateOneRequiredWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateWithoutSiteSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    memberships?: organizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganizationNestedInput
    vendorId?: StringFieldUpdateOperationsInput | string
    subdomainId?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutSubdomainInput = {
    id?: string
    name: string
    address?: AddressCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationCreateNestedManyWithoutOrganizationInput
    memberships?: organizationMembershipCreateNestedManyWithoutOrganizationInput
    products?: ProductCreateNestedManyWithoutOrganizationInput
    vendor: VendorCreateNestedOneWithoutOrganizationsInput
    termsAccepted?: boolean
    siteSetting?: SiteSettingCreateNestedOneWithoutOrganizationInput
    orders?: OrderCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUncheckedCreateWithoutSubdomainInput = {
    id?: string
    name: string
    address?: AddressUncheckedCreateNestedOneWithoutOrganizationInput
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    images?: ImageOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    memberships?: organizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganizationInput
    vendorId: string
    termsAccepted?: boolean
    siteSetting?: SiteSettingUncheckedCreateNestedOneWithoutOrganizationInput
    orders?: OrderUncheckedCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationCreateOrConnectWithoutSubdomainInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSubdomainInput, OrganizationUncheckedCreateWithoutSubdomainInput>
  }

  export type OrganizationCreateManySubdomainInputEnvelope = {
    data: Enumerable<OrganizationCreateManySubdomainInput>
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithWhereUniqueWithoutSubdomainInput = {
    where: OrganizationWhereUniqueInput
    update: XOR<OrganizationUpdateWithoutSubdomainInput, OrganizationUncheckedUpdateWithoutSubdomainInput>
    create: XOR<OrganizationCreateWithoutSubdomainInput, OrganizationUncheckedCreateWithoutSubdomainInput>
  }

  export type OrganizationUpdateWithWhereUniqueWithoutSubdomainInput = {
    where: OrganizationWhereUniqueInput
    data: XOR<OrganizationUpdateWithoutSubdomainInput, OrganizationUncheckedUpdateWithoutSubdomainInput>
  }

  export type OrganizationUpdateManyWithWhereWithoutSubdomainInput = {
    where: OrganizationScalarWhereInput
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type AddressCreateManyUserInput = {
    id?: string
    street1: string
    street2?: string | null
    city: string
    state: string
    zipcode: string
    country: string
    countryCode?: string | null
    coordinateId?: string | null
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUserCreateManyUserInput = {
    id?: string
    location: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    rating: number
    comment?: string | null
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipCreateManyUserInput = {
    id?: string
    role: MembershipRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    total: number
    status?: OrderStatus
    driverId?: string | null
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: CoordinatesUpdateOneWithoutAddressesNestedInput
    organization?: OrganizationUpdateOneWithoutAddressNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    coordinateId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    coordinateId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUserUncheckedUpdateManyWithoutImageUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | MembershipRole
    organizations?: organizationMembershipUpdateManyWithoutMembershipNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | MembershipRole
    organizations?: organizationMembershipUncheckedUpdateManyWithoutMembershipNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUncheckedUpdateManyWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | MembershipRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    items?: ProductUpdateManyWithoutOrdersNestedInput
    driver?: DriverUpdateOneWithoutOrdersNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutOrdersNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    items?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyDriverInput = {
    id?: string
    total: number
    status?: OrderStatus
    customerId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    items?: ProductUpdateManyWithoutOrdersNestedInput
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutOrdersNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    items?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    customerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateManyVendorInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    subdomainId: string
    termsAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUpdateManyWithoutOrganizationNestedInput
    memberships?: organizationMembershipUpdateManyWithoutOrganizationNestedInput
    products?: ProductUpdateManyWithoutOrganizationNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    subdomain?: SubDomainUpdateOneRequiredWithoutOrganizationNestedInput
    siteSetting?: SiteSettingUpdateOneWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    memberships?: organizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganizationNestedInput
    subdomainId?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    siteSetting?: SiteSettingUncheckedUpdateOneWithoutOrganizationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subdomainId?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyCoordinatesInput = {
    id?: string
    street1: string
    street2?: string | null
    city: string
    state: string
    zipcode: string
    country: string
    countryCode?: string | null
    userId?: string | null
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateWithoutCoordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutAddressNestedInput
    organization?: OrganizationUpdateOneWithoutAddressNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutCoordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationMembershipCreateManyMembershipInput = {
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationMembershipUpdateWithoutMembershipInput = {
    organization?: OrganizationUpdateOneRequiredWithoutMembershipsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationMembershipUncheckedUpdateWithoutMembershipInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationMembershipUncheckedUpdateManyWithoutOrganizationsInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    images?: ImageProductUpdateManyWithoutProductNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProductsNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    images?: ImageProductUncheckedUpdateManyWithoutProductNestedInput
    organizationId?: StringFieldUpdateOperationsInput | string
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    organizationId?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageOrganizationCreateManyOrganizationInput = {
    id?: string
    location: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationMembershipCreateManyOrganizationInput = {
    membershipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    features?: string | null
    unit?: Unit
    size: number
    basePrice: number
    currency: Currency
    discount: number
    quantity: number
    stock: number
    rating?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyOrganizationInput = {
    id?: string
    total: number
    status?: OrderStatus
    customerId: string
    driverId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageOrganizationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageOrganizationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageOrganizationUncheckedUpdateManyWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationMembershipUpdateWithoutOrganizationInput = {
    membership?: MembershipUpdateOneRequiredWithoutOrganizationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationMembershipUncheckedUpdateWithoutOrganizationInput = {
    membershipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationMembershipUncheckedUpdateManyWithoutMembershipsInput = {
    membershipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    images?: ImageProductUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutItemsNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    images?: ImageProductUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutItemsNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    items?: ProductUpdateManyWithoutOrdersNestedInput
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    driver?: DriverUpdateOneWithoutOrdersNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    items?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    customerId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageProductCreateManyProductInput = {
    id?: string
    location: string
    blurhash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyProductInput = {
    id?: string
    rating: number
    comment?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    categoryLists?: CategoryListUpdateManyWithoutCategoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    categoryLists?: CategoryListUncheckedUpdateManyWithoutCategoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageProductUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageProductUncheckedUpdateManyWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    blurhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    driver?: DriverUpdateOneWithoutOrdersNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutOrdersNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | OrderStatus
    customerId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    images?: ImageProductUpdateManyWithoutProductNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutItemsNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: EnumUnitFieldUpdateOperationsInput | Unit
    size?: FloatFieldUpdateOperationsInput | number
    basePrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    discount?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    images?: ImageProductUncheckedUpdateManyWithoutProductNestedInput
    organizationId?: StringFieldUpdateOperationsInput | string
    orders?: OrderUncheckedUpdateManyWithoutItemsNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryListUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryListUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryListUncheckedUpdateManyWithoutCategoryListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpdateWithoutCategoryListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutCategoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutCategoryListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutCategoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpdateWithoutServiceListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateWithoutServiceListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceListUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceListUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceListUncheckedUpdateManyWithoutServiceListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateManySubdomainInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    dialCode?: string | null
    phone?: string | null
    vendorId: string
    termsAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateWithoutSubdomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUpdateManyWithoutOrganizationNestedInput
    memberships?: organizationMembershipUpdateManyWithoutOrganizationNestedInput
    products?: ProductUpdateManyWithoutOrganizationNestedInput
    vendor?: VendorUpdateOneRequiredWithoutOrganizationsNestedInput
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    siteSetting?: SiteSettingUpdateOneWithoutOrganizationNestedInput
    orders?: OrderUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateWithoutSubdomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateOneWithoutOrganizationNestedInput
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    memberships?: organizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganizationNestedInput
    vendorId?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    siteSetting?: SiteSettingUncheckedUpdateOneWithoutOrganizationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOrganizationNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}