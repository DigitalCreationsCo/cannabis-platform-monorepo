---
.modules:
  - MODULE:
      - app/shop
      - app/dashboard
      # WIDGET MODULE NAME IS CONFLICTION WITH BUILD_TYPE, BUILD_CONTEXT, PORT VARIABLES. 
      # THE BEST SOLUTION IS TO USE DOCKER BUILDX BAKE. THE NEXT BEST IS TO CLEAN UP THE ARGUMENTS, OR WRITE EXCEPTION RULES FOR THIS MODULE.
      # - app/checkout-widget
      - server/main
      - server/location
      - server/payments
      - server/image
      # - supertokens

stages:
  - cache
  - build
  # - tag # Future TODO: Add Semantic Versioning to Images
  # https://github.com/semantic-release/semantic-release
  # - lint
  # - test
  # - release
  - deploy

build:
  extends: .module_build
  parallel:
    matrix: !reference [.modules]
  script: |
    echo "CI_COMMIT_BRANCH=$CI_COMMIT_BRANCH"
    echo "CI_DEFAULT_BRANCH=$CI_DEFAULT_BRANCH"
  rules:
  # MR
  # BUILD IMAGE, DON'T PUSH TO REGISTRY.
  # CACHE IT FOR THE MERGE COMMIT.
  # PUSH TO REGISTRY IN THE COMMIT PIPELINE
    # - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      changes:
        - node_modules
        - ${MODULE}/**/*
      # ^THESE PATHS ARE CORRECT TO TRIGGER THE JOB.
      # THE ISSUE HERE IS THE NODE_MODULES ARE NOT PRESENT IF THE CACHE DID NOT TRIGGER.
      # SO IT BRANCHES THIS WAY:
      # 1. CHANGE IS DETECTED IF THE CACHE RUNS, WHETHER THE MODULES ARE CHANGED OR NOT.
      # 2. THE JOB ONLY RUNS IF THE CACHE IS DIFFERENT, AND I DONT KNOW HOW THE CACHE IS TRIGGERED.
      # changes resolves to true if any of the matching files are changed (an OR operation).

      # ^ONE OTHER PROBLEM WITH THIS SETUP IS THE NODE_MODULES IS ALL DEPENDENCIES, AND MAY NOT INCLUDE
      # DEPENDENCIES OF A MODULE. SO MODULES WILL BE POSSIBLY BE BUILT WITH NO DEPENDENCY CHANGE, OR MODULE CHANGE.
      # ONE SOLUTION IS TO WATCH CHANGES FOR NODE_MODULES HERE, AND RUN A SCRIPT IN THE EXTENDED JOB.

      # WHAT IM THINKING IS THIS, FOR EACH MODULE BUILD, RUN A COMMAND THAT WILL CHECK THE MODULE AND DEPENDENCIES FOR CHANGES FROM PREVIOUS REF. SOMETHING LIKE: yarn workspaces foreach checklockfile ${MODULE}. (IF IT EXISTS). 
      # THE IDEA IS FOR EACH MODULE, THE JOB WILL CHECK IF THERE ARE CHANGES IN SOURCE FOR MODULE AND ANY DEPENDENCY PACKAGE. IF SO, THE IMAGE WILL BUILD. IF NOT, THE COMMAND WILL RETURN A CODE, AND THE JOB WILL FAIL, STOPPING THE DOWNSTREAM JOBS FOR THAT PARALLEL. :D

# tag:
#   extends: .module_tag_version
#   parallel:
#     matrix: !reference [.modules]
#   rules:
#     # Default branch
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
# changes:
# - node_modules
# - ${MODULE}/**/*

# publish:
#   extends: .module_publish
#   parallel:
#     matrix: !reference [.modules]
#   rules:
#     # Tags
#     # - if: $CI_COMMIT_TAG =~ /^$IMAGE-v[0-9]+\.[0-9]+\.[0-9]+$/
#     - if: $CI_COMMIT_TAG =~ /.+-v[0-9]+\.[0-9]+\.[0-9]+$/

deploy:
  extends: .module_deploy
  parallel:
    matrix: !reference [.modules]
  rules:
    # is production branch
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      changes:
        - ${MODULE}/**/*

include:
  - .gitlab/ci/cache.gitlab-ci.yml
  - .gitlab/ci/module.gitlab-ci.yml
  - .gitlab/ci/deploy.gitlab-ci.yml
# ========================================
# optimized CI for module builds
# such as each module job can run depending on changes of the module path, and the node_modules dependencies

# check this example for an idea: https://how-to.dev/how-to-set-up-monorepo-build-in-gitlab-ci

# TODO: Understand the parallel matrix: https://docs.gitlab.com/ee/ci/yaml/#parallelmatrix
# Run a one-dimensional matrix of parallel jobs:
# https://docs.gitlab.com/ee/ci/jobs/job_control.html#run-a-one-dimensional-matrix-of-parallel-jobs

# Run a matrix of parallel trigger jobs
# https://docs.gitlab.com/ee/ci/jobs/job_control.html#run-a-matrix-of-parallel-trigger-jobs

# Select different runner tags for each parallel matrix job
# https://docs.gitlab.com/ee/ci/jobs/job_control.html#select-different-runner-tags-for-each-parallel-matrix-job
